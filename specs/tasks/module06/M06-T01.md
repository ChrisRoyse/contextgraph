# M06-T01: Bridge UtlProcessor Trait to Real Implementation

```yaml
metadata:
  id: "M06-T01"
  title: "Bridge UtlProcessor Trait to Real Implementation"
  module: "module-06"
  module_name: "Stub Elimination"
  layer: "foundation"
  priority: "critical"
  created: "2026-01-04"
  updated: "2026-01-04"
  status: "ready"
  dependencies: []
  spec_refs:
    - "constitution.yaml:151-167"  # UTL formula: L = f((ΔS × ΔC) · wₑ · cos φ)
    - "learntheory.md"             # Full UTL theoretical foundation
```

## Problem Statement

**THE REAL `UtlProcessor` EXISTS AND WORKS** but the MCP server uses `StubUtlProcessor` which returns hash-based fake values. The real implementation does NOT implement the core trait interface.

### Current State (VERIFIED 2026-01-04)

**Real Implementation** - `crates/context-graph-utl/src/processor.rs`:
- `UtlProcessor` struct with 385+ passing tests
- SYNC methods (not async)
- `compute_learning(&mut self, content, embedding, context) -> UtlResult<LearningSignal>`
- Has `lifecycle_stage()`, `lambda_weights()`, `interaction_count()`, `computation_count()`, `current_phase()`
- Does NOT implement `context_graph_core::traits::UtlProcessor`
- Does NOT have `get_status()` method returning JSON

**Trait Definition** - `crates/context-graph-core/src/traits/utl_processor.rs`:
```rust
#[async_trait]
pub trait UtlProcessor: Send + Sync {
    async fn compute_learning_score(&self, input: &str, context: &UtlContext) -> CoreResult<f32>;
    async fn compute_surprise(&self, input: &str, context: &UtlContext) -> CoreResult<f32>;
    async fn compute_coherence_change(&self, input: &str, context: &UtlContext) -> CoreResult<f32>;
    async fn compute_emotional_weight(&self, input: &str, context: &UtlContext) -> CoreResult<f32>;
    async fn compute_alignment(&self, input: &str, context: &UtlContext) -> CoreResult<f32>;
    async fn should_consolidate(&self, node: &MemoryNode) -> CoreResult<bool>;
    async fn compute_metrics(&self, input: &str, context: &UtlContext) -> CoreResult<UtlMetrics>;
    fn get_status(&self) -> serde_json::Value;
}
```

**Stub Being Used** - `crates/context-graph-core/src/stubs/utl_stub.rs`:
- Returns hash-based fake values (deterministic but fake)
- `get_status()` returns hardcoded zeros
- Used by MCP server at `server.rs`

## Context

### Key Types Already Exist in `context-graph-utl/src/metrics.rs`:
- `UtlStatus` - Complete UTL system status
- `UtlStatusResponse` - MCP response format with `to_mcp_response()`
- `StageThresholds` - Lifecycle-specific thresholds
- `QuadrantDistribution` - Johari quadrant counts
- `UtlComputationMetrics` - Accumulated computation stats

### UTL Formula (constitution.yaml:152)
```
L = f((ΔS × ΔC) · wₑ · cos φ)
```
- ΔS: entropy/novelty [0,1]
- ΔC: coherence/understanding [0,1]
- wₑ: emotional weight [0.5,1.5]
- φ: phase sync [0,π]

### Marblestone Lifecycle Stages (constitution.yaml:165-167)
| Stage | Interactions | λ_ΔS | λ_ΔC | Focus |
|-------|--------------|------|------|-------|
| Infancy | 0-50 | 0.7 | 0.3 | capture-novelty |
| Growth | 50-500 | 0.5 | 0.5 | balanced |
| Maturity | 500+ | 0.3 | 0.7 | curation-coherence |

## Input Context Files (READ THESE FIRST)

| File | Purpose |
|------|---------|
| `crates/context-graph-core/src/traits/utl_processor.rs` | Trait interface to implement |
| `crates/context-graph-utl/src/processor.rs` | Real UtlProcessor implementation |
| `crates/context-graph-utl/src/metrics.rs` | UtlStatus, UtlStatusResponse, metrics types |
| `crates/context-graph-utl/src/lib.rs` | Public exports from UTL crate |
| `crates/context-graph-core/src/stubs/utl_stub.rs` | Stub to be replaced (reference for JSON schema) |
| `crates/context-graph-core/src/types/utl_types.rs` | UtlContext, UtlMetrics core types |

## Scope

### In Scope
1. Create `UtlProcessorAdapter` in `context-graph-core/src/adapters/utl_adapter.rs`
2. Implement `context_graph_core::traits::UtlProcessor` for the adapter
3. Wrap real `context_graph_utl::processor::UtlProcessor`
4. Bridge async trait methods to sync implementation via `spawn_blocking`
5. Implement `get_status()` returning live metrics as JSON

### Out of Scope
- Modifying the real `UtlProcessor` (it's complete)
- Wiring adapter into MCP server (M06-T10)
- Removing `StubUtlProcessor` (M06-T12)

## Definition of Done

### 1. Create Adapter Module

**File: `crates/context-graph-core/src/adapters/mod.rs`**
```rust
//! Adapters bridging external implementations to core traits.
pub mod utl_adapter;
pub use utl_adapter::UtlProcessorAdapter;
```

**File: `crates/context-graph-core/src/adapters/utl_adapter.rs`**
```rust
use context_graph_utl::processor::UtlProcessor as RealUtlProcessor;
use context_graph_utl::config::UtlConfig;
use context_graph_utl::metrics::UtlStatus;
use crate::traits::UtlProcessor;
use crate::types::{UtlContext, UtlMetrics, MemoryNode};
use crate::error::CoreResult;
use async_trait::async_trait;
use std::sync::Arc;
use tokio::sync::RwLock;

/// Adapter bridging real UtlProcessor to core trait.
///
/// Wraps the synchronous `context_graph_utl::processor::UtlProcessor`
/// and implements the async `context_graph_core::traits::UtlProcessor`.
pub struct UtlProcessorAdapter {
    inner: Arc<RwLock<RealUtlProcessor>>,
    /// Cached status for efficient reads
    cached_status: Arc<RwLock<UtlStatus>>,
}

impl UtlProcessorAdapter {
    /// Create adapter with configuration.
    pub fn new(config: UtlConfig) -> Self;

    /// Create adapter from existing processor.
    pub fn from_processor(processor: RealUtlProcessor) -> Self;

    /// Create with default configuration.
    pub fn with_defaults() -> Self;
}

#[async_trait]
impl UtlProcessor for UtlProcessorAdapter {
    async fn compute_learning_score(&self, input: &str, context: &UtlContext) -> CoreResult<f32>;
    async fn compute_surprise(&self, input: &str, context: &UtlContext) -> CoreResult<f32>;
    async fn compute_coherence_change(&self, input: &str, context: &UtlContext) -> CoreResult<f32>;
    async fn compute_emotional_weight(&self, input: &str, context: &UtlContext) -> CoreResult<f32>;
    async fn compute_alignment(&self, input: &str, context: &UtlContext) -> CoreResult<f32>;
    async fn should_consolidate(&self, node: &MemoryNode) -> CoreResult<bool>;
    async fn compute_metrics(&self, input: &str, context: &UtlContext) -> CoreResult<UtlMetrics>;
    fn get_status(&self) -> serde_json::Value;
}
```

### 2. Modify Cargo.toml

**File: `crates/context-graph-core/Cargo.toml`** - Add:
```toml
[dependencies]
context-graph-utl = { path = "../context-graph-utl", optional = true }

[features]
default = []
real-utl = ["context-graph-utl"]
```

### 3. Update lib.rs

**File: `crates/context-graph-core/src/lib.rs`** - Add:
```rust
#[cfg(feature = "real-utl")]
pub mod adapters;

#[cfg(feature = "real-utl")]
pub use adapters::UtlProcessorAdapter;
```

## Implementation Details

### Async-to-Sync Bridge Pattern

The real `UtlProcessor` uses `&mut self` sync methods. The trait requires async methods. Bridge using `spawn_blocking`:

```rust
async fn compute_learning_score(&self, input: &str, context: &UtlContext) -> CoreResult<f32> {
    let inner = self.inner.clone();
    let input = input.to_string();
    let embedding = context.embedding.clone().unwrap_or_else(|| vec![0.0; 1536]);
    let context_embeddings = context.context_embeddings.clone();

    tokio::task::spawn_blocking(move || {
        let mut processor = inner.blocking_write();
        let signal = processor.compute_learning(&input, &embedding, &context_embeddings)
            .map_err(|e| CoreError::UtlComputation(e.to_string()))?;
        Ok(signal.magnitude)
    })
    .await
    .map_err(|e| CoreError::Internal(e.to_string()))?
}
```

### get_status() Implementation

Use `UtlStatus` from `context-graph-utl/src/metrics.rs`:

```rust
fn get_status(&self) -> serde_json::Value {
    // Use blocking_read since get_status is sync
    let processor = self.inner.blocking_read();

    // Build UtlStatus from processor state
    let status = UtlStatus {
        lifecycle_stage: processor.lifecycle_stage(),
        interaction_count: processor.interaction_count(),
        current_thresholds: StageThresholds::for_stage(processor.lifecycle_stage()),
        lambda_weights: processor.lambda_weights(),
        phase_angle: processor.current_phase(),
        consolidation_phase: ConsolidationPhase::Wake, // Default, update with real oscillator
        metrics: UtlComputationMetrics::default(), // TODO: Track in adapter
    };

    // Convert to MCP response format
    serde_json::to_value(status.to_mcp_response())
        .unwrap_or_else(|_| serde_json::json!({"error": "serialization failed"}))
}
```

### Expected get_status() JSON Schema

Must match `StubUtlProcessor.get_status()` output for drop-in replacement:

```json
{
  "lifecycle_phase": "Growth",
  "interaction_count": 150,
  "entropy": 0.45,
  "coherence": 0.55,
  "learning_score": 0.65,
  "johari_quadrant": "Open",
  "consolidation_phase": "Wake",
  "phase_angle": 1.57,
  "thresholds": {
    "entropy_trigger": 0.7,
    "coherence_trigger": 0.5,
    "min_importance_store": 0.3,
    "consolidation_threshold": 0.5
  }
}
```

## Constraints (ABSOLUTE)

1. **NO BACKWARDS COMPATIBILITY HACKS** - System works or fails fast with clear errors
2. **NO MOCK DATA IN TESTS** - Use real UtlProcessor with real computations
3. **FAIL FAST** - Any computation error must propagate, never silently return defaults
4. **MUST USE `spawn_blocking`** - Never block async runtime (constitution AP-004)
5. **Values from real processor only** - No hardcoded values except schema defaults

## Test Requirements (REAL DATA ONLY)

### Unit Tests - `crates/context-graph-core/src/adapters/utl_adapter.rs`

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_adapter_computes_real_learning_score() {
        let adapter = UtlProcessorAdapter::with_defaults();
        let context = UtlContext {
            embedding: Some(vec![0.1; 1536]),
            context_embeddings: vec![vec![0.15; 1536], vec![0.12; 1536]],
            ..Default::default()
        };

        let score = adapter.compute_learning_score("test input", &context).await;
        assert!(score.is_ok());
        let score = score.unwrap();
        assert!(score >= 0.0 && score <= 1.0, "Score {} not in [0,1]", score);
    }

    #[tokio::test]
    async fn test_adapter_get_status_returns_live_values() {
        let adapter = UtlProcessorAdapter::with_defaults();

        // Compute something first
        let context = UtlContext {
            embedding: Some(vec![0.5; 1536]),
            context_embeddings: vec![],
            ..Default::default()
        };
        let _ = adapter.compute_learning_score("trigger computation", &context).await;

        let status = adapter.get_status();

        // Verify schema
        assert!(status.get("lifecycle_phase").is_some());
        assert!(status.get("interaction_count").is_some());
        assert!(status.get("thresholds").is_some());

        // Verify live values (not zeros from stub)
        let interaction_count = status["interaction_count"].as_u64().unwrap();
        assert!(interaction_count >= 1, "Should reflect real computation count");
    }

    #[tokio::test]
    async fn test_adapter_lifecycle_progression() {
        let adapter = UtlProcessorAdapter::with_defaults();
        let context = UtlContext {
            embedding: Some(vec![0.1; 1536]),
            context_embeddings: vec![],
            ..Default::default()
        };

        // Start in Infancy
        let status = adapter.get_status();
        assert_eq!(status["lifecycle_phase"].as_str().unwrap(), "Infancy");

        // Compute 50 times to trigger Growth
        for i in 0..50 {
            let mut ctx = context.clone();
            ctx.embedding = Some(vec![0.1 + (i as f32 * 0.01); 1536]);
            let _ = adapter.compute_learning_score(&format!("msg {}", i), &ctx).await;
        }

        let status = adapter.get_status();
        assert_eq!(status["lifecycle_phase"].as_str().unwrap(), "Growth");
    }

    #[tokio::test]
    async fn test_adapter_error_propagation() {
        let adapter = UtlProcessorAdapter::with_defaults();

        // Empty embedding should still work (handled by real processor)
        let context = UtlContext {
            embedding: Some(vec![]),
            context_embeddings: vec![],
            ..Default::default()
        };

        let result = adapter.compute_learning_score("test", &context).await;
        // Should either succeed or return meaningful error, NEVER panic
        match result {
            Ok(score) => assert!(score >= 0.0 && score <= 1.0),
            Err(e) => assert!(!e.to_string().is_empty(), "Error must have message"),
        }
    }
}
```

## Verification Commands

```bash
# 1. Build with feature flag
cargo build -p context-graph-core --features real-utl

# 2. Run adapter tests
cargo test -p context-graph-core adapters --features real-utl -- --nocapture

# 3. Verify trait implementation
grep -n "impl UtlProcessor for UtlProcessorAdapter" crates/context-graph-core/src/adapters/utl_adapter.rs

# 4. Verify no stub usage in adapter
grep -c "StubUtlProcessor" crates/context-graph-core/src/adapters/utl_adapter.rs
# Expected: 0

# 5. Verify get_status returns expected fields
cargo test -p context-graph-core test_adapter_get_status --features real-utl -- --nocapture
```

## Full State Verification Protocol

After completing implementation, you MUST perform these verification steps:

### 1. Source of Truth Identification

The source of truth is the **real UtlProcessor state** in `context-graph-utl`:
- `processor.lifecycle_stage()` → lifecycle_phase in JSON
- `processor.interaction_count()` → interaction_count in JSON
- `processor.lambda_weights()` → thresholds.lambda_s/lambda_c
- `processor.current_phase()` → phase_angle

### 2. Execute & Inspect Protocol

After running tests, manually verify the adapter returns live data:

```rust
// In a test or example:
let adapter = UtlProcessorAdapter::with_defaults();

// BEFORE: Check initial state
let status_before = adapter.get_status();
println!("BEFORE: {}", serde_json::to_string_pretty(&status_before).unwrap());

// Execute computation
let context = UtlContext { /* ... */ };
let _ = adapter.compute_learning_score("test", &context).await;

// AFTER: Verify state changed
let status_after = adapter.get_status();
println!("AFTER: {}", serde_json::to_string_pretty(&status_after).unwrap());

// VERIFY: interaction_count increased
assert!(
    status_after["interaction_count"].as_u64() > status_before["interaction_count"].as_u64(),
    "Computation did not update state"
);
```

### 3. Boundary & Edge Case Audit

Test these 3 edge cases and print state before/after:

| Edge Case | Input | Expected Behavior |
|-----------|-------|-------------------|
| Empty embedding | `vec![]` | Return error OR compute with baseline |
| Mismatched dimensions | `vec![0.1; 768]` vs 1536 context | Handle gracefully |
| Maximum context | 1000+ embeddings | Complete < 10ms |

```rust
#[tokio::test]
async fn test_edge_case_empty_embedding() {
    let adapter = UtlProcessorAdapter::with_defaults();

    println!("=== EDGE CASE: Empty Embedding ===");
    println!("BEFORE STATE: {:?}", adapter.get_status());

    let context = UtlContext {
        embedding: Some(vec![]),
        context_embeddings: vec![],
        ..Default::default()
    };

    let result = adapter.compute_learning_score("test", &context).await;
    println!("RESULT: {:?}", result);
    println!("AFTER STATE: {:?}", adapter.get_status());

    // System must not panic - either Ok or Err with clear message
    assert!(result.is_ok() || result.is_err());
}
```

### 4. Evidence of Success

The final verification output must show:

```
=== ADAPTER VERIFICATION REPORT ===
✓ Trait implementation compiles
✓ All 8 trait methods implemented
✓ get_status() returns valid JSON
✓ Values are LIVE (not hardcoded zeros)
✓ Lifecycle stage transitions correctly (Infancy → Growth at n=50)
✓ interaction_count increments on computation
✓ Error propagation works (no silent failures)

Sample get_status() output:
{
  "lifecycle_phase": "Infancy",
  "interaction_count": 5,
  "entropy": 0.234,
  "coherence": 0.567,
  "learning_score": 0.412,
  ...
}

All values above are COMPUTED, not hardcoded.
```

## Manual Output Verification Checklist

Before marking this task complete, you MUST verify:

- [ ] `cargo build -p context-graph-core --features real-utl` succeeds
- [ ] `cargo test -p context-graph-core adapters --features real-utl` passes
- [ ] `get_status()` output contains ALL fields from schema above
- [ ] `interaction_count` increases after each computation
- [ ] `lifecycle_phase` changes from "Infancy" to "Growth" after 50 computations
- [ ] No panics on empty/invalid input (returns Err instead)
- [ ] `grep -c "vec![0.1" crates/context-graph-core/src/adapters/` returns 0

## Final Verification: Sherlock-Holmes Agent

**MANDATORY**: After completing all implementation and tests, you MUST spawn the `sherlock-holmes` subagent to perform forensic verification:

```
Task: Forensic investigation of M06-T01 implementation
- Verify UtlProcessorAdapter exists and implements trait correctly
- Verify get_status() returns live data (not hardcoded)
- Verify async-to-sync bridge uses spawn_blocking
- Verify no stub patterns in adapter code
- Verify all tests use real data (no mocks)
- Report any discrepancies between spec and implementation
```

The task is NOT complete until sherlock-holmes confirms all verification passes.

---

*Task created: 2026-01-04*
*Last updated: 2026-01-04*
*Module: 06 - Stub Elimination*
*Layer: Foundation*
*Priority: CRITICAL*
