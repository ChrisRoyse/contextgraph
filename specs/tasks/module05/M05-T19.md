# M05-T19: Implement LifecycleManager State Machine

```yaml
metadata:
  id: "M05-T19"
  title: "Implement LifecycleManager State Machine"
  module: "module-05"
  module_name: "UTL Integration"
  layer: "surface"
  priority: "critical"
  estimated_hours: 3
  created: "2026-01-04"
  status: "pending"
  dependencies:
    - "M05-T05"
    - "M05-T06"
    - "M05-T07"
  spec_refs:
    - "TECH-UTL-005 Section 3.3"
    - "SPEC-UTL-005 Section 8.3"
    - "REQ-UTL-035"
```

---

## Description

Implement LifecycleManager struct for managing lifecycle state transitions following the Marblestone developmental learning model.

The LifecycleManager tracks the system's developmental stage and applies stage-appropriate learning parameters:
- **Infancy** (0-50 interactions): High novelty seeking (lambda_novelty=0.7)
- **Growth** (50-500 interactions): Balanced exploration/exploitation (lambda_novelty=0.5)
- **Maturity** (500+ interactions): High coherence preservation (lambda_novelty=0.3)

Stage transitions preserve accumulated knowledge coherence (REQ-UTL-035) and adjust storage behavior based on the current storage stance.

---

## File Path

```
crates/context-graph-utl/src/lifecycle/manager.rs
```

---

## Enums and Structs

### StorageStance Enum

```rust
use serde::{Deserialize, Serialize};

/// Represents the system's storage behavior based on lifecycle stage.
///
/// The storage stance determines how aggressively the system stores
/// new memories versus curating existing ones.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Serialize, Deserialize)]
#[repr(u8)]
pub enum StorageStance {
    /// Infancy: Store almost everything, maximize learning
    CaptureHeavy = 0,

    /// Growth: Balanced storage and curation
    Balanced = 1,

    /// Maturity: Selective storage, prioritize coherence
    CurationHeavy = 2,
}

impl StorageStance {
    /// Returns the stance name as a string.
    pub fn name(&self) -> &'static str {
        match self {
            Self::CaptureHeavy => "capture_heavy",
            Self::Balanced => "balanced",
            Self::CurationHeavy => "curation_heavy",
        }
    }

    /// Returns the minimum importance threshold for storage.
    pub fn min_importance(&self) -> f32 {
        match self {
            Self::CaptureHeavy => 0.1,
            Self::Balanced => 0.3,
            Self::CurationHeavy => 0.4,
        }
    }

    /// Returns whether this stance favors exploration over exploitation.
    pub fn is_exploratory(&self) -> bool {
        matches!(self, Self::CaptureHeavy)
    }
}

impl Default for StorageStance {
    fn default() -> Self {
        Self::CaptureHeavy
    }
}
```

### StageThresholds Struct

```rust
/// Stage-specific threshold values for UTL processing.
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct StageThresholds {
    /// Entropy trigger threshold for the current stage
    pub entropy_trigger: f32,

    /// Coherence trigger threshold for the current stage
    pub coherence_trigger: f32,

    /// Minimum importance for storage in the current stage
    pub min_importance_store: f32,

    /// Consolidation threshold for the current stage
    pub consolidation_threshold: f32,
}
```

### LifecycleManager Struct

```rust
use chrono::{DateTime, Utc};
use tracing::{info, warn};

use crate::config::LifecycleConfig;
use crate::lifecycle::lambda::LifecycleLambdaWeights;
use crate::lifecycle::stage::LifecycleStage;

/// Manages lifecycle state transitions for Marblestone developmental learning.
///
/// The lifecycle manager tracks interactions, manages stage transitions,
/// and provides stage-appropriate learning parameters.
///
/// # Lifecycle Stages
/// - **Infancy** (0-50): High novelty seeking, capture-heavy storage
/// - **Growth** (50-500): Balanced learning, balanced storage
/// - **Maturity** (500+): Coherence preservation, curated storage
///
/// # Example
/// ```rust
/// use context_graph_utl::lifecycle::{LifecycleManager, LifecycleConfig};
///
/// let config = LifecycleConfig::default();
/// let mut manager = LifecycleManager::new(config);
///
/// // Initially in Infancy
/// assert_eq!(manager.current_stage(), LifecycleStage::Infancy);
///
/// // Record interactions until transition
/// for _ in 0..50 {
///     manager.record_interaction();
/// }
/// assert_eq!(manager.current_stage(), LifecycleStage::Growth);
/// ```
pub struct LifecycleManager {
    /// Total number of recorded interactions
    interaction_count: u64,

    /// Current lifecycle stage
    current_stage: LifecycleStage,

    /// Current lambda weights for learning modulation
    lambda_weights: LifecycleLambdaWeights,

    /// Configuration parameters
    config: LifecycleConfig,

    /// Timestamp of the last stage transition
    last_transition: Option<DateTime<Utc>>,
}

impl LifecycleManager {
    /// Creates a new LifecycleManager with the given configuration.
    pub fn new(config: LifecycleConfig) -> Self {
        let stage = LifecycleStage::Infancy;
        let lambda_weights = stage.get_lambda_weights();

        Self {
            interaction_count: 0,
            current_stage: stage,
            lambda_weights,
            config,
            last_transition: None,
        }
    }

    /// Records an interaction and checks for stage transitions.
    ///
    /// Increments the interaction count and transitions to the next
    /// lifecycle stage when thresholds are reached:
    /// - Infancy -> Growth at 50 interactions
    /// - Growth -> Maturity at 500 interactions
    ///
    /// # Returns
    /// Some(new_stage) if a transition occurred, None otherwise
    pub fn record_interaction(&mut self) -> Option<LifecycleStage> {
        self.interaction_count += 1;
        self.check_transition()
    }

    /// Records multiple interactions at once.
    ///
    /// Useful for bulk processing or restoration from persistence.
    pub fn record_interactions(&mut self, count: u64) -> Option<LifecycleStage> {
        self.interaction_count += count;
        self.check_transition()
    }

    /// Returns the current lifecycle stage.
    pub fn current_stage(&self) -> LifecycleStage {
        self.current_stage
    }

    /// Returns the current lambda weights for learning modulation.
    pub fn get_lambda_weights(&self) -> LifecycleLambdaWeights {
        self.lambda_weights.clone()
    }

    /// Applies lambda weights to surprise and coherence deltas.
    ///
    /// # Arguments
    /// * `delta_s` - Surprise/entropy delta
    /// * `delta_c` - Coherence delta
    ///
    /// # Returns
    /// Tuple of (weighted_delta_s, weighted_delta_c)
    pub fn apply_lambda_weights(&self, delta_s: f32, delta_c: f32) -> (f32, f32) {
        self.lambda_weights.apply(delta_s, delta_c)
    }

    /// Returns the stage-specific thresholds.
    pub fn get_thresholds(&self) -> StageThresholds {
        let stage_config = match self.current_stage {
            LifecycleStage::Infancy => &self.config.infancy,
            LifecycleStage::Growth => &self.config.growth,
            LifecycleStage::Maturity => &self.config.maturity,
        };

        StageThresholds {
            entropy_trigger: stage_config.entropy_trigger,
            coherence_trigger: stage_config.coherence_trigger,
            min_importance_store: stage_config.min_importance_store,
            consolidation_threshold: stage_config.consolidation_threshold,
        }
    }

    /// Returns the current storage stance based on lifecycle stage.
    pub fn storage_stance(&self) -> StorageStance {
        match self.current_stage {
            LifecycleStage::Infancy => StorageStance::CaptureHeavy,
            LifecycleStage::Growth => StorageStance::Balanced,
            LifecycleStage::Maturity => StorageStance::CurationHeavy,
        }
    }

    /// Determines whether a memory should be stored based on magnitude and importance.
    ///
    /// Storage decision varies by lifecycle stage:
    /// - Infancy: Store if magnitude > 0.1 OR importance > 0.1
    /// - Growth: Store if magnitude > 0.3 AND importance > 0.2
    /// - Maturity: Store if magnitude > 0.4 AND importance > 0.3
    ///
    /// # Arguments
    /// * `magnitude` - Learning magnitude from UTL computation
    /// * `importance` - Computed importance of the memory
    ///
    /// # Returns
    /// true if the memory should be stored
    pub fn should_store(&self, magnitude: f32, importance: f32) -> bool {
        let thresholds = self.get_thresholds();
        let min_importance = thresholds.min_importance_store;

        match self.current_stage {
            LifecycleStage::Infancy => {
                // Capture-heavy: liberal storage
                magnitude > 0.1 || importance > min_importance
            }
            LifecycleStage::Growth => {
                // Balanced: moderate thresholds
                magnitude > 0.3 && importance > min_importance
            }
            LifecycleStage::Maturity => {
                // Curation-heavy: strict thresholds
                magnitude > 0.4 && importance > min_importance
            }
        }
    }

    /// Determines whether consolidation should be triggered.
    ///
    /// # Arguments
    /// * `magnitude` - Learning magnitude
    /// * `importance` - Memory importance
    ///
    /// # Returns
    /// true if consolidation should be triggered
    pub fn should_consolidate(&self, magnitude: f32, importance: f32) -> bool {
        let thresholds = self.get_thresholds();
        magnitude >= thresholds.consolidation_threshold || importance > 0.8
    }

    /// Returns the total interaction count.
    pub fn interaction_count(&self) -> u64 {
        self.interaction_count
    }

    /// Restores the manager to a specific interaction count.
    ///
    /// Used for persistence restoration. Automatically sets the
    /// appropriate lifecycle stage based on the count.
    ///
    /// # Arguments
    /// * `count` - Interaction count to restore
    pub fn restore(&mut self, count: u64) {
        self.interaction_count = count;

        // Determine appropriate stage
        let new_stage = if count < self.config.infancy_threshold {
            LifecycleStage::Infancy
        } else if count < self.config.growth_threshold {
            LifecycleStage::Growth
        } else {
            LifecycleStage::Maturity
        };

        if new_stage != self.current_stage {
            self.transition_to(new_stage);
        }
    }

    /// Returns the timestamp of the last stage transition.
    pub fn last_transition_time(&self) -> Option<DateTime<Utc>> {
        self.last_transition
    }

    /// Returns true if the system is in novelty-seeking mode.
    pub fn is_novelty_seeking(&self) -> bool {
        self.current_stage.is_novelty_seeking()
    }

    /// Returns true if the system is in coherence-preserving mode.
    pub fn is_coherence_preserving(&self) -> bool {
        self.current_stage.is_coherence_preserving()
    }

    // -------------------------------------------------------------------------
    // Private Methods
    // -------------------------------------------------------------------------

    /// Checks for and performs stage transitions.
    fn check_transition(&mut self) -> Option<LifecycleStage> {
        let new_stage = match self.current_stage {
            LifecycleStage::Infancy => {
                if self.interaction_count >= self.config.infancy_threshold {
                    Some(LifecycleStage::Growth)
                } else {
                    None
                }
            }
            LifecycleStage::Growth => {
                if self.interaction_count >= self.config.growth_threshold {
                    Some(LifecycleStage::Maturity)
                } else {
                    None
                }
            }
            LifecycleStage::Maturity => None, // Final stage
        };

        if let Some(stage) = new_stage {
            self.transition_to(stage);
            Some(stage)
        } else {
            None
        }
    }

    /// Performs a stage transition with logging.
    fn transition_to(&mut self, new_stage: LifecycleStage) {
        let old_stage = self.current_stage;

        info!(
            "Lifecycle transition: {} -> {} at {} interactions",
            old_stage.name(),
            new_stage.name(),
            self.interaction_count
        );

        self.current_stage = new_stage;
        self.lambda_weights = new_stage.get_lambda_weights();
        self.last_transition = Some(Utc::now());

        // REQ-UTL-035: Ensure transition preserves coherence
        // This is enforced by using the new stage's coherence-aware weights
        if new_stage.is_coherence_preserving() && !old_stage.is_coherence_preserving() {
            info!(
                "Entering coherence-preserving mode: lambda_consolidation={}",
                self.lambda_weights.lambda_consolidation
            );
        }
    }
}

impl Clone for LifecycleManager {
    fn clone(&self) -> Self {
        Self {
            interaction_count: self.interaction_count,
            current_stage: self.current_stage,
            lambda_weights: self.lambda_weights.clone(),
            config: self.config.clone(),
            last_transition: self.last_transition,
        }
    }
}
```

---

## Acceptance Criteria

- [ ] LifecycleManager struct has all specified fields: interaction_count, current_stage, lambda_weights, config, last_transition
- [ ] record_interaction() increments count and checks for stage transition
- [ ] Stage transitions occur at correct thresholds:
  - [ ] Infancy -> Growth at 50 interactions (configurable via infancy_threshold)
  - [ ] Growth -> Maturity at 500 interactions (configurable via growth_threshold)
- [ ] Lambda weights update correctly on transition:
  - [ ] Infancy: lambda_novelty=0.7, lambda_consolidation=0.3
  - [ ] Growth: lambda_novelty=0.5, lambda_consolidation=0.5
  - [ ] Maturity: lambda_novelty=0.3, lambda_consolidation=0.7
- [ ] get_thresholds() returns stage-specific values from config
- [ ] should_store() varies by storage stance
- [ ] should_consolidate() uses stage-specific threshold
- [ ] restore() sets stage based on count
- [ ] Logging occurs on stage transitions (tracing::info)
- [ ] REQ-UTL-035: Transitions preserve accumulated knowledge coherence

---

## Test File

```
crates/context-graph-utl/tests/lifecycle_tests.rs
```

### Test Cases

```rust
#[cfg(test)]
mod lifecycle_manager_tests {
    use super::*;

    fn default_config() -> LifecycleConfig {
        LifecycleConfig {
            infancy_threshold: 50,
            growth_threshold: 500,
            infancy: StageConfig {
                entropy_trigger: 0.9,
                coherence_trigger: 0.2,
                min_importance_store: 0.1,
                consolidation_threshold: 0.3,
            },
            growth: StageConfig {
                entropy_trigger: 0.7,
                coherence_trigger: 0.4,
                min_importance_store: 0.3,
                consolidation_threshold: 0.5,
            },
            maturity: StageConfig {
                entropy_trigger: 0.6,
                coherence_trigger: 0.5,
                min_importance_store: 0.4,
                consolidation_threshold: 0.6,
            },
        }
    }

    #[test]
    fn test_initial_state_is_infancy() {
        let manager = LifecycleManager::new(default_config());

        assert_eq!(manager.current_stage(), LifecycleStage::Infancy);
        assert_eq!(manager.interaction_count(), 0);
        assert!(manager.is_novelty_seeking());
        assert!(!manager.is_coherence_preserving());
    }

    #[test]
    fn test_infancy_lambda_weights() {
        let manager = LifecycleManager::new(default_config());
        let weights = manager.get_lambda_weights();

        assert!((weights.lambda_novelty - 0.7).abs() < 0.01);
        assert!((weights.lambda_consolidation - 0.3).abs() < 0.01);
    }

    #[test]
    fn test_transition_to_growth() {
        let mut manager = LifecycleManager::new(default_config());

        // Record 49 interactions - still Infancy
        for _ in 0..49 {
            let result = manager.record_interaction();
            assert!(result.is_none());
        }
        assert_eq!(manager.current_stage(), LifecycleStage::Infancy);

        // 50th interaction triggers transition
        let result = manager.record_interaction();
        assert_eq!(result, Some(LifecycleStage::Growth));
        assert_eq!(manager.current_stage(), LifecycleStage::Growth);
    }

    #[test]
    fn test_growth_lambda_weights() {
        let mut manager = LifecycleManager::new(default_config());
        manager.record_interactions(50);

        let weights = manager.get_lambda_weights();
        assert!((weights.lambda_novelty - 0.5).abs() < 0.01);
        assert!((weights.lambda_consolidation - 0.5).abs() < 0.01);
    }

    #[test]
    fn test_transition_to_maturity() {
        let mut manager = LifecycleManager::new(default_config());
        manager.record_interactions(500);

        assert_eq!(manager.current_stage(), LifecycleStage::Maturity);
        assert!(manager.is_coherence_preserving());
    }

    #[test]
    fn test_maturity_lambda_weights() {
        let mut manager = LifecycleManager::new(default_config());
        manager.record_interactions(500);

        let weights = manager.get_lambda_weights();
        assert!((weights.lambda_novelty - 0.3).abs() < 0.01);
        assert!((weights.lambda_consolidation - 0.7).abs() < 0.01);
    }

    #[test]
    fn test_apply_lambda_weights() {
        let manager = LifecycleManager::new(default_config());

        // Infancy: lambda_novelty=0.7, lambda_consolidation=0.3
        let (weighted_s, weighted_c) = manager.apply_lambda_weights(1.0, 1.0);
        assert!((weighted_s - 0.7).abs() < 0.01);
        assert!((weighted_c - 0.3).abs() < 0.01);
    }

    #[test]
    fn test_get_thresholds_by_stage() {
        let mut manager = LifecycleManager::new(default_config());

        // Infancy thresholds
        let infancy_thresholds = manager.get_thresholds();
        assert!((infancy_thresholds.entropy_trigger - 0.9).abs() < 0.01);

        // Growth thresholds
        manager.record_interactions(50);
        let growth_thresholds = manager.get_thresholds();
        assert!((growth_thresholds.entropy_trigger - 0.7).abs() < 0.01);

        // Maturity thresholds
        manager.record_interactions(450);
        let maturity_thresholds = manager.get_thresholds();
        assert!((maturity_thresholds.entropy_trigger - 0.6).abs() < 0.01);
    }

    #[test]
    fn test_storage_stance() {
        let mut manager = LifecycleManager::new(default_config());

        assert_eq!(manager.storage_stance(), StorageStance::CaptureHeavy);

        manager.record_interactions(50);
        assert_eq!(manager.storage_stance(), StorageStance::Balanced);

        manager.record_interactions(450);
        assert_eq!(manager.storage_stance(), StorageStance::CurationHeavy);
    }

    #[test]
    fn test_should_store_infancy_liberal() {
        let manager = LifecycleManager::new(default_config());

        // Infancy: OR logic, low thresholds
        assert!(manager.should_store(0.2, 0.05)); // magnitude > 0.1
        assert!(manager.should_store(0.05, 0.2)); // importance > 0.1
        assert!(!manager.should_store(0.05, 0.05)); // both below
    }

    #[test]
    fn test_should_store_maturity_strict() {
        let mut manager = LifecycleManager::new(default_config());
        manager.record_interactions(500);

        // Maturity: AND logic, high thresholds
        assert!(manager.should_store(0.5, 0.5)); // both above
        assert!(!manager.should_store(0.3, 0.5)); // magnitude too low
        assert!(!manager.should_store(0.5, 0.3)); // importance too low
    }

    #[test]
    fn test_should_consolidate() {
        let mut manager = LifecycleManager::new(default_config());

        // Infancy: consolidation_threshold=0.3
        assert!(!manager.should_consolidate(0.2, 0.5));
        assert!(manager.should_consolidate(0.4, 0.5));
        assert!(manager.should_consolidate(0.2, 0.9)); // high importance always

        // Maturity: consolidation_threshold=0.6
        manager.record_interactions(500);
        assert!(!manager.should_consolidate(0.5, 0.5));
        assert!(manager.should_consolidate(0.7, 0.5));
    }

    #[test]
    fn test_restore() {
        let mut manager = LifecycleManager::new(default_config());

        // Restore to Growth
        manager.restore(100);
        assert_eq!(manager.current_stage(), LifecycleStage::Growth);
        assert_eq!(manager.interaction_count(), 100);

        // Restore to Maturity
        manager.restore(600);
        assert_eq!(manager.current_stage(), LifecycleStage::Maturity);
        assert_eq!(manager.interaction_count(), 600);

        // Restore to Infancy
        manager.restore(25);
        assert_eq!(manager.current_stage(), LifecycleStage::Infancy);
    }

    #[test]
    fn test_last_transition_time() {
        let mut manager = LifecycleManager::new(default_config());

        assert!(manager.last_transition_time().is_none());

        manager.record_interactions(50);
        assert!(manager.last_transition_time().is_some());
    }

    #[test]
    fn test_clone() {
        let mut manager = LifecycleManager::new(default_config());
        manager.record_interactions(100);

        let cloned = manager.clone();
        assert_eq!(manager.interaction_count(), cloned.interaction_count());
        assert_eq!(manager.current_stage(), cloned.current_stage());
    }

    #[test]
    fn test_req_utl_035_coherence_preservation() {
        let mut manager = LifecycleManager::new(default_config());

        // In Infancy, novelty is dominant
        assert!(manager.get_lambda_weights().lambda_novelty > manager.get_lambda_weights().lambda_consolidation);

        // Transition to Maturity
        manager.record_interactions(500);

        // In Maturity, consolidation (coherence) is dominant
        assert!(manager.get_lambda_weights().lambda_consolidation > manager.get_lambda_weights().lambda_novelty);

        // This ensures coherence is preserved as the system matures
    }
}
```

---

## Implementation Notes

1. **Marblestone Model**: Based on developmental learning theory where early stages prioritize exploration and later stages prioritize exploitation
2. **Lambda Weights**: Sum to 1.0, modulate the balance between surprise and coherence in learning
3. **Storage Stance**: Determines how liberal/strict the system is about storing new memories
4. **Transition Logging**: Uses tracing crate for observable stage changes
5. **REQ-UTL-035 Compliance**: Coherence preservation is achieved through increasing lambda_consolidation as system matures
6. **Persistence Integration**: restore() method enables cross-session continuity

---

## Dependencies

| Dependency | Purpose |
|------------|---------|
| M05-T05 | LifecycleStage enum |
| M05-T06 | LifecycleLambdaWeights struct |
| M05-T07 | LifecycleConfig and StageConfig |
| chrono | DateTime for transition timestamps |
| tracing | Logging for stage transitions |

---

## Related Tasks

| Task ID | Relationship |
|---------|--------------|
| M05-T05 | LifecycleStage enum used for stage tracking |
| M05-T06 | LifecycleLambdaWeights for learning modulation |
| M05-T07 | LifecycleConfig provides thresholds |
| M05-T22 | Integrates into UtlProcessor |
| M05-T39 | Persists lifecycle state to RocksDB |
