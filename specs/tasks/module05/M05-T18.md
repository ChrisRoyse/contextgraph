# M05-T18: Implement JohariClassifier with Retrieval Strategies

```yaml
metadata:
  id: "M05-T18"
  title: "Implement JohariClassifier with Retrieval Strategies"
  module: "module-05"
  module_name: "UTL Integration"
  layer: "surface"
  priority: "critical"
  estimated_hours: 2.5
  created: "2026-01-04"
  status: "pending"
  dependencies:
    - "M05-T08"
  spec_refs:
    - "TECH-UTL-005 Section 4.2"
    - "SPEC-UTL-005 Section 7"
```

---

## Description

Implement JohariClassifier struct for quadrant classification based on entropy (delta_s) and coherence (delta_c).

The Johari Window model classifies knowledge states into four quadrants:
- **Open** (low entropy, high coherence): Well-understood, confidently retrievable
- **Blind** (high entropy, low coherence): Unknown unknowns, requires exploration
- **Hidden** (low entropy, low coherence): Known but disconnected, needs integration
- **Unknown** (high entropy, high coherence): Novel but fitting, epistemic opportunity

Each quadrant has associated:
- **Suggested Action**: What the system should do (DirectRecall, TriggerDream, etc.)
- **Retrieval Strategy**: How to search (depth, neighbors, confidence, max_results)

---

## File Path

```
crates/context-graph-utl/src/johari/classifier.rs
```

---

## Classification Logic

| Quadrant | Entropy (delta_s) | Coherence (delta_c) | Suggested Action |
|----------|-------------------|---------------------|------------------|
| Open     | < threshold       | >= threshold        | DirectRecall     |
| Blind    | >= threshold      | < threshold         | TriggerDream     |
| Hidden   | < threshold       | < threshold         | GetNeighborhood  |
| Unknown  | >= threshold      | >= threshold        | EpistemicAction  |

Default thresholds: entropy_threshold = 0.5, coherence_threshold = 0.5

---

## Structs

### RetrievalStrategy

```rust
use serde::{Deserialize, Serialize};

/// Configuration for retrieval based on Johari quadrant.
///
/// Different quadrants require different search strategies:
/// - Open: Shallow, confident retrieval
/// - Unknown: Deep, exploratory search
/// - Blind: Dream-like association discovery
/// - Hidden: Neighborhood exploration
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct RetrievalStrategy {
    /// How deep to search in the graph (1 = immediate, 4 = extensive)
    pub search_depth: u32,

    /// Whether to include neighboring nodes in results
    pub include_neighbors: bool,

    /// Minimum confidence threshold for including results
    pub confidence_threshold: f32,

    /// Maximum number of results to return
    pub max_results: usize,

    /// Whether to enable fuzzy/associative matching
    pub fuzzy_matching: bool,

    /// Minimum similarity score for inclusion
    pub min_similarity: f32,
}

impl RetrievalStrategy {
    /// Strategy for Open quadrant: direct, confident retrieval
    pub fn for_open() -> Self {
        Self {
            search_depth: 1,
            include_neighbors: false,
            confidence_threshold: 0.8,
            max_results: 5,
            fuzzy_matching: false,
            min_similarity: 0.85,
        }
    }

    /// Strategy for Blind quadrant: exploratory dream-like search
    pub fn for_blind() -> Self {
        Self {
            search_depth: 3,
            include_neighbors: true,
            confidence_threshold: 0.4,
            max_results: 20,
            fuzzy_matching: true,
            min_similarity: 0.5,
        }
    }

    /// Strategy for Hidden quadrant: neighborhood exploration
    pub fn for_hidden() -> Self {
        Self {
            search_depth: 2,
            include_neighbors: true,
            confidence_threshold: 0.6,
            max_results: 15,
            fuzzy_matching: false,
            min_similarity: 0.7,
        }
    }

    /// Strategy for Unknown quadrant: deep epistemic exploration
    pub fn for_unknown() -> Self {
        Self {
            search_depth: 4,
            include_neighbors: true,
            confidence_threshold: 0.3,
            max_results: 30,
            fuzzy_matching: true,
            min_similarity: 0.4,
        }
    }
}

impl Default for RetrievalStrategy {
    fn default() -> Self {
        Self::for_open()
    }
}
```

### QuadrantTransition

```rust
/// Represents a transition between Johari quadrants.
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct QuadrantTransition {
    /// Previous quadrant
    pub from: JohariQuadrant,

    /// New quadrant
    pub to: JohariQuadrant,

    /// Previous entropy value
    pub old_entropy: f32,

    /// Previous coherence value
    pub old_coherence: f32,

    /// New entropy value
    pub new_entropy: f32,

    /// New coherence value
    pub new_coherence: f32,
}

impl QuadrantTransition {
    /// Returns true if this is a significant transition.
    ///
    /// Significant transitions are those that cross quadrant boundaries.
    pub fn is_significant(&self) -> bool {
        self.from != self.to
    }

    /// Returns true if moving toward better understanding (Open quadrant).
    pub fn is_improving(&self) -> bool {
        matches!(self.to, JohariQuadrant::Open)
            && !matches!(self.from, JohariQuadrant::Open)
    }

    /// Returns true if moving toward uncertainty.
    pub fn is_degrading(&self) -> bool {
        matches!(self.from, JohariQuadrant::Open)
            && !matches!(self.to, JohariQuadrant::Open)
    }
}
```

### JohariClassifier

```rust
use crate::config::JohariConfig;
use crate::johari::quadrant::{JohariQuadrant, SuggestedAction};

/// Classifies knowledge states into Johari Window quadrants.
///
/// The classifier uses entropy (surprise/novelty) and coherence
/// (fit with existing knowledge) to determine the quadrant.
///
/// # Quadrant Meanings
/// - **Open**: Well-understood, retrieve directly
/// - **Blind**: Unknown unknowns, explore associatively
/// - **Hidden**: Known but disconnected, integrate neighborhoods
/// - **Unknown**: Novel but coherent, epistemic opportunity
///
/// # Example
/// ```rust
/// use context_graph_utl::johari::{JohariClassifier, JohariConfig};
///
/// let config = JohariConfig::default();
/// let classifier = JohariClassifier::new(config);
///
/// // Low entropy, high coherence -> Open
/// let quadrant = classifier.classify(0.3, 0.7);
/// assert_eq!(quadrant, JohariQuadrant::Open);
///
/// // High entropy, low coherence -> Blind
/// let quadrant = classifier.classify(0.7, 0.3);
/// assert_eq!(quadrant, JohariQuadrant::Blind);
/// ```
pub struct JohariClassifier {
    /// Configuration with threshold values
    config: JohariConfig,
}

impl JohariClassifier {
    /// Creates a new JohariClassifier with the given configuration.
    pub fn new(config: JohariConfig) -> Self {
        Self { config }
    }

    /// Classifies a knowledge state into a Johari quadrant.
    ///
    /// # Arguments
    /// * `delta_s` - Entropy/surprise value in [0, 1]
    /// * `delta_c` - Coherence value in [0, 1]
    ///
    /// # Returns
    /// The appropriate JohariQuadrant
    pub fn classify(&self, delta_s: f32, delta_c: f32) -> JohariQuadrant {
        let low_entropy = delta_s < self.config.entropy_threshold;
        let high_coherence = delta_c >= self.config.coherence_threshold;

        match (low_entropy, high_coherence) {
            (true, true) => JohariQuadrant::Open,
            (false, false) => JohariQuadrant::Blind,
            (true, false) => JohariQuadrant::Hidden,
            (false, true) => JohariQuadrant::Unknown,
        }
    }

    /// Returns the suggested action for a given quadrant.
    ///
    /// # Actions
    /// - Open: DirectRecall - retrieve with high confidence
    /// - Blind: TriggerDream - exploratory association
    /// - Hidden: GetNeighborhood - expand connections
    /// - Unknown: EpistemicAction - investigate novelty
    pub fn suggested_action(&self, quadrant: JohariQuadrant) -> SuggestedAction {
        match quadrant {
            JohariQuadrant::Open => SuggestedAction::DirectRecall,
            JohariQuadrant::Blind => SuggestedAction::TriggerDream,
            JohariQuadrant::Hidden => SuggestedAction::GetNeighborhood,
            JohariQuadrant::Unknown => SuggestedAction::EpistemicAction,
        }
    }

    /// Returns the retrieval strategy for a given quadrant.
    ///
    /// Different quadrants require different search approaches:
    /// - Open: Shallow, confident (depth=1, max=5)
    /// - Blind: Deep, exploratory (depth=3, max=20)
    /// - Hidden: Neighborhood-focused (depth=2, max=15)
    /// - Unknown: Extensive exploration (depth=4, max=30)
    pub fn retrieval_strategy(&self, quadrant: JohariQuadrant) -> RetrievalStrategy {
        match quadrant {
            JohariQuadrant::Open => RetrievalStrategy::for_open(),
            JohariQuadrant::Blind => RetrievalStrategy::for_blind(),
            JohariQuadrant::Hidden => RetrievalStrategy::for_hidden(),
            JohariQuadrant::Unknown => RetrievalStrategy::for_unknown(),
        }
    }

    /// Detects a quadrant transition between two states.
    ///
    /// # Arguments
    /// * `old_s` - Previous entropy value
    /// * `old_c` - Previous coherence value
    /// * `new_s` - New entropy value
    /// * `new_c` - New coherence value
    ///
    /// # Returns
    /// Some(QuadrantTransition) if quadrant changed, None otherwise
    pub fn detect_transition(
        &self,
        old_s: f32,
        old_c: f32,
        new_s: f32,
        new_c: f32,
    ) -> Option<QuadrantTransition> {
        let old_quadrant = self.classify(old_s, old_c);
        let new_quadrant = self.classify(new_s, new_c);

        if old_quadrant != new_quadrant {
            Some(QuadrantTransition {
                from: old_quadrant,
                to: new_quadrant,
                old_entropy: old_s,
                old_coherence: old_c,
                new_entropy: new_s,
                new_coherence: new_c,
            })
        } else {
            None
        }
    }

    /// Classifies and returns both quadrant and suggested action.
    pub fn classify_with_action(
        &self,
        delta_s: f32,
        delta_c: f32,
    ) -> (JohariQuadrant, SuggestedAction) {
        let quadrant = self.classify(delta_s, delta_c);
        let action = self.suggested_action(quadrant);
        (quadrant, action)
    }

    /// Classifies and returns quadrant, action, and retrieval strategy.
    pub fn classify_full(
        &self,
        delta_s: f32,
        delta_c: f32,
    ) -> (JohariQuadrant, SuggestedAction, RetrievalStrategy) {
        let quadrant = self.classify(delta_s, delta_c);
        let action = self.suggested_action(quadrant);
        let strategy = self.retrieval_strategy(quadrant);
        (quadrant, action, strategy)
    }

    /// Gets the current threshold configuration.
    pub fn thresholds(&self) -> (f32, f32) {
        (self.config.entropy_threshold, self.config.coherence_threshold)
    }
}
```

---

## Acceptance Criteria

- [ ] JohariClassifier struct with entropy/coherence thresholds from JohariConfig
- [ ] classify() returns correct quadrant based on threshold comparisons
- [ ] suggested_action() maps each quadrant to appropriate SuggestedAction
- [ ] retrieval_strategy() returns quadrant-specific RetrievalStrategy:
  - [ ] Open: depth=1, max_results=5, confidence=0.8
  - [ ] Blind: depth=3, max_results=20, confidence=0.4, fuzzy=true
  - [ ] Hidden: depth=2, max_results=15, include_neighbors=true
  - [ ] Unknown: depth=4, max_results=30, confidence=0.3
- [ ] detect_transition() returns Some when quadrant changes, None otherwise
- [ ] QuadrantTransition includes from/to quadrants and old/new values
- [ ] classify_full() returns quadrant, action, and strategy in one call

---

## Test File

```
crates/context-graph-utl/tests/johari_tests.rs
```

### Test Cases

```rust
#[cfg(test)]
mod johari_classifier_tests {
    use super::*;

    fn default_config() -> JohariConfig {
        JohariConfig {
            entropy_threshold: 0.5,
            coherence_threshold: 0.5,
        }
    }

    #[test]
    fn test_classify_open() {
        let classifier = JohariClassifier::new(default_config());

        // Low entropy, high coherence -> Open
        assert_eq!(classifier.classify(0.3, 0.7), JohariQuadrant::Open);
        assert_eq!(classifier.classify(0.1, 0.9), JohariQuadrant::Open);
        assert_eq!(classifier.classify(0.49, 0.51), JohariQuadrant::Open);
    }

    #[test]
    fn test_classify_blind() {
        let classifier = JohariClassifier::new(default_config());

        // High entropy, low coherence -> Blind
        assert_eq!(classifier.classify(0.7, 0.3), JohariQuadrant::Blind);
        assert_eq!(classifier.classify(0.9, 0.1), JohariQuadrant::Blind);
        assert_eq!(classifier.classify(0.51, 0.49), JohariQuadrant::Blind);
    }

    #[test]
    fn test_classify_hidden() {
        let classifier = JohariClassifier::new(default_config());

        // Low entropy, low coherence -> Hidden
        assert_eq!(classifier.classify(0.3, 0.3), JohariQuadrant::Hidden);
        assert_eq!(classifier.classify(0.1, 0.1), JohariQuadrant::Hidden);
        assert_eq!(classifier.classify(0.49, 0.49), JohariQuadrant::Hidden);
    }

    #[test]
    fn test_classify_unknown() {
        let classifier = JohariClassifier::new(default_config());

        // High entropy, high coherence -> Unknown
        assert_eq!(classifier.classify(0.7, 0.7), JohariQuadrant::Unknown);
        assert_eq!(classifier.classify(0.9, 0.9), JohariQuadrant::Unknown);
        assert_eq!(classifier.classify(0.51, 0.51), JohariQuadrant::Unknown);
    }

    #[test]
    fn test_suggested_actions() {
        let classifier = JohariClassifier::new(default_config());

        assert_eq!(
            classifier.suggested_action(JohariQuadrant::Open),
            SuggestedAction::DirectRecall
        );
        assert_eq!(
            classifier.suggested_action(JohariQuadrant::Blind),
            SuggestedAction::TriggerDream
        );
        assert_eq!(
            classifier.suggested_action(JohariQuadrant::Hidden),
            SuggestedAction::GetNeighborhood
        );
        assert_eq!(
            classifier.suggested_action(JohariQuadrant::Unknown),
            SuggestedAction::EpistemicAction
        );
    }

    #[test]
    fn test_retrieval_strategy_open() {
        let classifier = JohariClassifier::new(default_config());
        let strategy = classifier.retrieval_strategy(JohariQuadrant::Open);

        assert_eq!(strategy.search_depth, 1);
        assert_eq!(strategy.max_results, 5);
        assert!(!strategy.include_neighbors);
        assert!((strategy.confidence_threshold - 0.8).abs() < 0.01);
        assert!(!strategy.fuzzy_matching);
    }

    #[test]
    fn test_retrieval_strategy_unknown() {
        let classifier = JohariClassifier::new(default_config());
        let strategy = classifier.retrieval_strategy(JohariQuadrant::Unknown);

        assert_eq!(strategy.search_depth, 4);
        assert_eq!(strategy.max_results, 30);
        assert!(strategy.include_neighbors);
        assert!((strategy.confidence_threshold - 0.3).abs() < 0.01);
        assert!(strategy.fuzzy_matching);
    }

    #[test]
    fn test_detect_transition_quadrant_change() {
        let classifier = JohariClassifier::new(default_config());

        // Open -> Blind (entropy increased, coherence decreased)
        let transition = classifier.detect_transition(0.3, 0.7, 0.7, 0.3);
        assert!(transition.is_some());

        let t = transition.unwrap();
        assert_eq!(t.from, JohariQuadrant::Open);
        assert_eq!(t.to, JohariQuadrant::Blind);
        assert!(t.is_significant());
        assert!(t.is_degrading());
    }

    #[test]
    fn test_detect_transition_no_change() {
        let classifier = JohariClassifier::new(default_config());

        // Stays in Open quadrant
        let transition = classifier.detect_transition(0.3, 0.7, 0.35, 0.65);
        assert!(transition.is_none());
    }

    #[test]
    fn test_detect_transition_improving() {
        let classifier = JohariClassifier::new(default_config());

        // Blind -> Open (entropy decreased, coherence increased)
        let transition = classifier.detect_transition(0.7, 0.3, 0.3, 0.7);
        assert!(transition.is_some());

        let t = transition.unwrap();
        assert!(t.is_improving());
        assert!(!t.is_degrading());
    }

    #[test]
    fn test_classify_with_action() {
        let classifier = JohariClassifier::new(default_config());

        let (quadrant, action) = classifier.classify_with_action(0.3, 0.7);
        assert_eq!(quadrant, JohariQuadrant::Open);
        assert_eq!(action, SuggestedAction::DirectRecall);
    }

    #[test]
    fn test_classify_full() {
        let classifier = JohariClassifier::new(default_config());

        let (quadrant, action, strategy) = classifier.classify_full(0.7, 0.7);
        assert_eq!(quadrant, JohariQuadrant::Unknown);
        assert_eq!(action, SuggestedAction::EpistemicAction);
        assert_eq!(strategy.search_depth, 4);
    }

    #[test]
    fn test_custom_thresholds() {
        let config = JohariConfig {
            entropy_threshold: 0.3,
            coherence_threshold: 0.7,
        };
        let classifier = JohariClassifier::new(config);

        // With lower entropy threshold, 0.4 is now high entropy
        assert_eq!(classifier.classify(0.4, 0.8), JohariQuadrant::Unknown);

        // With higher coherence threshold, 0.6 is now low coherence
        assert_eq!(classifier.classify(0.2, 0.6), JohariQuadrant::Hidden);
    }

    #[test]
    fn test_thresholds_getter() {
        let config = JohariConfig {
            entropy_threshold: 0.4,
            coherence_threshold: 0.6,
        };
        let classifier = JohariClassifier::new(config);

        let (e, c) = classifier.thresholds();
        assert_eq!(e, 0.4);
        assert_eq!(c, 0.6);
    }
}
```

---

## Implementation Notes

1. **Threshold Logic**: Low entropy means delta_s < threshold; high coherence means delta_c >= threshold
2. **Retrieval Strategies**: Each quadrant has carefully tuned search parameters
3. **Transition Detection**: Important for logging and steering system behavior
4. **Fuzzy Matching**: Only enabled for Blind and Unknown quadrants where exploration is valuable
5. **Performance**: Classification is O(1) - just threshold comparisons

---

## Dependencies

| Dependency | Purpose |
|------------|---------|
| M05-T08 | JohariQuadrant and SuggestedAction enums |
| M05-T33 | JohariConfig struct |
| serde | Serialization for RetrievalStrategy |

---

## Related Tasks

| Task ID | Relationship |
|---------|--------------|
| M05-T08 | Provides JohariQuadrant and SuggestedAction types |
| M05-T22 | Integrates classifier into UtlProcessor |
| M05-T33 | Provides JohariConfig configuration |
| M05-T37 | Maps quadrant to MCP verbosity tier |
| M05-T38 | Uses retrieval strategy in inject_context |
