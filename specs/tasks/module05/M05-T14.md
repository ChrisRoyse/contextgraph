# M05-T14: Implement Structural Coherence and Contradiction Detection

| Field | Value |
|-------|-------|
| **Task ID** | M05-T14 |
| **Module** | context-graph-utl |
| **Status** | Pending |
| **Priority** | P1 (High) |
| **Depends On** | M05-T13 (CoherenceTracker with Semantic Coherence) |
| **Estimated Hours** | 2 |
| **Constitution Refs** | TECH-UTL-005 Section 6, SPEC-UTL-005 Section 4.2 |

---

## Executive Summary

Extend the `CoherenceTracker` with structural coherence and contradiction detection capabilities. Structural coherence measures how well new content integrates with the knowledge graph topology, while contradiction detection identifies conflicts with existing knowledge.

**Key Features:**
- Structural coherence based on graph connectivity
- Contradiction detection via similarity search
- Combined coherence formula with penalty application
- Graceful degradation when graph is unavailable

---

## Implementation Requirements

### File Location

**Source File:** `crates/context-graph-utl/src/coherence/structural.rs`

New file extending the coherence module with structural analysis.

### Module Structure Update

```rust
// In crates/context-graph-utl/src/coherence/mod.rs
pub mod tracker;
pub mod structural;

pub use tracker::{
    CoherenceEntry,
    CoherenceWindow,
    CoherenceTracker,
    CoherenceStats,
    KnowledgeGraphRef,
};
pub use structural::{
    StructuralCoherenceCalculator,
    ContradictionDetector,
    ContradictionResult,
};
```

### Structural Coherence Calculator

```rust
use crate::config::CoherenceConfig;
use super::tracker::KnowledgeGraphRef;
use std::sync::Arc;
use uuid::Uuid;

/// Calculator for structural coherence based on graph topology.
///
/// Structural coherence measures how well new content integrates with
/// the existing knowledge graph structure, considering:
/// - Edge connectivity
/// - Neighborhood density
/// - Path distances to related concepts
///
/// # Example
///
/// ```rust
/// use context_graph_utl::coherence::StructuralCoherenceCalculator;
///
/// let calculator = StructuralCoherenceCalculator::new(config, Some(graph));
/// let coherence = calculator.compute(node_id, &embedding);
/// ```
#[derive(Debug)]
pub struct StructuralCoherenceCalculator {
    /// Configuration parameters
    config: CoherenceConfig,

    /// Optional knowledge graph reference
    graph: Option<Arc<dyn KnowledgeGraphRef>>,
}

impl StructuralCoherenceCalculator {
    /// Create a new structural coherence calculator.
    ///
    /// # Arguments
    ///
    /// * `config` - Coherence configuration parameters
    /// * `graph` - Optional knowledge graph reference
    pub fn new(config: CoherenceConfig, graph: Option<Arc<dyn KnowledgeGraphRef>>) -> Self {
        Self { config, graph }
    }

    /// Compute structural coherence for a node.
    ///
    /// # Arguments
    ///
    /// * `node_id` - The node to evaluate (may be new, not yet in graph)
    /// * `embedding` - The node's embedding vector
    ///
    /// # Returns
    ///
    /// Structural coherence score in range [0, 1]
    ///
    /// # Fallback
    ///
    /// Returns `default_coherence_empty` when graph is unavailable
    pub fn compute(&self, node_id: Option<Uuid>, embedding: &[f32]) -> f32 {
        let graph = match &self.graph {
            Some(g) => g,
            None => return self.config.default_coherence_empty,
        };

        // Find similar nodes in the graph
        let similar = graph.search_similar(embedding, self.config.contradiction_search_k);

        if similar.is_empty() {
            return self.config.default_coherence_no_concepts;
        }

        // Compute connectivity-based coherence
        let connectivity_score = self.compute_connectivity_score(&similar, graph);

        // Compute neighborhood density
        let density_score = self.compute_density_score(&similar, graph);

        // Combine scores (weighted average)
        let structural = 0.6 * connectivity_score + 0.4 * density_score;

        structural.clamp(0.0, 1.0)
    }

    /// Compute coherence based on edge connectivity of similar nodes.
    fn compute_connectivity_score(
        &self,
        similar_nodes: &[(Uuid, f32)],
        graph: &Arc<dyn KnowledgeGraphRef>,
    ) -> f32 {
        if similar_nodes.is_empty() {
            return 0.0;
        }

        let mut total_edges = 0usize;
        let mut weighted_edges = 0.0f32;

        for (node_id, similarity) in similar_nodes {
            let edge_count = graph.edge_count(*node_id);
            total_edges += edge_count;
            weighted_edges += edge_count as f32 * similarity;
        }

        // Normalize: assume well-connected nodes have ~10+ edges
        let avg_edges = if similar_nodes.is_empty() {
            0.0
        } else {
            total_edges as f32 / similar_nodes.len() as f32
        };

        // Sigmoid-like normalization to [0, 1]
        // More edges = higher structural coherence
        let normalized = 1.0 - (-avg_edges / 10.0).exp();

        normalized.clamp(0.0, 1.0)
    }

    /// Compute neighborhood density score.
    fn compute_density_score(
        &self,
        similar_nodes: &[(Uuid, f32)],
        _graph: &Arc<dyn KnowledgeGraphRef>,
    ) -> f32 {
        if similar_nodes.is_empty() {
            return 0.0;
        }

        // Average similarity to nearby nodes indicates neighborhood density
        let avg_similarity: f32 = similar_nodes.iter().map(|(_, s)| s).sum::<f32>()
            / similar_nodes.len() as f32;

        // Higher average similarity = denser neighborhood = higher coherence
        avg_similarity.clamp(0.0, 1.0)
    }

    /// Check if graph is available.
    pub fn has_graph(&self) -> bool {
        self.graph.is_some()
    }
}
```

### Contradiction Detector

```rust
/// Result of contradiction detection.
#[derive(Debug, Clone)]
pub struct ContradictionResult {
    /// Whether a contradiction was detected
    pub has_contradiction: bool,

    /// Penalty to apply to coherence (0.0 = no penalty, max = max_contradiction_penalty)
    pub penalty: f32,

    /// IDs of conflicting nodes (if any)
    pub conflicting_nodes: Vec<Uuid>,

    /// Similarity scores to conflicting nodes
    pub conflict_scores: Vec<f32>,

    /// Human-readable explanation
    pub explanation: Option<String>,
}

impl ContradictionResult {
    /// Create a result indicating no contradiction.
    pub fn none() -> Self {
        Self {
            has_contradiction: false,
            penalty: 0.0,
            conflicting_nodes: Vec::new(),
            conflict_scores: Vec::new(),
            explanation: None,
        }
    }

    /// Create a result with detected contradiction.
    pub fn detected(
        penalty: f32,
        conflicting_nodes: Vec<Uuid>,
        conflict_scores: Vec<f32>,
        explanation: String,
    ) -> Self {
        Self {
            has_contradiction: true,
            penalty,
            conflicting_nodes,
            conflict_scores,
            explanation: Some(explanation),
        }
    }
}

/// Detector for contradictions with existing knowledge.
///
/// Identifies potential conflicts between new content and existing
/// graph knowledge by analyzing semantic similarity patterns.
///
/// # Detection Strategy
///
/// A contradiction is suspected when:
/// 1. Very high similarity to existing nodes (> similarity_threshold)
/// 2. BUT the content appears to assert different/opposite claims
///
/// # Example
///
/// ```rust
/// use context_graph_utl::coherence::ContradictionDetector;
///
/// let detector = ContradictionDetector::new(config, Some(graph));
/// let result = detector.detect(&embedding, Some(content));
/// if result.has_contradiction {
///     println!("Penalty: {}", result.penalty);
/// }
/// ```
#[derive(Debug)]
pub struct ContradictionDetector {
    /// Configuration parameters
    config: CoherenceConfig,

    /// Optional knowledge graph reference
    graph: Option<Arc<dyn KnowledgeGraphRef>>,
}

impl ContradictionDetector {
    /// Create a new contradiction detector.
    pub fn new(config: CoherenceConfig, graph: Option<Arc<dyn KnowledgeGraphRef>>) -> Self {
        Self { config, graph }
    }

    /// Detect potential contradictions with existing knowledge.
    ///
    /// # Arguments
    ///
    /// * `embedding` - Embedding of the new content
    /// * `content` - Optional text content for analysis
    ///
    /// # Returns
    ///
    /// ContradictionResult indicating whether a contradiction was found
    /// and the associated penalty.
    pub fn detect(&self, embedding: &[f32], content: Option<&str>) -> ContradictionResult {
        let graph = match &self.graph {
            Some(g) => g,
            None => return ContradictionResult::none(),
        };

        // Search for highly similar nodes that might conflict
        let similar = graph.search_similar(embedding, self.config.contradiction_search_k);

        // Filter to very high similarity matches (potential contradictions)
        let potential_conflicts: Vec<(Uuid, f32)> = similar
            .into_iter()
            .filter(|(_, sim)| *sim >= self.config.contradiction_similarity_threshold)
            .collect();

        if potential_conflicts.is_empty() {
            return ContradictionResult::none();
        }

        // Analyze potential conflicts
        // For now, use a heuristic: very high similarity without being identical
        // suggests potential contradiction (same topic, different claims)
        //
        // A more sophisticated implementation would:
        // 1. Load the content of conflicting nodes
        // 2. Use NLI or semantic analysis to detect actual contradictions
        // 3. Consider edge types (supports vs. contradicts)

        let max_similarity = potential_conflicts.iter().map(|(_, s)| *s).fold(0.0f32, f32::max);

        // Heuristic: similarity in [0.85, 0.98] range suggests potential conflict
        // (Very high but not identical)
        let is_potential_conflict = max_similarity >= 0.85 && max_similarity < 0.98;

        if is_potential_conflict {
            // Calculate penalty based on number and strength of conflicts
            let avg_conflict_score: f32 = potential_conflicts.iter().map(|(_, s)| s).sum::<f32>()
                / potential_conflicts.len() as f32;

            let penalty = (avg_conflict_score - self.config.contradiction_similarity_threshold)
                / (1.0 - self.config.contradiction_similarity_threshold)
                * self.config.max_contradiction_penalty;

            let (node_ids, scores): (Vec<Uuid>, Vec<f32>) = potential_conflicts.into_iter().unzip();

            let explanation = format!(
                "High similarity ({:.2}) to {} existing nodes suggests potential semantic conflict",
                avg_conflict_score,
                node_ids.len()
            );

            ContradictionResult::detected(penalty.clamp(0.0, self.config.max_contradiction_penalty), node_ids, scores, explanation)
        } else {
            ContradictionResult::none()
        }
    }

    /// Check if graph is available for detection.
    pub fn has_graph(&self) -> bool {
        self.graph.is_some()
    }
}
```

### Extended CoherenceTracker Methods

Add these methods to the `CoherenceTracker` struct in `tracker.rs`:

```rust
impl CoherenceTracker {
    // ... existing methods ...

    /// Compute full coherence including structural and contradiction components.
    ///
    /// # Formula
    ///
    /// ```text
    /// coherence = (semantic_weight * semantic + structural_weight * structural)
    ///             * (1 - contradiction_penalty)
    /// ```
    ///
    /// # Arguments
    ///
    /// * `embedding` - Embedding of the new content
    /// * `content` - Optional text content
    /// * `node_id` - Optional node ID (for structural coherence)
    ///
    /// # Returns
    ///
    /// Combined coherence score in [0, 1] after applying contradiction penalty
    pub fn compute_full_coherence(
        &self,
        embedding: &[f32],
        content: Option<&str>,
        node_id: Option<Uuid>,
    ) -> CoherenceResult {
        // Compute semantic coherence
        let semantic = self.compute_semantic_coherence(embedding);

        // Compute structural coherence
        let structural_calc = StructuralCoherenceCalculator::new(
            self.config.clone(),
            self.graph.clone(),
        );
        let structural = structural_calc.compute(node_id, embedding);

        // Detect contradictions
        let contradiction_detector = ContradictionDetector::new(
            self.config.clone(),
            self.graph.clone(),
        );
        let contradiction = contradiction_detector.detect(embedding, content);

        // Combine coherence components
        let base_coherence = self.config.semantic_weight * semantic
            + self.config.structural_weight * structural;

        // Apply contradiction penalty
        let final_coherence = base_coherence * (1.0 - contradiction.penalty);

        CoherenceResult {
            coherence: final_coherence.clamp(0.0, 1.0),
            semantic_coherence: semantic,
            structural_coherence: structural,
            contradiction: contradiction,
        }
    }

    /// Compute structural coherence for the given embedding.
    ///
    /// # Returns
    ///
    /// Structural coherence in [0, 1], or default if graph unavailable
    pub fn compute_structural_coherence(&self, embedding: &[f32]) -> f32 {
        let calc = StructuralCoherenceCalculator::new(
            self.config.clone(),
            self.graph.clone(),
        );
        calc.compute(None, embedding)
    }

    /// Detect contradictions with existing knowledge.
    pub fn detect_contradictions(&self, embedding: &[f32], content: Option<&str>) -> ContradictionResult {
        let detector = ContradictionDetector::new(
            self.config.clone(),
            self.graph.clone(),
        );
        detector.detect(embedding, content)
    }
}

/// Complete result of coherence computation.
#[derive(Debug, Clone)]
pub struct CoherenceResult {
    /// Final combined coherence score
    pub coherence: f32,
    /// Semantic coherence component
    pub semantic_coherence: f32,
    /// Structural coherence component
    pub structural_coherence: f32,
    /// Contradiction detection result
    pub contradiction: ContradictionResult,
}

impl CoherenceResult {
    /// Check if any contradiction was detected.
    pub fn has_contradiction(&self) -> bool {
        self.contradiction.has_contradiction
    }

    /// Get the contradiction penalty applied.
    pub fn contradiction_penalty(&self) -> f32 {
        self.contradiction.penalty
    }
}
```

---

## Configuration Reference

From M05-T03 (contradiction-related fields):

```rust
pub struct CoherenceConfig {
    // ... existing fields ...

    /// Number of similar nodes to search for contradiction detection
    pub contradiction_search_k: usize,           // 20

    /// Similarity threshold above which nodes may conflict
    pub contradiction_similarity_threshold: f32, // 0.85

    /// Maximum penalty to apply for contradictions
    pub max_contradiction_penalty: f32,          // 0.5
}
```

---

## Test Cases

### File Location

**Test File:** `crates/context-graph-utl/tests/coherence_tests.rs`

### Required Tests

```rust
#[cfg(test)]
mod structural_coherence_tests {
    use super::*;
    use std::sync::Arc;
    use uuid::Uuid;
    use std::collections::HashMap;

    // Mock implementation of KnowledgeGraphRef for testing
    struct MockGraph {
        nodes: HashMap<Uuid, (Vec<f32>, usize)>, // (embedding, edge_count)
    }

    impl MockGraph {
        fn new() -> Self {
            Self { nodes: HashMap::new() }
        }

        fn add_node(&mut self, id: Uuid, embedding: Vec<f32>, edges: usize) {
            self.nodes.insert(id, (embedding, edges));
        }
    }

    impl KnowledgeGraphRef for MockGraph {
        fn has_concept(&self, _concept: &str) -> bool {
            false
        }

        fn edge_count(&self, node_id: Uuid) -> usize {
            self.nodes.get(&node_id).map(|(_, e)| *e).unwrap_or(0)
        }

        fn search_similar(&self, embedding: &[f32], k: usize) -> Vec<(Uuid, f32)> {
            let mut results: Vec<_> = self.nodes.iter()
                .map(|(id, (emb, _))| {
                    let sim = cosine_similarity(embedding, emb);
                    (*id, sim)
                })
                .collect();
            results.sort_by(|a, b| b.1.partial_cmp(&a.1).unwrap());
            results.truncate(k);
            results
        }
    }

    fn make_config() -> CoherenceConfig {
        CoherenceConfig::default()
    }

    // ========== Structural Coherence Tests ==========

    #[test]
    fn test_structural_coherence_no_graph() {
        let config = make_config();
        let calc = StructuralCoherenceCalculator::new(config.clone(), None);

        let embedding = vec![0.5; 128];
        let result = calc.compute(None, &embedding);

        assert_eq!(result, config.default_coherence_empty);
        assert!(!calc.has_graph());
    }

    #[test]
    fn test_structural_coherence_empty_graph() {
        let config = make_config();
        let graph = Arc::new(MockGraph::new());
        let calc = StructuralCoherenceCalculator::new(config.clone(), Some(graph));

        let embedding = vec![0.5; 128];
        let result = calc.compute(None, &embedding);

        assert_eq!(result, config.default_coherence_no_concepts);
    }

    #[test]
    fn test_structural_coherence_with_similar_nodes() {
        let config = make_config();
        let mut mock = MockGraph::new();

        // Add nodes similar to our query
        for i in 0..5 {
            let embedding: Vec<f32> = (0..128).map(|j| ((i + j) as f32 * 0.01).sin()).collect();
            mock.add_node(Uuid::new_v4(), embedding, 5); // 5 edges each
        }

        let graph = Arc::new(mock);
        let calc = StructuralCoherenceCalculator::new(config, Some(graph));

        let query: Vec<f32> = (0..128).map(|j| (j as f32 * 0.01).sin()).collect();
        let result = calc.compute(None, &query);

        assert!(result > 0.0 && result <= 1.0);
    }

    // ========== Contradiction Detection Tests ==========

    #[test]
    fn test_contradiction_detection_no_graph() {
        let config = make_config();
        let detector = ContradictionDetector::new(config, None);

        let embedding = vec![0.5; 128];
        let result = detector.detect(&embedding, None);

        assert!(!result.has_contradiction);
        assert_eq!(result.penalty, 0.0);
    }

    #[test]
    fn test_contradiction_detection_no_conflicts() {
        let config = make_config();
        let mut mock = MockGraph::new();

        // Add dissimilar nodes (low similarity)
        for i in 0..5 {
            let embedding: Vec<f32> = (0..128).map(|j| if j % 2 == i % 2 { 1.0 } else { 0.0 }).collect();
            mock.add_node(Uuid::new_v4(), embedding, 3);
        }

        let graph = Arc::new(mock);
        let detector = ContradictionDetector::new(config, Some(graph));

        // Query with very different embedding
        let query: Vec<f32> = (0..128).map(|j| (j as f32 * 0.1).cos()).collect();
        let result = detector.detect(&query, None);

        // Low similarity shouldn't trigger contradiction
        assert_eq!(result.penalty, 0.0);
    }

    #[test]
    fn test_contradiction_detection_high_similarity() {
        let mut config = make_config();
        config.contradiction_similarity_threshold = 0.85;
        config.max_contradiction_penalty = 0.5;

        let mut mock = MockGraph::new();

        // Add node very similar to our query
        let similar_embedding: Vec<f32> = (0..128).map(|j| (j as f32 * 0.01).sin()).collect();
        mock.add_node(Uuid::new_v4(), similar_embedding.clone(), 3);

        let graph = Arc::new(mock);
        let detector = ContradictionDetector::new(config, Some(graph));

        // Query with very similar embedding (but not identical)
        let query: Vec<f32> = similar_embedding.iter()
            .map(|v| v + 0.01) // Slight perturbation
            .collect();

        let result = detector.detect(&query, None);

        // Should detect potential conflict
        // Note: exact behavior depends on similarity threshold
        assert!(result.penalty >= 0.0 && result.penalty <= 0.5);
    }

    #[test]
    fn test_contradiction_result_none() {
        let result = ContradictionResult::none();
        assert!(!result.has_contradiction);
        assert_eq!(result.penalty, 0.0);
        assert!(result.conflicting_nodes.is_empty());
    }

    // ========== Full Coherence Tests ==========

    #[test]
    fn test_full_coherence_no_graph() {
        let mut tracker = CoherenceTracker::default();

        // Add some window entries
        for i in 0..5 {
            let embedding: Vec<f32> = (0..128).map(|j| ((i + j) as f32 * 0.01).sin()).collect();
            tracker.add(Uuid::new_v4(), embedding, 0.5);
        }

        let query: Vec<f32> = (0..128).map(|j| (j as f32 * 0.01).sin()).collect();
        let result = tracker.compute_full_coherence(&query, None, None);

        // Should still compute semantic coherence
        assert!(result.coherence >= 0.0 && result.coherence <= 1.0);
        assert!(result.semantic_coherence > 0.0);
        // Structural should use default
        assert_eq!(result.structural_coherence, tracker.config().default_coherence_empty);
    }

    #[test]
    fn test_full_coherence_weights_applied() {
        let mut config = make_config();
        config.semantic_weight = 0.6;
        config.structural_weight = 0.4;

        let mut tracker = CoherenceTracker::new(config);

        for i in 0..5 {
            tracker.add(Uuid::new_v4(), vec![(i as f32 * 0.1).sin(); 128], 0.5);
        }

        let result = tracker.compute_full_coherence(&vec![0.5; 128], None, None);

        // Verify weights are applied
        // base = 0.6 * semantic + 0.4 * structural
        // Since no graph, structural = default_coherence_empty
        let expected_base = 0.6 * result.semantic_coherence
            + 0.4 * result.structural_coherence;
        let expected = expected_base * (1.0 - result.contradiction_penalty());

        assert!((result.coherence - expected).abs() < 1e-5,
            "Expected {}, got {}", expected, result.coherence);
    }

    // ========== Graceful Degradation Tests ==========

    #[test]
    fn test_graceful_degradation_structural() {
        let config = make_config();

        // Calculator without graph should return default
        let calc = StructuralCoherenceCalculator::new(config.clone(), None);
        let result = calc.compute(None, &vec![0.5; 128]);

        assert_eq!(result, config.default_coherence_empty);
    }

    #[test]
    fn test_graceful_degradation_contradiction() {
        let config = make_config();

        // Detector without graph should return no contradiction
        let detector = ContradictionDetector::new(config, None);
        let result = detector.detect(&vec![0.5; 128], Some("test content"));

        assert!(!result.has_contradiction);
        assert_eq!(result.penalty, 0.0);
    }
}
```

---

## Acceptance Criteria

### Functional Requirements

- [ ] `StructuralCoherenceCalculator::compute()` uses graph connectivity
- [ ] `StructuralCoherenceCalculator` returns default when graph unavailable
- [ ] `ContradictionDetector::detect()` identifies high-similarity conflicts
- [ ] `ContradictionDetector` returns penalty in [0, max_contradiction_penalty]
- [ ] `compute_full_coherence()` combines semantic, structural, and contradiction
- [ ] Final coherence formula: `(sem_weight * sem + struct_weight * struct) * (1 - penalty)`
- [ ] Graceful degradation when graph is None

### Performance Requirements

- [ ] Structural coherence computation < 2ms (excluding graph queries)
- [ ] Contradiction detection < 2ms (excluding graph queries)
- [ ] Full coherence < 10ms total

### Code Quality Requirements

- [ ] `ContradictionResult` struct with all required fields
- [ ] `CoherenceResult` struct for comprehensive results
- [ ] No `unwrap()` in production code
- [ ] Comprehensive rustdoc documentation
- [ ] Stub implementations work without graph

---

## Integration Notes

### Upstream Dependencies

- M05-T03: `CoherenceConfig` with contradiction fields
- M05-T09: `cosine_similarity()` function
- M05-T13: `CoherenceTracker`, `KnowledgeGraphRef` trait

### Downstream Consumers

- M05-T22: `UtlProcessor` uses full coherence computation
- M05-T35: Real KnowledgeGraph integration replaces stubs

### Stub Implementation Notes

The structural coherence and contradiction detection implementations in this task are **stubs** that will be replaced with real graph queries in M05-T35. The stub behavior:

1. **Without graph**: Returns default values
2. **With mock graph**: Uses the `KnowledgeGraphRef` trait for testing
3. **Production**: Will use real `KnowledgeGraph` from Module 4

---

## Revision History

| Date | Author | Changes |
|------|--------|---------|
| 2026-01-04 | AI Agent | Initial atomic task creation from M05 master spec |
