# M05-T11: Implement SurpriseCalculator Struct

| Field | Value |
|-------|-------|
| **Task ID** | M05-T11 |
| **Module** | context-graph-utl |
| **Status** | Pending |
| **Priority** | P1 (High) |
| **Depends On** | M05-T10 (Surprise Computation Methods) |
| **Estimated Hours** | 2 |
| **Constitution Refs** | TECH-UTL-005 Section 5.2, SPEC-UTL-005 Section 3.2.3 |

---

## Executive Summary

Implement the `SurpriseCalculator` struct that provides an ensemble approach to surprise computation by combining KL divergence and distance-based methods with configurable weights. This struct serves as the high-level API for computing surprise signals in the UTL system.

**Key Features:**
- Ensemble combination of KL and distance surprise methods
- Recency decay weighting for context embeddings
- Configurable weights via `SurpriseConfig`
- Caching-friendly design for repeated computations

---

## Implementation Requirements

### File Location

**Source File:** `crates/context-graph-utl/src/surprise/calculator.rs`

### Module Structure

```rust
// In crates/context-graph-utl/src/surprise/mod.rs
pub mod kl_divergence;
pub mod calculator;

pub use kl_divergence::{
    kl_divergence,
    softmax_normalize,
    cosine_similarity,
    compute_surprise_kl,
    compute_surprise_distance,
    compute_centroid,
    compute_weighted_centroid,
};
pub use calculator::SurpriseCalculator;
```

### Struct Definition

```rust
use crate::config::SurpriseConfig;
use super::kl_divergence::{
    compute_surprise_kl,
    compute_surprise_distance,
    compute_weighted_centroid,
};

/// Calculator for computing ensemble surprise signals.
///
/// Combines multiple surprise computation methods (KL divergence and cosine distance)
/// with configurable weights to produce robust surprise estimates.
///
/// # Example
///
/// ```rust
/// use context_graph_utl::surprise::SurpriseCalculator;
/// use context_graph_utl::config::SurpriseConfig;
///
/// let config = SurpriseConfig::default();
/// let calculator = SurpriseCalculator::new(config);
///
/// let observed = vec![0.5; 1536];
/// let context = vec![vec![0.3; 1536]; 10];
///
/// let surprise = calculator.compute_surprise_ensemble(&observed, &context);
/// assert!(surprise >= 0.0 && surprise <= 1.0);
/// ```
#[derive(Debug, Clone)]
pub struct SurpriseCalculator {
    /// Configuration parameters for surprise computation
    config: SurpriseConfig,
}

impl SurpriseCalculator {
    /// Create a new SurpriseCalculator with the given configuration.
    ///
    /// # Arguments
    ///
    /// * `config` - Configuration parameters including weights and thresholds
    ///
    /// # Example
    ///
    /// ```rust
    /// let config = SurpriseConfig::default();
    /// let calculator = SurpriseCalculator::new(config);
    /// ```
    pub fn new(config: SurpriseConfig) -> Self {
        Self { config }
    }

    /// Create a SurpriseCalculator with default configuration.
    pub fn default() -> Self {
        Self::new(SurpriseConfig::default())
    }

    /// Compute ensemble surprise by combining KL and distance methods.
    ///
    /// The ensemble formula is:
    /// ```text
    /// surprise = kl_weight * kl_surprise + distance_weight * distance_surprise
    /// ```
    ///
    /// This combines the strengths of both methods:
    /// - KL divergence captures distributional differences
    /// - Cosine distance captures geometric relationships
    ///
    /// # Arguments
    ///
    /// * `observed` - The observed embedding vector
    /// * `context` - Slice of recent context embeddings
    ///
    /// # Returns
    ///
    /// Combined surprise value in range [0, 1]
    ///
    /// # Performance
    ///
    /// Target: <10ms for typical context sizes (50 embeddings, 1536 dimensions)
    pub fn compute_surprise_ensemble(
        &self,
        observed: &[f32],
        context: &[Vec<f32>],
    ) -> f32 {
        // Compute KL-based surprise
        let kl_surprise = compute_surprise_kl(observed, context, &self.config);

        // Compute distance-based surprise
        let dist_surprise = compute_surprise_distance(observed, context, &self.config);

        // Combine with configured weights
        let ensemble_surprise =
            self.config.kl_weight * kl_surprise +
            self.config.distance_weight * dist_surprise;

        // Clamp to valid range
        ensemble_surprise.clamp(0.0, 1.0)
    }

    /// Compute surprise with recency-weighted context.
    ///
    /// Applies exponential decay to context embeddings, giving more weight
    /// to recent entries. This models the intuition that recent context
    /// is more relevant for determining surprise.
    ///
    /// # Arguments
    ///
    /// * `observed` - The observed embedding vector
    /// * `context` - Slice of context embeddings (most recent LAST)
    ///
    /// # Returns
    ///
    /// Surprise value with recency weighting applied, in range [0, 1]
    ///
    /// # Context Ordering
    ///
    /// The context slice should be ordered chronologically with the most
    /// recent embedding at the END of the slice.
    pub fn compute_surprise_with_decay(
        &self,
        observed: &[f32],
        context: &[Vec<f32>],
    ) -> f32 {
        if context.is_empty() {
            return self.config.max_surprise_no_context;
        }

        // Apply recency decay to create weighted context
        let weighted_context = self.apply_recency_decay(context);

        // Compute surprise using the weighted context representation
        self.compute_surprise_from_weighted(&observed, &weighted_context)
    }

    /// Apply recency decay to context embeddings.
    ///
    /// Creates a weighted representation where more recent embeddings
    /// have higher influence.
    fn apply_recency_decay(&self, context: &[Vec<f32>]) -> WeightedContext {
        let mut weights = Vec::with_capacity(context.len());
        let decay = self.config.context_decay;

        // Apply exponential decay (most recent = highest weight)
        for i in 0..context.len() {
            let age = (context.len() - 1 - i) as i32;
            weights.push(decay.powi(age));
        }

        WeightedContext {
            embeddings: context,
            weights,
        }
    }

    /// Compute surprise from a weighted context representation.
    fn compute_surprise_from_weighted(
        &self,
        observed: &[f32],
        weighted: &WeightedContext<'_>,
    ) -> f32 {
        // Compute weighted centroid
        let centroid = match self.compute_weighted_centroid_internal(weighted) {
            Some(c) => c,
            None => return self.config.max_surprise_no_context,
        };

        // Create a single-element context for reuse of existing methods
        let context_singleton = vec![centroid];

        // Compute ensemble surprise against weighted centroid
        self.compute_surprise_ensemble(observed, &context_singleton)
    }

    /// Internal weighted centroid computation.
    fn compute_weighted_centroid_internal(&self, weighted: &WeightedContext<'_>) -> Option<Vec<f32>> {
        if weighted.embeddings.is_empty() {
            return None;
        }

        let dim = weighted.embeddings[0].len();
        let mut centroid = vec![0.0f32; dim];
        let mut total_weight = 0.0f32;

        for (embedding, &weight) in weighted.embeddings.iter().zip(weighted.weights.iter()) {
            total_weight += weight;
            for (i, &val) in embedding.iter().enumerate() {
                centroid[i] += val * weight;
            }
        }

        if total_weight > 0.0 {
            for val in &mut centroid {
                *val /= total_weight;
            }
        }

        Some(centroid)
    }

    /// Get the current configuration.
    pub fn config(&self) -> &SurpriseConfig {
        &self.config
    }

    /// Update the configuration.
    pub fn set_config(&mut self, config: SurpriseConfig) {
        self.config = config;
    }

    /// Get the configured KL weight.
    pub fn kl_weight(&self) -> f32 {
        self.config.kl_weight
    }

    /// Get the configured distance weight.
    pub fn distance_weight(&self) -> f32 {
        self.config.distance_weight
    }
}

/// Internal struct for weighted context representation.
struct WeightedContext<'a> {
    embeddings: &'a [Vec<f32>],
    weights: Vec<f32>,
}

impl Default for SurpriseCalculator {
    fn default() -> Self {
        Self::new(SurpriseConfig::default())
    }
}
```

---

## Configuration Reference

From M05-T02:

```rust
pub struct SurpriseConfig {
    pub kl_weight: f32,              // 0.6 - Weight for KL divergence method
    pub distance_weight: f32,        // 0.4 - Weight for distance method
    pub kl: KlConfig,                // KL-specific parameters
    pub context_window_size: usize,  // 50 - Max context entries
    pub context_decay: f32,          // 0.95 - Recency decay factor
    pub max_surprise_no_context: f32, // 0.9 - Default for empty context
    pub min_context_for_kl: usize,   // 3 - Min entries for KL method
}
```

**Weight Invariant:** `kl_weight + distance_weight = 1.0`

---

## Test Cases

### File Location

**Test File:** `crates/context-graph-utl/tests/surprise_tests.rs`

### Required Tests

```rust
#[cfg(test)]
mod surprise_calculator_tests {
    use super::*;
    use crate::config::SurpriseConfig;

    fn make_calculator() -> SurpriseCalculator {
        SurpriseCalculator::default()
    }

    // ========== Construction Tests ==========

    #[test]
    fn test_calculator_new() {
        let config = SurpriseConfig::default();
        let calculator = SurpriseCalculator::new(config.clone());
        assert_eq!(calculator.kl_weight(), config.kl_weight);
        assert_eq!(calculator.distance_weight(), config.distance_weight);
    }

    #[test]
    fn test_calculator_default() {
        let calculator = SurpriseCalculator::default();
        assert!((calculator.kl_weight() - 0.6).abs() < 1e-6);
        assert!((calculator.distance_weight() - 0.4).abs() < 1e-6);
    }

    // ========== Ensemble Surprise Tests ==========

    #[test]
    fn test_ensemble_empty_context() {
        let calculator = make_calculator();
        let observed = vec![0.5; 128];
        let result = calculator.compute_surprise_ensemble(&observed, &[]);
        assert_eq!(result, calculator.config().max_surprise_no_context);
    }

    #[test]
    fn test_ensemble_combines_methods() {
        let calculator = make_calculator();
        let observed = vec![0.5; 128];
        let context = vec![vec![0.5; 128]; 10];

        let result = calculator.compute_surprise_ensemble(&observed, &context);

        // Identical embeddings should yield low surprise
        assert!(result < 0.2, "Expected low surprise for identical, got {}", result);
    }

    #[test]
    fn test_ensemble_in_valid_range() {
        let calculator = make_calculator();
        let observed = vec![1.0; 128];
        let context = vec![vec![-1.0; 128]; 10];

        let result = calculator.compute_surprise_ensemble(&observed, &context);

        assert!(result >= 0.0 && result <= 1.0,
            "Result {} not in [0,1]", result);
    }

    #[test]
    fn test_ensemble_weights_sum_to_one() {
        let calculator = make_calculator();
        let sum = calculator.kl_weight() + calculator.distance_weight();
        assert!((sum - 1.0).abs() < 1e-6,
            "Weights should sum to 1.0, got {}", sum);
    }

    // ========== Recency Decay Tests ==========

    #[test]
    fn test_surprise_with_decay_empty_context() {
        let calculator = make_calculator();
        let observed = vec![0.5; 128];
        let result = calculator.compute_surprise_with_decay(&observed, &[]);
        assert_eq!(result, calculator.config().max_surprise_no_context);
    }

    #[test]
    fn test_surprise_with_decay_recency_effect() {
        let calculator = make_calculator();
        let observed = vec![1.0; 128];

        // Context with old entries different from observed, recent similar
        let mut context = Vec::new();
        for _ in 0..9 {
            context.push(vec![0.0; 128]); // Old, different
        }
        context.push(vec![1.0; 128]); // Recent, same as observed

        let result = calculator.compute_surprise_with_decay(&observed, &context);

        // With recency decay, recent similar embedding should reduce surprise
        assert!(result < 0.5, "Expected lower surprise due to recent match, got {}", result);
    }

    #[test]
    fn test_decay_weights_applied_correctly() {
        let mut config = SurpriseConfig::default();
        config.context_decay = 0.5; // Aggressive decay for testing
        let calculator = SurpriseCalculator::new(config);

        let observed = vec![0.0; 128];

        // Old entry matches observed, recent entry is different
        let context = vec![
            vec![0.0; 128], // Old, matches observed
            vec![1.0; 128], // Recent, different
        ];

        let result = calculator.compute_surprise_with_decay(&observed, &context);

        // With aggressive decay, recent different entry dominates
        // So surprise should be higher than if old matching entry dominated
        assert!(result > 0.3, "Expected higher surprise due to recent mismatch, got {}", result);
    }

    // ========== Configuration Tests ==========

    #[test]
    fn test_set_config() {
        let mut calculator = make_calculator();
        let mut new_config = SurpriseConfig::default();
        new_config.kl_weight = 0.8;
        new_config.distance_weight = 0.2;

        calculator.set_config(new_config.clone());

        assert!((calculator.kl_weight() - 0.8).abs() < 1e-6);
        assert!((calculator.distance_weight() - 0.2).abs() < 1e-6);
    }

    // ========== Performance Tests ==========

    #[test]
    fn test_ensemble_performance() {
        let calculator = make_calculator();
        let observed = vec![0.5; 1536]; // Full dimension
        let context: Vec<Vec<f32>> = (0..50)
            .map(|i| vec![(i as f32 * 0.01).sin(); 1536])
            .collect();

        let start = std::time::Instant::now();
        for _ in 0..100 {
            let _ = calculator.compute_surprise_ensemble(&observed, &context);
        }
        let elapsed = start.elapsed();
        let per_op = elapsed / 100;

        assert!(per_op.as_millis() < 10,
            "Ensemble performance target missed: {:?} per operation", per_op);
    }

    #[test]
    fn test_decay_performance() {
        let calculator = make_calculator();
        let observed = vec![0.5; 1536];
        let context: Vec<Vec<f32>> = (0..50)
            .map(|i| vec![(i as f32 * 0.01).sin(); 1536])
            .collect();

        let start = std::time::Instant::now();
        for _ in 0..100 {
            let _ = calculator.compute_surprise_with_decay(&observed, &context);
        }
        let elapsed = start.elapsed();
        let per_op = elapsed / 100;

        assert!(per_op.as_millis() < 15,
            "Decay surprise performance target missed: {:?} per operation", per_op);
    }
}
```

---

## Acceptance Criteria

### Functional Requirements

- [ ] `SurpriseCalculator::new(config)` creates calculator with given config
- [ ] `SurpriseCalculator::default()` uses default configuration
- [ ] `compute_surprise_ensemble()` combines KL and distance methods
- [ ] Ensemble weights sum to 1.0 (kl_weight + distance_weight = 1.0)
- [ ] `compute_surprise_with_decay()` applies recency weighting
- [ ] Recency decay gives higher weight to recent context entries
- [ ] All results clamped to [0, 1] range
- [ ] Empty context returns `max_surprise_no_context`

### Performance Requirements

- [ ] `compute_surprise_ensemble()` executes in <10ms for typical context
- [ ] `compute_surprise_with_decay()` executes in <15ms for typical context
- [ ] Memory allocation minimized in computation paths

### Code Quality Requirements

- [ ] No `unwrap()` or `expect()` in production code
- [ ] Comprehensive rustdoc documentation
- [ ] Clone and Debug traits implemented
- [ ] Default trait implemented
- [ ] All edge cases handled

---

## Integration Notes

### Upstream Dependencies

- M05-T09: `kl_divergence()`, `softmax_normalize()`, `cosine_similarity()`
- M05-T10: `compute_surprise_kl()`, `compute_surprise_distance()`
- M05-T02: `SurpriseConfig` struct

### Downstream Consumers

- M05-T22: `UtlProcessor` uses `SurpriseCalculator` for delta_s computation

---

## Revision History

| Date | Author | Changes |
|------|--------|---------|
| 2026-01-04 | AI Agent | Initial atomic task creation from M05 master spec |
