# M05-T21: Define LearningSignal and UtlState Structs

```yaml
task_id: M05-T21
title: "Define LearningSignal and UtlState Structs"
module: "Module 5: UTL Integration"
layer: "surface"
priority: "critical"
status: "pending"
estimated_hours: 2
created: "2026-01-04"

file_path: "crates/context-graph-utl/src/lib.rs"
test_file: "crates/context-graph-utl/tests/utl_core_tests.rs"

dependencies:
  - "M05-T06"  # LifecycleLambdaWeights
  - "M05-T08"  # JohariQuadrant, SuggestedAction

spec_refs:
  - "TECH-UTL-005 Section 2.2"
  - "SPEC-UTL-005 Section 9.1"
```

---

## Description

Implement `LearningSignal` struct for complete UTL computation output and `UtlState` struct for node storage. These are the primary data structures that capture the full UTL computation result.

---

## LearningSignal Struct

The complete output from a UTL computation, containing all component values and derived decisions.

### Fields

| Field | Type | Description |
|-------|------|-------------|
| `magnitude` | `f32` | Learning magnitude L in [0, 1] |
| `delta_s` | `f32` | Surprise (entropy) value [0, 1] |
| `delta_c` | `f32` | Coherence value [0, 1] |
| `w_e` | `f32` | Emotional weight [0.5, 1.5] |
| `phi` | `f32` | Phase angle [0, PI] |
| `lambda_weights` | `Option<LifecycleLambdaWeights>` | Marblestone weights if applied |
| `quadrant` | `JohariQuadrant` | Classified Johari quadrant |
| `suggested_action` | `SuggestedAction` | Recommended retrieval action |
| `should_consolidate` | `bool` | Whether consolidation is recommended |
| `should_store` | `bool` | Whether storage is recommended |
| `timestamp` | `DateTime<Utc>` | When computation was performed |
| `latency_us` | `u64` | Computation time in microseconds |

### Implementation

```rust
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};

use crate::johari::{JohariQuadrant, SuggestedAction};
use crate::lifecycle::LifecycleLambdaWeights;
use crate::error::UtlError;

/// Complete UTL computation output with all component values and decisions
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LearningSignal {
    /// Learning magnitude L in [0, 1]
    pub magnitude: f32,

    /// Surprise (entropy) value [0, 1]
    pub delta_s: f32,

    /// Coherence value [0, 1]
    pub delta_c: f32,

    /// Emotional weight [0.5, 1.5]
    pub w_e: f32,

    /// Phase angle [0, PI]
    pub phi: f32,

    /// Marblestone lambda weights if applied
    pub lambda_weights: Option<LifecycleLambdaWeights>,

    /// Classified Johari quadrant
    pub quadrant: JohariQuadrant,

    /// Recommended retrieval action
    pub suggested_action: SuggestedAction,

    /// Whether consolidation is recommended
    pub should_consolidate: bool,

    /// Whether storage is recommended
    pub should_store: bool,

    /// When computation was performed
    pub timestamp: DateTime<Utc>,

    /// Computation time in microseconds
    pub latency_us: u64,
}

impl LearningSignal {
    /// Create a new LearningSignal with validation
    pub fn new(
        magnitude: f32,
        delta_s: f32,
        delta_c: f32,
        w_e: f32,
        phi: f32,
        lambda_weights: Option<LifecycleLambdaWeights>,
        quadrant: JohariQuadrant,
        suggested_action: SuggestedAction,
        should_consolidate: bool,
        should_store: bool,
        latency_us: u64,
    ) -> Result<Self, UtlError> {
        let signal = Self {
            magnitude,
            delta_s,
            delta_c,
            w_e,
            phi,
            lambda_weights,
            quadrant,
            suggested_action,
            should_consolidate,
            should_store,
            timestamp: Utc::now(),
            latency_us,
        };

        signal.validate()?;
        Ok(signal)
    }

    /// Validate that all values are finite and within expected ranges
    pub fn validate(&self) -> Result<(), UtlError> {
        if self.magnitude.is_nan() || self.magnitude.is_infinite() {
            return Err(UtlError::InvalidComputation {
                delta_s: self.delta_s,
                delta_c: self.delta_c,
                w_e: self.w_e,
                phi: self.phi,
                reason: "magnitude is NaN or Infinity".to_string(),
            });
        }

        if self.delta_s.is_nan() || self.delta_c.is_nan()
           || self.w_e.is_nan() || self.phi.is_nan() {
            return Err(UtlError::InvalidComputation {
                delta_s: self.delta_s,
                delta_c: self.delta_c,
                w_e: self.w_e,
                phi: self.phi,
                reason: "component value is NaN".to_string(),
            });
        }

        Ok(())
    }

    /// Check if this signal indicates high learning potential
    pub fn is_high_learning(&self) -> bool {
        self.magnitude > 0.7
    }

    /// Check if this signal indicates low learning potential
    pub fn is_low_learning(&self) -> bool {
        self.magnitude < 0.3
    }

    /// Get the learning intensity category
    pub fn intensity_category(&self) -> LearningIntensity {
        if self.magnitude < 0.3 {
            LearningIntensity::Low
        } else if self.magnitude < 0.7 {
            LearningIntensity::Medium
        } else {
            LearningIntensity::High
        }
    }
}

/// Learning intensity category
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[repr(u8)]
pub enum LearningIntensity {
    Low = 0,
    Medium = 1,
    High = 2,
}
```

---

## UtlState Struct

Compact UTL state for storage in MemoryNode. This is the persistent representation stored with each memory.

### Fields

| Field | Type | Description |
|-------|------|-------------|
| `delta_s` | `f32` | Last computed surprise |
| `delta_c` | `f32` | Last computed coherence |
| `w_e` | `f32` | Last computed emotional weight |
| `phi` | `f32` | Phase angle at computation |
| `learning_magnitude` | `f32` | Computed learning magnitude |
| `quadrant` | `JohariQuadrant` | Classified quadrant |
| `last_computed` | `DateTime<Utc>` | When state was last updated |

### Implementation

```rust
/// Compact UTL state for node storage
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UtlState {
    /// Last computed surprise value [0, 1]
    pub delta_s: f32,

    /// Last computed coherence value [0, 1]
    pub delta_c: f32,

    /// Last computed emotional weight [0.5, 1.5]
    pub w_e: f32,

    /// Phase angle at computation [0, PI]
    pub phi: f32,

    /// Computed learning magnitude [0, 1]
    pub learning_magnitude: f32,

    /// Classified Johari quadrant
    pub quadrant: JohariQuadrant,

    /// When state was last updated
    pub last_computed: DateTime<Utc>,
}

impl UtlState {
    /// Create a new UtlState from a LearningSignal
    pub fn from_signal(signal: &LearningSignal) -> Self {
        Self {
            delta_s: signal.delta_s,
            delta_c: signal.delta_c,
            w_e: signal.w_e,
            phi: signal.phi,
            learning_magnitude: signal.magnitude,
            quadrant: signal.quadrant,
            last_computed: signal.timestamp,
        }
    }

    /// Create a default/empty UtlState
    pub fn empty() -> Self {
        Self {
            delta_s: 0.0,
            delta_c: 0.0,
            w_e: 1.0,
            phi: 0.0,
            learning_magnitude: 0.5,
            quadrant: JohariQuadrant::default(),
            last_computed: Utc::now(),
        }
    }

    /// Validate that all values are finite
    pub fn validate(&self) -> Result<(), UtlError> {
        let values = [
            ("delta_s", self.delta_s),
            ("delta_c", self.delta_c),
            ("w_e", self.w_e),
            ("phi", self.phi),
            ("learning_magnitude", self.learning_magnitude),
        ];

        for (name, value) in values {
            if value.is_nan() || value.is_infinite() {
                return Err(UtlError::InvalidComputation {
                    delta_s: self.delta_s,
                    delta_c: self.delta_c,
                    w_e: self.w_e,
                    phi: self.phi,
                    reason: format!("{} is NaN or Infinity", name),
                });
            }
        }

        Ok(())
    }

    /// Check if this state is stale (not computed recently)
    pub fn is_stale(&self, max_age_seconds: i64) -> bool {
        let age = Utc::now() - self.last_computed;
        age.num_seconds() > max_age_seconds
    }

    /// Get the age of this state in seconds
    pub fn age_seconds(&self) -> i64 {
        (Utc::now() - self.last_computed).num_seconds()
    }
}

impl Default for UtlState {
    fn default() -> Self {
        Self::empty()
    }
}
```

---

## Acceptance Criteria

- [ ] `LearningSignal` struct with all 12 fields
- [ ] `UtlState` struct with 7 fields for node storage
- [ ] `validate()` returns `UtlError` if magnitude is NaN/Infinity
- [ ] `Clone`, `Debug`, `Serialize`, `Deserialize` implemented
- [ ] Latency tracking in microseconds
- [ ] `from_signal()` converts LearningSignal to UtlState
- [ ] `is_stale()` correctly detects old state
- [ ] Unit tests for validation

---

## Test Cases

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use chrono::Duration;

    #[test]
    fn test_learning_signal_validation_success() {
        let signal = LearningSignal::new(
            0.7,                           // magnitude
            0.6,                           // delta_s
            0.8,                           // delta_c
            1.2,                           // w_e
            0.5,                           // phi
            None,                          // lambda_weights
            JohariQuadrant::Open,
            SuggestedAction::DirectRecall,
            false,                         // should_consolidate
            true,                          // should_store
            1500,                          // latency_us
        );

        assert!(signal.is_ok());
    }

    #[test]
    fn test_learning_signal_validation_nan() {
        let signal = LearningSignal::new(
            f32::NAN,
            0.6,
            0.8,
            1.2,
            0.5,
            None,
            JohariQuadrant::Open,
            SuggestedAction::DirectRecall,
            false,
            true,
            1500,
        );

        assert!(signal.is_err());
        match signal.unwrap_err() {
            UtlError::InvalidComputation { reason, .. } => {
                assert!(reason.contains("NaN"));
            }
            _ => panic!("Expected InvalidComputation error"),
        }
    }

    #[test]
    fn test_learning_intensity_categories() {
        let low = LearningSignal::new(0.2, 0.5, 0.5, 1.0, 0.5, None,
            JohariQuadrant::Open, SuggestedAction::DirectRecall, false, true, 100).unwrap();
        assert_eq!(low.intensity_category(), LearningIntensity::Low);

        let medium = LearningSignal::new(0.5, 0.5, 0.5, 1.0, 0.5, None,
            JohariQuadrant::Open, SuggestedAction::DirectRecall, false, true, 100).unwrap();
        assert_eq!(medium.intensity_category(), LearningIntensity::Medium);

        let high = LearningSignal::new(0.8, 0.5, 0.5, 1.0, 0.5, None,
            JohariQuadrant::Open, SuggestedAction::DirectRecall, false, true, 100).unwrap();
        assert_eq!(high.intensity_category(), LearningIntensity::High);
    }

    #[test]
    fn test_utl_state_from_signal() {
        let signal = LearningSignal::new(
            0.7, 0.6, 0.8, 1.2, 0.5, None,
            JohariQuadrant::Blind,
            SuggestedAction::TriggerDream,
            true, true, 2000,
        ).unwrap();

        let state = UtlState::from_signal(&signal);

        assert_eq!(state.delta_s, signal.delta_s);
        assert_eq!(state.delta_c, signal.delta_c);
        assert_eq!(state.learning_magnitude, signal.magnitude);
        assert_eq!(state.quadrant, JohariQuadrant::Blind);
    }

    #[test]
    fn test_utl_state_staleness() {
        let mut state = UtlState::empty();

        // Fresh state should not be stale
        assert!(!state.is_stale(300));

        // Simulate old state
        state.last_computed = Utc::now() - Duration::seconds(400);
        assert!(state.is_stale(300));
    }

    #[test]
    fn test_utl_state_serialization() {
        let state = UtlState::empty();

        let json = serde_json::to_string(&state).unwrap();
        let deserialized: UtlState = serde_json::from_str(&json).unwrap();

        assert_eq!(state.delta_s, deserialized.delta_s);
        assert_eq!(state.learning_magnitude, deserialized.learning_magnitude);
    }
}
```

---

## Verification Commands

```bash
# Run unit tests
cargo test -p context-graph-utl --lib -- learning_signal
cargo test -p context-graph-utl --lib -- utl_state

# Check serialization
cargo test -p context-graph-utl --lib -- serialization
```

---

## Related Tasks

| Task | Relationship |
|------|--------------|
| M05-T06 | Provides LifecycleLambdaWeights type |
| M05-T08 | Provides JohariQuadrant, SuggestedAction |
| M05-T20 | Computes magnitude stored in structs |
| M05-T22 | UtlProcessor produces LearningSignal |
| M05-T23 | Uses UtlError for validation |
| M05-T29 | MemoryNode stores UtlState |
