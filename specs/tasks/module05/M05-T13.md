# M05-T13: Implement CoherenceTracker with Semantic Coherence

| Field | Value |
|-------|-------|
| **Task ID** | M05-T13 |
| **Module** | context-graph-utl |
| **Status** | Pending |
| **Priority** | P0 (Critical Path) |
| **Depends On** | M05-T12 (CoherenceEntry and Rolling Window) |
| **Estimated Hours** | 3 |
| **Constitution Refs** | TECH-UTL-005 Section 6, SPEC-UTL-005 Section 4 |

---

## Executive Summary

Implement the `CoherenceTracker` struct that computes semantic coherence (delta_c) by measuring how well new content fits with the recent context window. Semantic coherence uses weighted average similarity with recency decay to quantify alignment with existing knowledge.

**Key Features:**
- Semantic coherence via weighted cosine similarity
- Recency decay for temporal weighting
- Importance-weighted contributions
- Integration with the CoherenceWindow from M05-T12

---

## Implementation Requirements

### File Location

**Source File:** `crates/context-graph-utl/src/coherence/tracker.rs`

Extends the file from M05-T12 with the `CoherenceTracker` struct.

### Dependencies

```rust
use crate::config::CoherenceConfig;
use crate::surprise::cosine_similarity;
use super::{CoherenceEntry, CoherenceWindow};
```

### Struct Definition

```rust
/// Tracker for computing semantic coherence of new content.
///
/// The CoherenceTracker maintains a rolling window of recent embeddings
/// and computes how well new content fits with this context using
/// weighted similarity measures.
///
/// # Semantic Coherence Formula
///
/// ```text
/// delta_c = sum(sim_i * decay^i * importance_i) / sum(decay^i * importance_i)
/// ```
///
/// Where:
/// - `sim_i` is the cosine similarity to the i-th window entry
/// - `decay^i` applies recency weighting (i=0 is most recent)
/// - `importance_i` is the UTL importance of that entry
///
/// # Example
///
/// ```rust
/// use context_graph_utl::coherence::CoherenceTracker;
/// use context_graph_utl::config::CoherenceConfig;
///
/// let config = CoherenceConfig::default();
/// let mut tracker = CoherenceTracker::new(config);
///
/// // Add some context
/// tracker.update(entry1);
/// tracker.update(entry2);
///
/// // Compute coherence for new content
/// let embedding = vec![0.5; 1536];
/// let coherence = tracker.compute_coherence(&embedding, None);
/// ```
#[derive(Debug)]
pub struct CoherenceTracker {
    /// Rolling window of recent entries
    window: CoherenceWindow,

    /// Configuration parameters
    config: CoherenceConfig,

    /// Optional reference to knowledge graph for structural coherence
    /// (Used in M05-T14, stubbed here)
    #[allow(dead_code)]
    graph: Option<std::sync::Arc<dyn KnowledgeGraphRef>>,
}

/// Trait for knowledge graph reference (to be implemented in M05-T35).
///
/// This allows the CoherenceTracker to query the graph for structural
/// coherence without tight coupling.
pub trait KnowledgeGraphRef: Send + Sync {
    /// Check if a concept exists in the graph.
    fn has_concept(&self, concept: &str) -> bool;

    /// Get edge count for a node.
    fn edge_count(&self, node_id: uuid::Uuid) -> usize;

    /// Search for similar nodes.
    fn search_similar(&self, embedding: &[f32], k: usize) -> Vec<(uuid::Uuid, f32)>;
}

impl CoherenceTracker {
    /// Create a new CoherenceTracker with the given configuration.
    ///
    /// # Arguments
    ///
    /// * `config` - Configuration for coherence computation
    ///
    /// # Example
    ///
    /// ```rust
    /// let config = CoherenceConfig::default();
    /// let tracker = CoherenceTracker::new(config);
    /// ```
    pub fn new(config: CoherenceConfig) -> Self {
        let window = CoherenceWindow::new(config.window_size);
        Self {
            window,
            config,
            graph: None,
        }
    }

    /// Create a CoherenceTracker with a knowledge graph reference.
    ///
    /// Enables structural coherence computation when the graph is available.
    pub fn with_graph(
        config: CoherenceConfig,
        graph: std::sync::Arc<dyn KnowledgeGraphRef>,
    ) -> Self {
        let window = CoherenceWindow::new(config.window_size);
        Self {
            window,
            config,
            graph: Some(graph),
        }
    }

    /// Create a tracker with default configuration.
    pub fn default() -> Self {
        Self::new(CoherenceConfig::default())
    }

    /// Compute overall coherence for new content.
    ///
    /// Combines semantic coherence (similarity to window) with structural
    /// coherence (graph connectivity) if available.
    ///
    /// # Arguments
    ///
    /// * `embedding` - Embedding vector of the new content
    /// * `content` - Optional text content for concept extraction
    ///
    /// # Returns
    ///
    /// Coherence score delta_c in range [0, 1]
    ///
    /// # Default Behavior
    ///
    /// - Returns `default_coherence_empty` when window is empty
    /// - Returns `default_coherence_no_concepts` when no concepts found
    ///
    /// # Performance Target
    ///
    /// <5ms for 100 window entries
    pub fn compute_coherence(
        &self,
        embedding: &[f32],
        _content: Option<&str>,
    ) -> f32 {
        // Handle empty window
        if self.window.is_empty() {
            return self.config.default_coherence_empty;
        }

        // Compute semantic coherence
        let semantic = self.compute_semantic_coherence(embedding);

        // For now, structural coherence is stubbed (implemented in M05-T14)
        // Final coherence will be: semantic_weight * semantic + structural_weight * structural

        // Currently returns just semantic coherence
        semantic.clamp(0.0, 1.0)
    }

    /// Compute semantic coherence based on similarity to window entries.
    ///
    /// Uses weighted average similarity with recency decay and importance weighting.
    ///
    /// # Formula
    ///
    /// ```text
    /// semantic_coherence = sum(sim_i * decay^i * importance_i) / sum(decay^i * importance_i)
    /// ```
    ///
    /// # Arguments
    ///
    /// * `embedding` - The embedding to compare against the window
    ///
    /// # Returns
    ///
    /// Semantic coherence in range [0, 1] (assuming normalized embeddings)
    pub fn compute_semantic_coherence(&self, embedding: &[f32]) -> f32 {
        if self.window.is_empty() {
            return self.config.default_coherence_empty;
        }

        let decay = self.config.recency_decay;
        let mut weighted_sum = 0.0f32;
        let mut weight_total = 0.0f32;

        // Iterate from newest to oldest (reverse order)
        for (i, entry) in self.window.iter_rev().enumerate() {
            // Compute similarity
            let similarity = cosine_similarity(embedding, entry.embedding());

            // Apply recency decay (i=0 is most recent, gets weight 1.0)
            let recency_weight = decay.powi(i as i32);

            // Combine with importance
            let weight = recency_weight * entry.importance();

            weighted_sum += similarity * weight;
            weight_total += weight;
        }

        if weight_total > 0.0 {
            // Map similarity from [-1, 1] to [0, 1]
            let raw_coherence = weighted_sum / weight_total;
            (raw_coherence + 1.0) / 2.0
        } else {
            self.config.default_coherence_empty
        }
    }

    /// Update the coherence window with a new entry.
    ///
    /// Adds the entry to the rolling window, potentially evicting
    /// the oldest entry if at capacity.
    ///
    /// # Arguments
    ///
    /// * `entry` - The coherence entry to add
    ///
    /// # Returns
    ///
    /// The evicted entry if the window was at capacity.
    pub fn update(&mut self, entry: CoherenceEntry) -> Option<CoherenceEntry> {
        self.window.push(entry)
    }

    /// Add content to the window (convenience method).
    ///
    /// Creates a CoherenceEntry and adds it to the window.
    pub fn add(
        &mut self,
        node_id: uuid::Uuid,
        embedding: Vec<f32>,
        importance: f32,
    ) -> Option<CoherenceEntry> {
        self.window.add(node_id, embedding, importance)
    }

    /// Get the current window size (number of entries).
    #[inline]
    pub fn window_size(&self) -> usize {
        self.window.len()
    }

    /// Get the maximum window capacity.
    #[inline]
    pub fn capacity(&self) -> usize {
        self.window.capacity()
    }

    /// Check if the window is empty.
    #[inline]
    pub fn is_empty(&self) -> bool {
        self.window.is_empty()
    }

    /// Clear the coherence window.
    pub fn clear(&mut self) {
        self.window.clear();
    }

    /// Get reference to the configuration.
    pub fn config(&self) -> &CoherenceConfig {
        &self.config
    }

    /// Update the configuration.
    ///
    /// Note: This does not resize the window. If the new config has a different
    /// window_size, create a new tracker instead.
    pub fn set_config(&mut self, config: CoherenceConfig) {
        self.config = config;
    }

    /// Get the embeddings from the window.
    pub fn window_embeddings(&self) -> Vec<&[f32]> {
        self.window.embeddings()
    }

    /// Compute recency-weighted centroid of the window.
    pub fn compute_context_centroid(&self) -> Option<Vec<f32>> {
        if self.window.is_empty() {
            return None;
        }

        let first = self.window.get(0)?;
        let dim = first.dimension();
        let mut centroid = vec![0.0f32; dim];
        let mut total_weight = 0.0f32;
        let decay = self.config.recency_decay;

        for (i, entry) in self.window.iter_rev().enumerate() {
            let weight = decay.powi(i as i32) * entry.importance();
            total_weight += weight;

            for (j, &val) in entry.embedding().iter().enumerate() {
                centroid[j] += val * weight;
            }
        }

        if total_weight > 0.0 {
            for val in &mut centroid {
                *val /= total_weight;
            }
        }

        Some(centroid)
    }

    /// Get statistics about the current window.
    pub fn stats(&self) -> CoherenceStats {
        CoherenceStats {
            window_size: self.window.len(),
            capacity: self.window.capacity(),
            average_importance: self.window.average_importance(),
            oldest_age_seconds: self.window.oldest().map(|e| e.age_seconds()).unwrap_or(0),
            newest_age_seconds: self.window.newest().map(|e| e.age_seconds()).unwrap_or(0),
        }
    }
}

/// Statistics about the coherence window.
#[derive(Debug, Clone)]
pub struct CoherenceStats {
    /// Current number of entries in the window
    pub window_size: usize,
    /// Maximum window capacity
    pub capacity: usize,
    /// Average importance of entries
    pub average_importance: f32,
    /// Age of oldest entry in seconds
    pub oldest_age_seconds: i64,
    /// Age of newest entry in seconds
    pub newest_age_seconds: i64,
}

impl Default for CoherenceTracker {
    fn default() -> Self {
        Self::new(CoherenceConfig::default())
    }
}
```

---

## Configuration Reference

From M05-T03:

```rust
pub struct CoherenceConfig {
    pub window_size: usize,              // 100
    pub recency_decay: f32,              // 0.98
    pub semantic_weight: f32,            // 0.6
    pub structural_weight: f32,          // 0.4
    pub default_coherence_empty: f32,    // 0.5
    pub default_coherence_no_concepts: f32, // 0.4
    // Contradiction detection fields (used in M05-T14)
    pub contradiction_search_k: usize,   // 20
    pub contradiction_similarity_threshold: f32, // 0.85
    pub max_contradiction_penalty: f32,  // 0.5
}
```

---

## Test Cases

### File Location

**Test File:** `crates/context-graph-utl/tests/coherence_tests.rs`

### Required Tests

```rust
#[cfg(test)]
mod coherence_tracker_tests {
    use super::*;
    use uuid::Uuid;

    fn make_config() -> CoherenceConfig {
        CoherenceConfig::default()
    }

    fn make_entry(embedding: Vec<f32>, importance: f32) -> CoherenceEntry {
        CoherenceEntry::new(Uuid::new_v4(), embedding, importance)
    }

    // ========== Construction Tests ==========

    #[test]
    fn test_tracker_new() {
        let config = make_config();
        let tracker = CoherenceTracker::new(config.clone());

        assert!(tracker.is_empty());
        assert_eq!(tracker.capacity(), config.window_size);
    }

    #[test]
    fn test_tracker_default() {
        let tracker = CoherenceTracker::default();
        assert_eq!(tracker.capacity(), 100);
    }

    // ========== Coherence Computation Tests ==========

    #[test]
    fn test_coherence_empty_window() {
        let tracker = CoherenceTracker::default();
        let embedding = vec![0.5; 128];

        let coherence = tracker.compute_coherence(&embedding, None);

        assert_eq!(coherence, tracker.config().default_coherence_empty);
    }

    #[test]
    fn test_coherence_identical_content() {
        let mut tracker = CoherenceTracker::default();
        let embedding = vec![0.5; 128];

        // Add the same embedding to the window
        for _ in 0..5 {
            tracker.add(Uuid::new_v4(), embedding.clone(), 1.0);
        }

        // Compute coherence for the same embedding
        let coherence = tracker.compute_coherence(&embedding, None);

        // Should be very high (close to 1.0)
        assert!(coherence > 0.9, "Expected high coherence, got {}", coherence);
    }

    #[test]
    fn test_coherence_orthogonal_content() {
        let mut tracker = CoherenceTracker::default();

        // Window contains embeddings pointing one direction
        let window_embedding: Vec<f32> = (0..128).map(|i| if i < 64 { 1.0 } else { 0.0 }).collect();
        for _ in 0..5 {
            tracker.add(Uuid::new_v4(), window_embedding.clone(), 1.0);
        }

        // New content points orthogonal direction
        let new_embedding: Vec<f32> = (0..128).map(|i| if i >= 64 { 1.0 } else { 0.0 }).collect();
        let coherence = tracker.compute_coherence(&new_embedding, None);

        // Should be around 0.5 (orthogonal maps to neutral coherence)
        assert!((coherence - 0.5).abs() < 0.15, "Expected ~0.5 coherence, got {}", coherence);
    }

    #[test]
    fn test_coherence_opposite_content() {
        let mut tracker = CoherenceTracker::default();

        let window_embedding = vec![1.0; 128];
        for _ in 0..5 {
            tracker.add(Uuid::new_v4(), window_embedding.clone(), 1.0);
        }

        // Opposite direction
        let new_embedding = vec![-1.0; 128];
        let coherence = tracker.compute_coherence(&new_embedding, None);

        // Should be low (opposite = low coherence)
        assert!(coherence < 0.2, "Expected low coherence, got {}", coherence);
    }

    #[test]
    fn test_coherence_in_valid_range() {
        let mut tracker = CoherenceTracker::default();

        for i in 0..10 {
            let embedding: Vec<f32> = (0..128).map(|j| ((i + j) as f32).sin()).collect();
            tracker.add(Uuid::new_v4(), embedding, 0.5);
        }

        let test_embedding: Vec<f32> = (0..128).map(|i| (i as f32).cos()).collect();
        let coherence = tracker.compute_coherence(&test_embedding, None);

        assert!(coherence >= 0.0 && coherence <= 1.0,
            "Coherence {} not in [0,1]", coherence);
    }

    // ========== Semantic Coherence Tests ==========

    #[test]
    fn test_semantic_coherence_recency_effect() {
        let mut config = make_config();
        config.recency_decay = 0.5; // Aggressive decay for testing
        let mut tracker = CoherenceTracker::new(config);

        // Add old entries that are different from test embedding
        for _ in 0..5 {
            tracker.add(Uuid::new_v4(), vec![0.0; 128], 1.0);
        }

        // Add recent entry that matches test embedding
        tracker.add(Uuid::new_v4(), vec![1.0; 128], 1.0);

        let coherence = tracker.compute_semantic_coherence(&vec![1.0; 128]);

        // With aggressive decay, recent matching entry should dominate
        assert!(coherence > 0.7, "Expected high coherence due to recent match, got {}", coherence);
    }

    #[test]
    fn test_semantic_coherence_importance_weighting() {
        let mut tracker = CoherenceTracker::default();

        // Add low-importance entries that don't match
        for _ in 0..5 {
            tracker.add(Uuid::new_v4(), vec![0.0; 128], 0.1);
        }

        // Add high-importance entry that matches
        tracker.add(Uuid::new_v4(), vec![1.0; 128], 1.0);

        let coherence = tracker.compute_semantic_coherence(&vec![1.0; 128]);

        // High-importance matching entry should have strong effect
        assert!(coherence > 0.6, "Expected higher coherence due to important match, got {}", coherence);
    }

    // ========== Window Management Tests ==========

    #[test]
    fn test_tracker_update() {
        let mut tracker = CoherenceTracker::default();

        tracker.update(make_entry(vec![0.1; 128], 0.5));
        tracker.update(make_entry(vec![0.2; 128], 0.6));

        assert_eq!(tracker.window_size(), 2);
    }

    #[test]
    fn test_tracker_clear() {
        let mut tracker = CoherenceTracker::default();

        tracker.add(Uuid::new_v4(), vec![0.1; 128], 0.5);
        tracker.add(Uuid::new_v4(), vec![0.2; 128], 0.5);

        tracker.clear();

        assert!(tracker.is_empty());
    }

    // ========== Centroid Tests ==========

    #[test]
    fn test_compute_context_centroid_empty() {
        let tracker = CoherenceTracker::default();
        assert!(tracker.compute_context_centroid().is_none());
    }

    #[test]
    fn test_compute_context_centroid() {
        let mut tracker = CoherenceTracker::default();

        tracker.add(Uuid::new_v4(), vec![1.0, 0.0], 1.0);
        tracker.add(Uuid::new_v4(), vec![0.0, 1.0], 1.0);

        let centroid = tracker.compute_context_centroid().unwrap();

        // With equal importance and near-1.0 decay, should be close to [0.5, 0.5]
        // (slightly weighted toward the more recent entry)
        assert!(centroid[0] > 0.0 && centroid[0] < 1.0);
        assert!(centroid[1] > 0.0 && centroid[1] < 1.0);
    }

    // ========== Stats Tests ==========

    #[test]
    fn test_stats() {
        let mut tracker = CoherenceTracker::default();

        tracker.add(Uuid::new_v4(), vec![0.1; 128], 0.5);
        tracker.add(Uuid::new_v4(), vec![0.2; 128], 0.7);

        let stats = tracker.stats();

        assert_eq!(stats.window_size, 2);
        assert_eq!(stats.capacity, 100);
        assert!((stats.average_importance - 0.6).abs() < 1e-6);
    }

    // ========== Performance Tests ==========

    #[test]
    fn test_coherence_performance() {
        let mut tracker = CoherenceTracker::default();

        // Fill window with 100 entries
        for i in 0..100 {
            let embedding: Vec<f32> = (0..1536).map(|j| ((i + j) as f32 * 0.01).sin()).collect();
            tracker.add(Uuid::new_v4(), embedding, 0.5);
        }

        let test_embedding: Vec<f32> = (0..1536).map(|i| (i as f32 * 0.01).cos()).collect();

        let start = std::time::Instant::now();
        for _ in 0..100 {
            let _ = tracker.compute_coherence(&test_embedding, None);
        }
        let elapsed = start.elapsed();
        let per_op = elapsed / 100;

        assert!(per_op.as_millis() < 5,
            "Performance target missed: {:?} per operation", per_op);
    }
}
```

---

## Acceptance Criteria

### Functional Requirements

- [ ] `CoherenceTracker::new(config)` creates tracker with specified configuration
- [ ] `CoherenceTracker::with_graph()` accepts knowledge graph reference
- [ ] `compute_coherence()` returns delta_c in [0, 1] range
- [ ] `compute_coherence()` returns `default_coherence_empty` when window is empty
- [ ] `compute_semantic_coherence()` applies recency decay correctly
- [ ] `compute_semantic_coherence()` applies importance weighting
- [ ] `update()` adds entries and evicts oldest at capacity
- [ ] Recency decay formula: `decay^i` where i=0 is most recent
- [ ] Coherence maps similarity [-1, 1] to coherence [0, 1]

### Performance Requirements

- [ ] `compute_coherence()` executes in <5ms for 100 window entries
- [ ] Efficient iteration avoiding unnecessary allocations

### Code Quality Requirements

- [ ] `KnowledgeGraphRef` trait defined for future integration
- [ ] `CoherenceStats` struct for introspection
- [ ] No `unwrap()` in production code
- [ ] Comprehensive rustdoc documentation
- [ ] Debug trait implemented

---

## Integration Notes

### Upstream Dependencies

- M05-T03: `CoherenceConfig` struct
- M05-T09: `cosine_similarity()` function
- M05-T12: `CoherenceEntry`, `CoherenceWindow`

### Downstream Consumers

- M05-T14: Extends with structural coherence and contradiction detection
- M05-T22: `UtlProcessor` uses `CoherenceTracker` for delta_c computation

---

## Revision History

| Date | Author | Changes |
|------|--------|---------|
| 2026-01-04 | AI Agent | Initial atomic task creation from M05 master spec |
