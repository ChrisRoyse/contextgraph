# M05-T17: Implement PhaseOscillator for Consolidation Timing

```yaml
metadata:
  id: "M05-T17"
  title: "Implement PhaseOscillator for Consolidation Timing"
  module: "module-05"
  module_name: "UTL Integration"
  layer: "logic"
  priority: "high"
  estimated_hours: 2.5
  created: "2026-01-04"
  status: "pending"
  dependencies: []
  spec_refs:
    - "TECH-UTL-005 Section 8"
    - "SPEC-UTL-005 Section 6"
```

---

## Description

Implement PhaseOscillator struct for theta-inspired memory phase tracking in the UTL system.

The phase oscillator models the encoding-consolidation cycle inspired by hippocampal theta rhythms:
- **Encoding Phase** (phi near 0): Optimal for new memory acquisition
- **Transition Phase**: Intermediate state between encoding and consolidation
- **Consolidation Phase** (phi near PI): Optimal for memory strengthening

The phase angle (phi) advances based on elapsed time and modulation factor, oscillating using |sin| * PI formula. This provides a biological plausibility constraint on when memories should be consolidated.

---

## File Path

```
crates/context-graph-utl/src/phase/oscillator.rs
```

---

## Enums and Structs

### ConsolidationPhase Enum

```rust
/// Represents the current phase of memory processing.
///
/// Based on hippocampal theta rhythms, memory processing alternates
/// between encoding (acquisition) and consolidation (strengthening).
#[derive(Clone, Copy, Debug, PartialEq, Eq, Serialize, Deserialize)]
#[repr(u8)]
pub enum ConsolidationPhase {
    /// Encoding phase (phi near 0): Optimal for new memory acquisition.
    /// The system is primed to accept and store new information.
    Encoding = 0,

    /// Transition phase: Intermediate state between encoding and consolidation.
    /// Neither optimally encoding nor consolidating.
    Transition = 1,

    /// Consolidation phase (phi near PI): Optimal for memory strengthening.
    /// The system is primed to reinforce existing memories.
    Consolidation = 2,
}

impl ConsolidationPhase {
    /// Returns the phase name as a string.
    pub fn name(&self) -> &'static str {
        match self {
            Self::Encoding => "encoding",
            Self::Transition => "transition",
            Self::Consolidation => "consolidation",
        }
    }

    /// Returns true if in the encoding phase.
    pub fn is_encoding(&self) -> bool {
        matches!(self, Self::Encoding)
    }

    /// Returns true if in the consolidation phase.
    pub fn is_consolidation(&self) -> bool {
        matches!(self, Self::Consolidation)
    }
}

impl Default for ConsolidationPhase {
    fn default() -> Self {
        Self::Encoding
    }
}
```

### PhaseOscillator Struct

```rust
use std::f32::consts::PI;
use std::time::Instant;
use serde::{Deserialize, Serialize};

use crate::config::PhaseConfig;

/// Theta-inspired phase oscillator for memory consolidation timing.
///
/// Models the encoding-consolidation cycle with phase angle phi in [0, PI].
/// Phase advances based on elapsed time and modulation factor.
///
/// # Phase Dynamics
/// - phi = 0: Peak encoding
/// - phi = PI: Peak consolidation
/// - Oscillation: |sin(frequency * time * modulation)| * PI
///
/// # Example
/// ```rust
/// use context_graph_utl::phase::{PhaseOscillator, PhaseConfig};
///
/// let config = PhaseConfig::default();
/// let mut oscillator = PhaseOscillator::new(config);
///
/// // Initially in encoding phase
/// assert!(oscillator.get_phase().is_encoding());
///
/// // Phase advances over time
/// std::thread::sleep(std::time::Duration::from_millis(100));
/// let phi = oscillator.get_phi();
/// assert!(phi >= 0.0 && phi <= PI);
/// ```
pub struct PhaseOscillator {
    /// Current phase angle in [0, PI]
    phi: f32,

    /// Base oscillation frequency (radians per second)
    frequency: f32,

    /// Last time the phase was updated
    last_update: Instant,

    /// Modulation factor for phase advancement speed
    modulation: f32,

    /// Configuration parameters
    config: PhaseConfig,
}

impl PhaseOscillator {
    /// Creates a new PhaseOscillator with the given configuration.
    pub fn new(config: PhaseConfig) -> Self {
        Self {
            phi: 0.0,
            frequency: config.base_frequency,
            last_update: Instant::now(),
            modulation: 1.0,
            config,
        }
    }

    /// Gets the current phase angle, updating based on elapsed time.
    ///
    /// # Returns
    /// Phase angle phi in [0, PI]
    ///
    /// # Performance
    /// Target: <10us
    #[inline]
    pub fn get_phi(&mut self) -> f32 {
        self.update_phase();
        self.phi
    }

    /// Gets the current consolidation phase (Encoding/Transition/Consolidation).
    pub fn get_phase(&mut self) -> ConsolidationPhase {
        let phi = self.get_phi();
        let normalized = phi / PI;

        if normalized < self.config.encoding_threshold {
            ConsolidationPhase::Encoding
        } else if normalized > self.config.consolidation_threshold {
            ConsolidationPhase::Consolidation
        } else {
            ConsolidationPhase::Transition
        }
    }

    /// Gets the current phase without updating (for read-only access).
    pub fn peek_phi(&self) -> f32 {
        self.phi
    }

    /// Gets the current phase without updating.
    pub fn peek_phase(&self) -> ConsolidationPhase {
        let normalized = self.phi / PI;

        if normalized < self.config.encoding_threshold {
            ConsolidationPhase::Encoding
        } else if normalized > self.config.consolidation_threshold {
            ConsolidationPhase::Consolidation
        } else {
            ConsolidationPhase::Transition
        }
    }

    /// Sets the modulation factor for phase advancement speed.
    ///
    /// Higher modulation = faster phase advancement.
    /// Clamped to [modulation_min, modulation_max].
    ///
    /// # Arguments
    /// * `modulation` - Modulation factor, clamped to config bounds
    pub fn set_modulation(&mut self, modulation: f32) {
        self.modulation = modulation.clamp(
            self.config.modulation_min,
            self.config.modulation_max,
        );
    }

    /// Gets the current modulation factor.
    pub fn get_modulation(&self) -> f32 {
        self.modulation
    }

    /// Resets the oscillator to the encoding phase (phi = 0).
    pub fn reset_to_encoding(&mut self) {
        self.phi = 0.0;
        self.last_update = Instant::now();
    }

    /// Forces the oscillator to the consolidation phase (phi = 0.9 * PI).
    ///
    /// Used when consolidation should be triggered immediately
    /// (e.g., high importance memory or explicit trigger).
    pub fn force_consolidation(&mut self) {
        self.phi = 0.9 * PI;
        self.last_update = Instant::now();
    }

    /// Sets the phase angle directly (for testing/restoration).
    pub fn set_phi(&mut self, phi: f32) {
        self.phi = phi.clamp(0.0, PI);
        self.last_update = Instant::now();
    }

    /// Gets the base frequency.
    pub fn get_frequency(&self) -> f32 {
        self.frequency
    }

    /// Computes cos(phi) for use in UTL learning magnitude.
    ///
    /// cos(phi) ranges from 1 (encoding) to -1 (consolidation).
    #[inline]
    pub fn cos_phi(&mut self) -> f32 {
        self.get_phi().cos()
    }

    // -------------------------------------------------------------------------
    // Private Methods
    // -------------------------------------------------------------------------

    /// Updates the phase based on elapsed time.
    fn update_phase(&mut self) {
        let now = Instant::now();
        let elapsed = now.duration_since(self.last_update).as_secs_f32();
        self.last_update = now;

        // Oscillation formula: |sin(frequency * time * modulation)| * PI
        // We accumulate phase based on elapsed time
        let phase_advance = self.frequency * elapsed * self.modulation;
        let raw_phi = self.phi + phase_advance;

        // Oscillate using |sin| to keep in [0, PI]
        // This creates a smooth oscillation between encoding and consolidation
        self.phi = raw_phi.sin().abs() * PI;
    }
}

impl Clone for PhaseOscillator {
    fn clone(&self) -> Self {
        Self {
            phi: self.phi,
            frequency: self.frequency,
            last_update: Instant::now(), // Reset timer for clone
            modulation: self.modulation,
            config: self.config.clone(),
        }
    }
}
```

---

## Acceptance Criteria

- [ ] PhaseOscillator struct with phi (f32 in [0, PI]), frequency (f32), last_update (Instant), modulation (f32)
- [ ] ConsolidationPhase enum with 3 variants: Encoding, Transition, Consolidation
- [ ] get_phi() updates phase based on elapsed time and returns phi in [0, PI]
- [ ] Phase oscillates using |sin| * PI formula
- [ ] set_modulation() clamps to [modulation_min, modulation_max] from config
- [ ] force_consolidation() sets phi to 0.9 * PI
- [ ] reset_to_encoding() sets phi to 0.0
- [ ] Performance: <10us per get_phi() call
- [ ] cos_phi() returns cos(phi) for UTL computation
- [ ] peek_phi() and peek_phase() allow read-only access without update

---

## Test File

```
crates/context-graph-utl/tests/phase_tests.rs
```

### Test Cases

```rust
#[cfg(test)]
mod phase_oscillator_tests {
    use super::*;
    use std::f32::consts::PI;
    use std::time::{Duration, Instant};

    fn default_config() -> PhaseConfig {
        PhaseConfig {
            base_frequency: 0.1,
            modulation_min: 0.1,
            modulation_max: 3.0,
            encoding_threshold: 0.33,
            consolidation_threshold: 0.67,
            consolidation_phase_threshold: 2.1,
            consolidation_importance_threshold: 0.4,
            consolidation_staleness_seconds: 300,
        }
    }

    #[test]
    fn test_initial_encoding_phase() {
        let config = default_config();
        let mut oscillator = PhaseOscillator::new(config);

        assert!(oscillator.get_phase().is_encoding());
        assert_eq!(oscillator.peek_phi(), 0.0);
    }

    #[test]
    fn test_phi_bounds() {
        let config = default_config();
        let mut oscillator = PhaseOscillator::new(config);

        // Force to various states and verify bounds
        oscillator.set_phi(-1.0);
        assert_eq!(oscillator.peek_phi(), 0.0);

        oscillator.set_phi(PI + 1.0);
        assert_eq!(oscillator.peek_phi(), PI);

        oscillator.set_phi(PI / 2.0);
        assert!((oscillator.peek_phi() - PI / 2.0).abs() < 0.001);
    }

    #[test]
    fn test_force_consolidation() {
        let config = default_config();
        let mut oscillator = PhaseOscillator::new(config);

        oscillator.force_consolidation();

        assert!((oscillator.peek_phi() - 0.9 * PI).abs() < 0.001);
        assert!(oscillator.peek_phase().is_consolidation());
    }

    #[test]
    fn test_reset_to_encoding() {
        let config = default_config();
        let mut oscillator = PhaseOscillator::new(config);

        oscillator.force_consolidation();
        oscillator.reset_to_encoding();

        assert_eq!(oscillator.peek_phi(), 0.0);
        assert!(oscillator.peek_phase().is_encoding());
    }

    #[test]
    fn test_modulation_bounds() {
        let config = default_config();
        let mut oscillator = PhaseOscillator::new(config);

        // Below minimum
        oscillator.set_modulation(0.01);
        assert_eq!(oscillator.get_modulation(), 0.1);

        // Above maximum
        oscillator.set_modulation(10.0);
        assert_eq!(oscillator.get_modulation(), 3.0);

        // Within range
        oscillator.set_modulation(1.5);
        assert_eq!(oscillator.get_modulation(), 1.5);
    }

    #[test]
    fn test_phase_classification() {
        let config = default_config();
        let mut oscillator = PhaseOscillator::new(config);

        // Encoding phase (normalized < 0.33)
        oscillator.set_phi(0.1 * PI);
        assert_eq!(oscillator.peek_phase(), ConsolidationPhase::Encoding);

        // Transition phase (0.33 <= normalized <= 0.67)
        oscillator.set_phi(0.5 * PI);
        assert_eq!(oscillator.peek_phase(), ConsolidationPhase::Transition);

        // Consolidation phase (normalized > 0.67)
        oscillator.set_phi(0.8 * PI);
        assert_eq!(oscillator.peek_phase(), ConsolidationPhase::Consolidation);
    }

    #[test]
    fn test_cos_phi_range() {
        let config = default_config();
        let mut oscillator = PhaseOscillator::new(config);

        // At encoding (phi = 0), cos(phi) = 1
        oscillator.set_phi(0.0);
        assert!((oscillator.cos_phi() - 1.0).abs() < 0.001);

        // At consolidation (phi = PI), cos(phi) = -1
        oscillator.set_phi(PI);
        assert!((oscillator.cos_phi() - (-1.0)).abs() < 0.001);

        // At transition (phi = PI/2), cos(phi) = 0
        oscillator.set_phi(PI / 2.0);
        assert!(oscillator.cos_phi().abs() < 0.001);
    }

    #[test]
    fn test_performance_under_10us() {
        let config = default_config();
        let mut oscillator = PhaseOscillator::new(config);

        let start = Instant::now();
        for _ in 0..10000 {
            let _ = oscillator.get_phi();
        }
        let elapsed = start.elapsed();

        // Average should be under 10us
        let avg_ns = elapsed.as_nanos() / 10000;
        assert!(avg_ns < 10000, "Average took {}ns, should be <10000ns", avg_ns);
    }

    #[test]
    fn test_consolidation_phase_name() {
        assert_eq!(ConsolidationPhase::Encoding.name(), "encoding");
        assert_eq!(ConsolidationPhase::Transition.name(), "transition");
        assert_eq!(ConsolidationPhase::Consolidation.name(), "consolidation");
    }

    #[test]
    fn test_peek_vs_get() {
        let config = default_config();
        let mut oscillator = PhaseOscillator::new(config);

        let phi1 = oscillator.peek_phi();
        let phi2 = oscillator.peek_phi();
        // peek_phi should not update, so values should be equal
        assert_eq!(phi1, phi2);

        // get_phi updates based on time
        std::thread::sleep(Duration::from_millis(10));
        let phi3 = oscillator.get_phi();
        // After sleep and get_phi, value may have changed
        // (depends on frequency, could still be similar for short sleep)
    }

    #[test]
    fn test_clone() {
        let config = default_config();
        let mut oscillator = PhaseOscillator::new(config);
        oscillator.set_phi(PI / 4.0);
        oscillator.set_modulation(2.0);

        let cloned = oscillator.clone();

        assert_eq!(oscillator.peek_phi(), cloned.peek_phi());
        assert_eq!(oscillator.get_modulation(), cloned.get_modulation());
    }
}
```

---

## Implementation Notes

1. **Theta Rhythm Inspiration**: Based on hippocampal theta oscillations (4-8 Hz in biology, much slower here for practical use)
2. **|sin| Formula**: Using |sin| * PI ensures phi stays in [0, PI] while oscillating
3. **Modulation**: Allows external factors (e.g., user activity, system load) to influence phase speed
4. **cos(phi) Usage**: In UTL equation, cos(phi) modulates learning magnitude:
   - cos(0) = 1: Maximum encoding weight
   - cos(PI) = -1: Maximum consolidation weight
5. **Performance Critical**: get_phi() is called frequently, must be <10us

---

## Dependencies

| Dependency | Purpose |
|------------|---------|
| M05-T32 | PhaseConfig struct for configuration |
| std::time::Instant | Time tracking |
| serde | Serialization for ConsolidationPhase |

---

## Related Tasks

| Task ID | Relationship |
|---------|--------------|
| M05-T20 | Uses cos(phi) in learning magnitude computation |
| M05-T22 | Integrates phase into UtlProcessor |
| M05-T32 | Provides PhaseConfig configuration |
