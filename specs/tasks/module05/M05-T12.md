# M05-T12: Define CoherenceEntry and Rolling Window

| Field | Value |
|-------|-------|
| **Task ID** | M05-T12 |
| **Module** | context-graph-utl |
| **Status** | Pending |
| **Priority** | P1 (High) |
| **Depends On** | M05-T03 (CoherenceConfig) |
| **Estimated Hours** | 1.5 |
| **Constitution Refs** | TECH-UTL-005 Section 6.1, SPEC-UTL-005 Section 4.2 |

---

## Executive Summary

Implement the `CoherenceEntry` struct and a rolling window buffer for tracking recent memory entries used in coherence computation. The rolling window maintains a fixed-size history of recent embeddings with metadata, enabling efficient semantic coherence calculations.

**Key Components:**
- `CoherenceEntry` - Individual entry in the coherence window
- `CoherenceWindow` - VecDeque-based rolling window with capacity management
- Automatic eviction of oldest entries when capacity is reached

---

## Implementation Requirements

### File Location

**Source File:** `crates/context-graph-utl/src/coherence/tracker.rs`

### Module Structure

```rust
// In crates/context-graph-utl/src/coherence/mod.rs
pub mod tracker;

pub use tracker::{CoherenceEntry, CoherenceWindow, CoherenceTracker};
```

### Data Structures

#### 1. `CoherenceEntry` Struct

```rust
use chrono::{DateTime, Utc};
use uuid::Uuid;
use serde::{Deserialize, Serialize};

/// An entry in the coherence tracking window.
///
/// Each entry represents a recently processed memory node and its embedding,
/// used for computing semantic coherence of new content.
///
/// # Example
///
/// ```rust
/// use context_graph_utl::coherence::CoherenceEntry;
/// use uuid::Uuid;
/// use chrono::Utc;
///
/// let entry = CoherenceEntry::new(
///     Uuid::new_v4(),
///     vec![0.5; 1536],
///     0.8, // importance
/// );
/// ```
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CoherenceEntry {
    /// Unique identifier of the memory node
    node_id: Uuid,

    /// Embedding vector of the content
    embedding: Vec<f32>,

    /// Timestamp when this entry was added
    timestamp: DateTime<Utc>,

    /// Importance score from UTL computation (used for weighting)
    importance: f32,
}

impl CoherenceEntry {
    /// Create a new coherence entry.
    ///
    /// # Arguments
    ///
    /// * `node_id` - UUID of the memory node
    /// * `embedding` - Embedding vector (typically 1536 dimensions)
    /// * `importance` - Importance score in range [0, 1]
    ///
    /// # Example
    ///
    /// ```rust
    /// let entry = CoherenceEntry::new(
    ///     Uuid::new_v4(),
    ///     vec![0.1, 0.2, 0.3],
    ///     0.75,
    /// );
    /// assert_eq!(entry.importance(), 0.75);
    /// ```
    pub fn new(node_id: Uuid, embedding: Vec<f32>, importance: f32) -> Self {
        Self {
            node_id,
            embedding,
            timestamp: Utc::now(),
            importance: importance.clamp(0.0, 1.0),
        }
    }

    /// Create an entry with a specific timestamp.
    ///
    /// Useful for testing or restoring from persistence.
    pub fn with_timestamp(
        node_id: Uuid,
        embedding: Vec<f32>,
        importance: f32,
        timestamp: DateTime<Utc>,
    ) -> Self {
        Self {
            node_id,
            embedding,
            timestamp,
            importance: importance.clamp(0.0, 1.0),
        }
    }

    /// Get the node ID.
    #[inline]
    pub fn node_id(&self) -> Uuid {
        self.node_id
    }

    /// Get the embedding vector.
    #[inline]
    pub fn embedding(&self) -> &[f32] {
        &self.embedding
    }

    /// Get the embedding dimension.
    #[inline]
    pub fn dimension(&self) -> usize {
        self.embedding.len()
    }

    /// Get the timestamp.
    #[inline]
    pub fn timestamp(&self) -> DateTime<Utc> {
        self.timestamp
    }

    /// Get the importance score.
    #[inline]
    pub fn importance(&self) -> f32 {
        self.importance
    }

    /// Calculate age in seconds from now.
    pub fn age_seconds(&self) -> i64 {
        (Utc::now() - self.timestamp).num_seconds()
    }
}
```

#### 2. `CoherenceWindow` Struct

```rust
use std::collections::VecDeque;

/// A fixed-capacity rolling window of coherence entries.
///
/// Maintains a FIFO queue of recent entries, automatically evicting
/// the oldest entry when capacity is reached. Used for computing
/// semantic coherence of new content against recent context.
///
/// # Capacity Management
///
/// When a new entry is added and the window is at capacity,
/// the oldest entry is automatically removed before insertion.
///
/// # Example
///
/// ```rust
/// use context_graph_utl::coherence::CoherenceWindow;
///
/// let mut window = CoherenceWindow::new(100); // Max 100 entries
///
/// // Add entries...
/// window.push(entry1);
/// window.push(entry2);
///
/// assert_eq!(window.len(), 2);
/// ```
#[derive(Debug, Clone)]
pub struct CoherenceWindow {
    /// The entries in order from oldest to newest
    entries: VecDeque<CoherenceEntry>,

    /// Maximum number of entries to retain
    capacity: usize,
}

impl CoherenceWindow {
    /// Create a new coherence window with the specified capacity.
    ///
    /// # Arguments
    ///
    /// * `capacity` - Maximum number of entries to retain
    ///
    /// # Panics
    ///
    /// Panics if capacity is 0.
    pub fn new(capacity: usize) -> Self {
        assert!(capacity > 0, "CoherenceWindow capacity must be > 0");
        Self {
            entries: VecDeque::with_capacity(capacity),
            capacity,
        }
    }

    /// Create a window with default capacity (100).
    pub fn default() -> Self {
        Self::new(100)
    }

    /// Add an entry to the window.
    ///
    /// If the window is at capacity, the oldest entry is removed first.
    ///
    /// # Arguments
    ///
    /// * `entry` - The coherence entry to add
    ///
    /// # Returns
    ///
    /// The evicted entry if one was removed, None otherwise.
    pub fn push(&mut self, entry: CoherenceEntry) -> Option<CoherenceEntry> {
        let evicted = if self.entries.len() >= self.capacity {
            self.entries.pop_front()
        } else {
            None
        };

        self.entries.push_back(entry);
        evicted
    }

    /// Add an entry, returning ownership if evicted.
    ///
    /// Convenience method that creates a CoherenceEntry and adds it.
    pub fn add(
        &mut self,
        node_id: Uuid,
        embedding: Vec<f32>,
        importance: f32,
    ) -> Option<CoherenceEntry> {
        let entry = CoherenceEntry::new(node_id, embedding, importance);
        self.push(entry)
    }

    /// Get the number of entries in the window.
    #[inline]
    pub fn len(&self) -> usize {
        self.entries.len()
    }

    /// Check if the window is empty.
    #[inline]
    pub fn is_empty(&self) -> bool {
        self.entries.is_empty()
    }

    /// Check if the window is at capacity.
    #[inline]
    pub fn is_full(&self) -> bool {
        self.entries.len() >= self.capacity
    }

    /// Get the capacity of the window.
    #[inline]
    pub fn capacity(&self) -> usize {
        self.capacity
    }

    /// Clear all entries from the window.
    pub fn clear(&mut self) {
        self.entries.clear();
    }

    /// Get an iterator over the entries (oldest to newest).
    pub fn iter(&self) -> impl Iterator<Item = &CoherenceEntry> {
        self.entries.iter()
    }

    /// Get an iterator over entries in reverse order (newest to oldest).
    pub fn iter_rev(&self) -> impl Iterator<Item = &CoherenceEntry> {
        self.entries.iter().rev()
    }

    /// Get all embeddings as a vector of slices.
    ///
    /// Useful for batch operations on all embeddings.
    pub fn embeddings(&self) -> Vec<&[f32]> {
        self.entries.iter().map(|e| e.embedding()).collect()
    }

    /// Get embeddings as owned vectors.
    ///
    /// Creates clones of all embedding vectors.
    pub fn embeddings_owned(&self) -> Vec<Vec<f32>> {
        self.entries.iter().map(|e| e.embedding.clone()).collect()
    }

    /// Get the most recent entry.
    pub fn newest(&self) -> Option<&CoherenceEntry> {
        self.entries.back()
    }

    /// Get the oldest entry.
    pub fn oldest(&self) -> Option<&CoherenceEntry> {
        self.entries.front()
    }

    /// Get entry by index (0 = oldest).
    pub fn get(&self, index: usize) -> Option<&CoherenceEntry> {
        self.entries.get(index)
    }

    /// Remove entries older than the given age threshold.
    ///
    /// # Arguments
    ///
    /// * `max_age_seconds` - Maximum age in seconds to retain
    ///
    /// # Returns
    ///
    /// Number of entries removed.
    pub fn evict_older_than(&mut self, max_age_seconds: i64) -> usize {
        let cutoff = Utc::now() - chrono::Duration::seconds(max_age_seconds);
        let original_len = self.entries.len();

        self.entries.retain(|e| e.timestamp >= cutoff);

        original_len - self.entries.len()
    }

    /// Calculate the average importance of entries in the window.
    pub fn average_importance(&self) -> f32 {
        if self.entries.is_empty() {
            return 0.0;
        }

        let sum: f32 = self.entries.iter().map(|e| e.importance).sum();
        sum / self.entries.len() as f32
    }

    /// Find an entry by node ID.
    pub fn find_by_id(&self, node_id: Uuid) -> Option<&CoherenceEntry> {
        self.entries.iter().find(|e| e.node_id == node_id)
    }

    /// Check if the window contains an entry with the given node ID.
    pub fn contains_id(&self, node_id: Uuid) -> bool {
        self.entries.iter().any(|e| e.node_id == node_id)
    }
}

impl Default for CoherenceWindow {
    fn default() -> Self {
        Self::new(100)
    }
}

impl IntoIterator for CoherenceWindow {
    type Item = CoherenceEntry;
    type IntoIter = std::collections::vec_deque::IntoIter<CoherenceEntry>;

    fn into_iter(self) -> Self::IntoIter {
        self.entries.into_iter()
    }
}

impl<'a> IntoIterator for &'a CoherenceWindow {
    type Item = &'a CoherenceEntry;
    type IntoIter = std::collections::vec_deque::Iter<'a, CoherenceEntry>;

    fn into_iter(self) -> Self::IntoIter {
        self.entries.iter()
    }
}
```

---

## Test Cases

### File Location

**Test File:** `crates/context-graph-utl/tests/coherence_tests.rs`

### Required Tests

```rust
#[cfg(test)]
mod coherence_entry_tests {
    use super::*;
    use uuid::Uuid;
    use chrono::Utc;

    // ========== CoherenceEntry Tests ==========

    #[test]
    fn test_entry_new() {
        let id = Uuid::new_v4();
        let embedding = vec![0.1, 0.2, 0.3];
        let entry = CoherenceEntry::new(id, embedding.clone(), 0.75);

        assert_eq!(entry.node_id(), id);
        assert_eq!(entry.embedding(), &embedding[..]);
        assert_eq!(entry.importance(), 0.75);
        assert!(entry.age_seconds() >= 0);
    }

    #[test]
    fn test_entry_importance_clamped() {
        let entry_high = CoherenceEntry::new(Uuid::new_v4(), vec![0.1], 1.5);
        assert_eq!(entry_high.importance(), 1.0);

        let entry_low = CoherenceEntry::new(Uuid::new_v4(), vec![0.1], -0.5);
        assert_eq!(entry_low.importance(), 0.0);
    }

    #[test]
    fn test_entry_with_timestamp() {
        let ts = Utc::now() - chrono::Duration::seconds(100);
        let entry = CoherenceEntry::with_timestamp(
            Uuid::new_v4(),
            vec![0.1],
            0.5,
            ts,
        );

        assert_eq!(entry.timestamp(), ts);
        assert!(entry.age_seconds() >= 100);
    }

    #[test]
    fn test_entry_dimension() {
        let entry = CoherenceEntry::new(Uuid::new_v4(), vec![0.1; 1536], 0.5);
        assert_eq!(entry.dimension(), 1536);
    }
}

#[cfg(test)]
mod coherence_window_tests {
    use super::*;
    use uuid::Uuid;

    fn make_entry(importance: f32) -> CoherenceEntry {
        CoherenceEntry::new(Uuid::new_v4(), vec![0.1, 0.2], importance)
    }

    // ========== Construction Tests ==========

    #[test]
    fn test_window_new() {
        let window = CoherenceWindow::new(50);
        assert_eq!(window.capacity(), 50);
        assert!(window.is_empty());
        assert_eq!(window.len(), 0);
    }

    #[test]
    fn test_window_default() {
        let window = CoherenceWindow::default();
        assert_eq!(window.capacity(), 100);
    }

    #[test]
    #[should_panic(expected = "capacity must be > 0")]
    fn test_window_zero_capacity_panics() {
        let _ = CoherenceWindow::new(0);
    }

    // ========== Push and Eviction Tests ==========

    #[test]
    fn test_window_push() {
        let mut window = CoherenceWindow::new(10);
        let entry = make_entry(0.5);

        let evicted = window.push(entry);

        assert!(evicted.is_none());
        assert_eq!(window.len(), 1);
    }

    #[test]
    fn test_window_push_evicts_at_capacity() {
        let mut window = CoherenceWindow::new(3);

        for i in 0..3 {
            let _ = window.add(Uuid::new_v4(), vec![i as f32], 0.5);
        }
        assert!(window.is_full());

        // This should evict the first entry
        let evicted = window.add(Uuid::new_v4(), vec![99.0], 0.5);

        assert!(evicted.is_some());
        assert_eq!(evicted.unwrap().embedding()[0], 0.0);
        assert_eq!(window.len(), 3);
    }

    #[test]
    fn test_window_fifo_order() {
        let mut window = CoherenceWindow::new(3);

        for i in 0..3 {
            let _ = window.add(Uuid::new_v4(), vec![i as f32], 0.5);
        }

        let oldest = window.oldest().unwrap();
        let newest = window.newest().unwrap();

        assert_eq!(oldest.embedding()[0], 0.0);
        assert_eq!(newest.embedding()[0], 2.0);
    }

    // ========== Query Tests ==========

    #[test]
    fn test_window_embeddings() {
        let mut window = CoherenceWindow::new(10);
        window.add(Uuid::new_v4(), vec![1.0, 2.0], 0.5);
        window.add(Uuid::new_v4(), vec![3.0, 4.0], 0.5);

        let embeddings = window.embeddings();

        assert_eq!(embeddings.len(), 2);
        assert_eq!(embeddings[0], &[1.0, 2.0]);
        assert_eq!(embeddings[1], &[3.0, 4.0]);
    }

    #[test]
    fn test_window_find_by_id() {
        let mut window = CoherenceWindow::new(10);
        let id = Uuid::new_v4();

        window.add(id, vec![1.0], 0.5);
        window.add(Uuid::new_v4(), vec![2.0], 0.5);

        let found = window.find_by_id(id);
        assert!(found.is_some());
        assert_eq!(found.unwrap().embedding()[0], 1.0);

        let not_found = window.find_by_id(Uuid::new_v4());
        assert!(not_found.is_none());
    }

    #[test]
    fn test_window_contains_id() {
        let mut window = CoherenceWindow::new(10);
        let id = Uuid::new_v4();

        window.add(id, vec![1.0], 0.5);

        assert!(window.contains_id(id));
        assert!(!window.contains_id(Uuid::new_v4()));
    }

    // ========== Clearing and Age Tests ==========

    #[test]
    fn test_window_clear() {
        let mut window = CoherenceWindow::new(10);
        window.add(Uuid::new_v4(), vec![1.0], 0.5);
        window.add(Uuid::new_v4(), vec![2.0], 0.5);

        window.clear();

        assert!(window.is_empty());
        assert_eq!(window.len(), 0);
    }

    #[test]
    fn test_window_evict_older_than() {
        let mut window = CoherenceWindow::new(10);

        // Add old entry
        let old_ts = Utc::now() - chrono::Duration::seconds(200);
        let old_entry = CoherenceEntry::with_timestamp(
            Uuid::new_v4(), vec![1.0], 0.5, old_ts
        );
        window.push(old_entry);

        // Add recent entry
        window.add(Uuid::new_v4(), vec![2.0], 0.5);

        let removed = window.evict_older_than(100);

        assert_eq!(removed, 1);
        assert_eq!(window.len(), 1);
        assert_eq!(window.newest().unwrap().embedding()[0], 2.0);
    }

    // ========== Statistics Tests ==========

    #[test]
    fn test_average_importance() {
        let mut window = CoherenceWindow::new(10);
        window.push(make_entry(0.2));
        window.push(make_entry(0.4));
        window.push(make_entry(0.6));

        let avg = window.average_importance();
        assert!((avg - 0.4).abs() < 1e-6);
    }

    #[test]
    fn test_average_importance_empty() {
        let window = CoherenceWindow::new(10);
        assert_eq!(window.average_importance(), 0.0);
    }

    // ========== Iterator Tests ==========

    #[test]
    fn test_window_iter() {
        let mut window = CoherenceWindow::new(10);
        window.push(make_entry(0.1));
        window.push(make_entry(0.2));

        let importances: Vec<f32> = window.iter().map(|e| e.importance()).collect();
        assert_eq!(importances, vec![0.1, 0.2]);
    }

    #[test]
    fn test_window_iter_rev() {
        let mut window = CoherenceWindow::new(10);
        window.push(make_entry(0.1));
        window.push(make_entry(0.2));

        let importances: Vec<f32> = window.iter_rev().map(|e| e.importance()).collect();
        assert_eq!(importances, vec![0.2, 0.1]);
    }

    #[test]
    fn test_window_into_iter() {
        let mut window = CoherenceWindow::new(10);
        window.push(make_entry(0.1));
        window.push(make_entry(0.2));

        let entries: Vec<CoherenceEntry> = window.into_iter().collect();
        assert_eq!(entries.len(), 2);
    }
}
```

---

## Acceptance Criteria

### Functional Requirements

- [ ] `CoherenceEntry` struct with 4 required fields (node_id, embedding, timestamp, importance)
- [ ] `CoherenceEntry::new()` creates entry with current timestamp
- [ ] `CoherenceEntry::with_timestamp()` allows custom timestamp
- [ ] Importance is clamped to [0, 1] range
- [ ] `CoherenceWindow` uses `VecDeque` for efficient FIFO operations
- [ ] `CoherenceWindow::push()` evicts oldest when at capacity
- [ ] `CoherenceWindow::push()` returns evicted entry if any
- [ ] `CoherenceWindow::clear()` empties the window
- [ ] `CoherenceWindow::evict_older_than()` removes stale entries
- [ ] All iterator traits implemented for ergonomic access

### Performance Requirements

- [ ] Push operation is O(1) amortized
- [ ] Eviction is O(1) (front removal from VecDeque)
- [ ] Memory efficient with pre-allocated capacity

### Code Quality Requirements

- [ ] `Clone` and `Debug` implemented for both structs
- [ ] `Serialize` and `Deserialize` for `CoherenceEntry`
- [ ] `Default` trait for `CoherenceWindow`
- [ ] No `unwrap()` in production code
- [ ] Comprehensive rustdoc documentation

---

## Integration Notes

### Upstream Dependencies

- M05-T03: `CoherenceConfig` provides window_size parameter

### Downstream Consumers

- M05-T13: `CoherenceTracker` uses `CoherenceWindow` for semantic coherence
- M05-T14: Structural coherence extends the tracker

---

## Revision History

| Date | Author | Changes |
|------|--------|---------|
| 2026-01-04 | AI Agent | Initial atomic task creation from M05 master spec |
