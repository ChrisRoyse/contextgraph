# M05-T24: Implement UtlMetrics and UtlStatus Structs

```yaml
task_id: M05-T24
title: "Implement UtlMetrics and UtlStatus Structs"
module: "Module 5: UTL Integration"
layer: "surface"
priority: "high"
status: "pending"
estimated_hours: 2
created: "2026-01-04"

file_path: "crates/context-graph-utl/src/metrics.rs"
test_file: "crates/context-graph-utl/tests/metrics_tests.rs"

dependencies:
  - "M05-T05"  # LifecycleStage
  - "M05-T06"  # LifecycleLambdaWeights
  - "M05-T08"  # JohariQuadrant

spec_refs:
  - "TECH-UTL-005 Section 2.2"
  - "SPEC-UTL-005 Section 10"
```

---

## Description

Implement `UtlMetrics` struct for monitoring UTL computation statistics and `UtlStatus` struct for complete status reporting. These structures support the `utl_status` MCP tool and internal monitoring.

---

## UtlMetrics Struct

Accumulated statistics from UTL computations.

### Fields

| Field | Type | Description |
|-------|------|-------------|
| `computation_count` | `u64` | Total number of computations |
| `avg_learning_magnitude` | `f32` | Running average of magnitude |
| `avg_delta_s` | `f32` | Running average of surprise |
| `avg_delta_c` | `f32` | Running average of coherence |
| `quadrant_distribution` | `QuadrantDistribution` | Counts per quadrant |
| `lifecycle_stage` | `LifecycleStage` | Current lifecycle stage |
| `lambda_weights` | `LifecycleLambdaWeights` | Current lambda weights |
| `avg_latency_us` | `f64` | Average latency in microseconds |
| `p99_latency_us` | `u64` | 99th percentile latency |

### Implementation

```rust
use serde::{Deserialize, Serialize};

use crate::lifecycle::{LifecycleStage, LifecycleLambdaWeights};
use crate::johari::JohariQuadrant;
use crate::phase::ConsolidationPhase;

/// Accumulated metrics from UTL computations
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UtlMetrics {
    /// Total number of UTL computations performed
    pub computation_count: u64,

    /// Running average of learning magnitude [0, 1]
    pub avg_learning_magnitude: f32,

    /// Running average of surprise (delta_s) [0, 1]
    pub avg_delta_s: f32,

    /// Running average of coherence (delta_c) [0, 1]
    pub avg_delta_c: f32,

    /// Distribution of Johari quadrant classifications
    pub quadrant_distribution: QuadrantDistribution,

    /// Current lifecycle stage
    pub lifecycle_stage: LifecycleStage,

    /// Current Marblestone lambda weights
    pub lambda_weights: LifecycleLambdaWeights,

    /// Average computation latency in microseconds
    pub avg_latency_us: f64,

    /// 99th percentile latency in microseconds
    pub p99_latency_us: u64,
}

impl Default for UtlMetrics {
    fn default() -> Self {
        Self {
            computation_count: 0,
            avg_learning_magnitude: 0.5,
            avg_delta_s: 0.0,
            avg_delta_c: 0.0,
            quadrant_distribution: QuadrantDistribution::default(),
            lifecycle_stage: LifecycleStage::default(),
            lambda_weights: LifecycleLambdaWeights::default(),
            avg_latency_us: 0.0,
            p99_latency_us: 0,
        }
    }
}

impl UtlMetrics {
    /// Create new empty metrics
    pub fn new() -> Self {
        Self::default()
    }

    /// Reset all metrics to initial state
    pub fn reset(&mut self) {
        *self = Self::default();
    }

    /// Get the dominant quadrant (most frequent)
    pub fn dominant_quadrant(&self) -> JohariQuadrant {
        self.quadrant_distribution.dominant()
    }

    /// Calculate learning efficiency (avg magnitude / avg latency ratio)
    pub fn learning_efficiency(&self) -> f64 {
        if self.avg_latency_us > 0.0 {
            (self.avg_learning_magnitude as f64) / self.avg_latency_us * 1000.0
        } else {
            0.0
        }
    }

    /// Check if metrics indicate healthy operation
    pub fn is_healthy(&self) -> bool {
        self.avg_latency_us < 10_000.0  // < 10ms
            && self.p99_latency_us < 50_000  // < 50ms p99
            && !self.avg_learning_magnitude.is_nan()
    }
}
```

---

## QuadrantDistribution Struct

Distribution counts for Johari quadrant classifications.

```rust
/// Distribution of classifications across Johari quadrants
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct QuadrantDistribution {
    /// Count of Open quadrant classifications
    pub open: u32,

    /// Count of Blind quadrant classifications
    pub blind: u32,

    /// Count of Hidden quadrant classifications
    pub hidden: u32,

    /// Count of Unknown quadrant classifications
    pub unknown: u32,
}

impl QuadrantDistribution {
    /// Create new empty distribution
    pub fn new() -> Self {
        Self::default()
    }

    /// Get total count across all quadrants
    pub fn total(&self) -> u32 {
        self.open + self.blind + self.hidden + self.unknown
    }

    /// Get percentages for each quadrant
    /// Returns [open_pct, blind_pct, hidden_pct, unknown_pct]
    pub fn percentages(&self) -> [f32; 4] {
        let total = self.total() as f32;
        if total == 0.0 {
            return [0.25, 0.25, 0.25, 0.25];  // Uniform when empty
        }

        [
            self.open as f32 / total,
            self.blind as f32 / total,
            self.hidden as f32 / total,
            self.unknown as f32 / total,
        ]
    }

    /// Get the dominant (most frequent) quadrant
    pub fn dominant(&self) -> JohariQuadrant {
        let counts = [
            (self.open, JohariQuadrant::Open),
            (self.blind, JohariQuadrant::Blind),
            (self.hidden, JohariQuadrant::Hidden),
            (self.unknown, JohariQuadrant::Unknown),
        ];

        counts
            .into_iter()
            .max_by_key(|(count, _)| *count)
            .map(|(_, quad)| quad)
            .unwrap_or(JohariQuadrant::Open)
    }

    /// Increment count for a specific quadrant
    pub fn increment(&mut self, quadrant: JohariQuadrant) {
        match quadrant {
            JohariQuadrant::Open => self.open += 1,
            JohariQuadrant::Blind => self.blind += 1,
            JohariQuadrant::Hidden => self.hidden += 1,
            JohariQuadrant::Unknown => self.unknown += 1,
        }
    }

    /// Get count for a specific quadrant
    pub fn count(&self, quadrant: JohariQuadrant) -> u32 {
        match quadrant {
            JohariQuadrant::Open => self.open,
            JohariQuadrant::Blind => self.blind,
            JohariQuadrant::Hidden => self.hidden,
            JohariQuadrant::Unknown => self.unknown,
        }
    }
}
```

---

## UtlStatus Struct

Complete status snapshot for `get_status()` and MCP tool responses.

```rust
use crate::lifecycle::StageThresholds;

/// Complete UTL system status for monitoring and MCP responses
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UtlStatus {
    /// Current lifecycle stage (Infancy, Growth, Maturity)
    pub lifecycle_stage: LifecycleStage,

    /// Total interaction count (determines stage)
    pub interaction_count: u64,

    /// Current thresholds for the lifecycle stage
    pub current_thresholds: StageThresholds,

    /// Current Marblestone lambda weights
    pub lambda_weights: LifecycleLambdaWeights,

    /// Current phase oscillator angle [0, PI]
    pub phase_angle: f32,

    /// Current consolidation phase
    pub consolidation_phase: ConsolidationPhase,

    /// Accumulated metrics
    pub metrics: UtlMetrics,
}

impl UtlStatus {
    /// Check if system is in encoding phase
    pub fn is_encoding(&self) -> bool {
        self.consolidation_phase == ConsolidationPhase::Encoding
    }

    /// Check if system is in consolidation phase
    pub fn is_consolidating(&self) -> bool {
        self.consolidation_phase == ConsolidationPhase::Consolidation
    }

    /// Check if system favors novelty (Infancy stage)
    pub fn is_novelty_seeking(&self) -> bool {
        self.lifecycle_stage == LifecycleStage::Infancy
    }

    /// Check if system favors consolidation (Maturity stage)
    pub fn is_consolidation_focused(&self) -> bool {
        self.lifecycle_stage == LifecycleStage::Maturity
    }

    /// Get a summary string for logging
    pub fn summary(&self) -> String {
        format!(
            "UTL: stage={:?}, interactions={}, phase={:?}, avg_L={:.3}",
            self.lifecycle_stage,
            self.interaction_count,
            self.consolidation_phase,
            self.metrics.avg_learning_magnitude
        )
    }

    /// Convert to MCP response format
    pub fn to_mcp_response(&self) -> UtlStatusResponse {
        UtlStatusResponse {
            lifecycle_phase: self.lifecycle_stage.name().to_string(),
            interaction_count: self.interaction_count,
            entropy: self.metrics.avg_delta_s,
            coherence: self.metrics.avg_delta_c,
            learning_score: self.metrics.avg_learning_magnitude,
            johari_quadrant: self.metrics.dominant_quadrant().name().to_string(),
            consolidation_phase: format!("{:?}", self.consolidation_phase),
            phase_angle: self.phase_angle,
            emotional_state: EmotionalStateResponse::default(),
            thresholds: ThresholdsResponse::from(&self.current_thresholds),
            suggested_action: None,
        }
    }
}

impl Default for UtlStatus {
    fn default() -> Self {
        Self {
            lifecycle_stage: LifecycleStage::default(),
            interaction_count: 0,
            current_thresholds: StageThresholds::default(),
            lambda_weights: LifecycleLambdaWeights::default(),
            phase_angle: 0.0,
            consolidation_phase: ConsolidationPhase::Encoding,
            metrics: UtlMetrics::default(),
        }
    }
}
```

---

## MCP Response Types

Types for MCP tool responses (compatible with utl_status tool).

```rust
/// MCP response format for utl_status tool
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UtlStatusResponse {
    pub lifecycle_phase: String,
    pub interaction_count: u64,
    pub entropy: f32,
    pub coherence: f32,
    pub learning_score: f32,
    pub johari_quadrant: String,
    pub consolidation_phase: String,
    pub phase_angle: f32,
    pub emotional_state: EmotionalStateResponse,
    pub thresholds: ThresholdsResponse,
    pub suggested_action: Option<String>,
}

/// Emotional state in MCP response format
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct EmotionalStateResponse {
    pub valence: f32,
    pub arousal: f32,
    pub weight: f32,
}

/// Thresholds in MCP response format
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct ThresholdsResponse {
    pub entropy_trigger: f32,
    pub coherence_trigger: f32,
    pub min_importance_store: f32,
    pub consolidation_threshold: f32,
}

impl From<&StageThresholds> for ThresholdsResponse {
    fn from(thresholds: &StageThresholds) -> Self {
        Self {
            entropy_trigger: thresholds.entropy_trigger,
            coherence_trigger: thresholds.coherence_trigger,
            min_importance_store: thresholds.min_importance_store,
            consolidation_threshold: thresholds.consolidation_threshold,
        }
    }
}
```

---

## Acceptance Criteria

- [ ] `UtlMetrics` struct with all 9 fields
- [ ] `QuadrantDistribution` with 4 counters
- [ ] `percentages()` returns array of 4 f32 summing to 1.0
- [ ] `UtlStatus` struct for complete status reporting
- [ ] `Default` impl for metrics initialization
- [ ] `Serde` Serialize/Deserialize implemented
- [ ] MCP response types implemented
- [ ] `dominant_quadrant()` correctly identifies most frequent
- [ ] `is_healthy()` checks latency bounds
- [ ] Unit tests for all functionality

---

## Test Cases

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_metrics_default() {
        let metrics = UtlMetrics::default();

        assert_eq!(metrics.computation_count, 0);
        assert_eq!(metrics.avg_learning_magnitude, 0.5);
        assert_eq!(metrics.quadrant_distribution.total(), 0);
    }

    #[test]
    fn test_quadrant_distribution_percentages_empty() {
        let dist = QuadrantDistribution::default();
        let pcts = dist.percentages();

        // Uniform when empty
        assert_eq!(pcts, [0.25, 0.25, 0.25, 0.25]);
    }

    #[test]
    fn test_quadrant_distribution_percentages() {
        let mut dist = QuadrantDistribution::default();
        dist.open = 50;
        dist.blind = 25;
        dist.hidden = 15;
        dist.unknown = 10;

        let pcts = dist.percentages();

        assert!((pcts[0] - 0.5).abs() < 0.01);   // open 50%
        assert!((pcts[1] - 0.25).abs() < 0.01);  // blind 25%
        assert!((pcts[2] - 0.15).abs() < 0.01);  // hidden 15%
        assert!((pcts[3] - 0.10).abs() < 0.01);  // unknown 10%
    }

    #[test]
    fn test_quadrant_distribution_dominant() {
        let mut dist = QuadrantDistribution::default();
        dist.open = 10;
        dist.blind = 50;  // Most frequent
        dist.hidden = 20;
        dist.unknown = 15;

        assert_eq!(dist.dominant(), JohariQuadrant::Blind);
    }

    #[test]
    fn test_quadrant_distribution_increment() {
        let mut dist = QuadrantDistribution::default();

        dist.increment(JohariQuadrant::Open);
        dist.increment(JohariQuadrant::Open);
        dist.increment(JohariQuadrant::Blind);

        assert_eq!(dist.open, 2);
        assert_eq!(dist.blind, 1);
        assert_eq!(dist.total(), 3);
    }

    #[test]
    fn test_metrics_is_healthy() {
        let mut metrics = UtlMetrics::default();
        metrics.avg_latency_us = 5000.0;  // 5ms
        metrics.p99_latency_us = 20000;   // 20ms

        assert!(metrics.is_healthy());

        // Unhealthy: high latency
        metrics.avg_latency_us = 15000.0;  // 15ms > 10ms threshold
        assert!(!metrics.is_healthy());
    }

    #[test]
    fn test_metrics_learning_efficiency() {
        let mut metrics = UtlMetrics::default();
        metrics.avg_learning_magnitude = 0.8;
        metrics.avg_latency_us = 5000.0;

        let efficiency = metrics.learning_efficiency();
        assert!(efficiency > 0.0);
    }

    #[test]
    fn test_status_summary() {
        let status = UtlStatus::default();
        let summary = status.summary();

        assert!(summary.contains("UTL:"));
        assert!(summary.contains("stage="));
        assert!(summary.contains("interactions="));
    }

    #[test]
    fn test_status_serialization() {
        let status = UtlStatus::default();

        let json = serde_json::to_string(&status).unwrap();
        let deserialized: UtlStatus = serde_json::from_str(&json).unwrap();

        assert_eq!(status.lifecycle_stage, deserialized.lifecycle_stage);
        assert_eq!(status.interaction_count, deserialized.interaction_count);
    }

    #[test]
    fn test_status_to_mcp_response() {
        let status = UtlStatus::default();
        let response = status.to_mcp_response();

        assert_eq!(response.lifecycle_phase, "Infancy");
        assert_eq!(response.interaction_count, 0);
    }

    #[test]
    fn test_thresholds_response_from() {
        use crate::lifecycle::StageThresholds;

        let thresholds = StageThresholds {
            entropy_trigger: 0.9,
            coherence_trigger: 0.2,
            min_importance_store: 0.1,
            consolidation_threshold: 0.3,
        };

        let response = ThresholdsResponse::from(&thresholds);

        assert_eq!(response.entropy_trigger, 0.9);
        assert_eq!(response.coherence_trigger, 0.2);
    }
}
```

---

## Verification Commands

```bash
# Run unit tests
cargo test -p context-graph-utl --lib -- metrics

# Check serialization
cargo test -p context-graph-utl --lib -- serialization

# Verify MCP response format
cargo test -p context-graph-utl tests::metrics_tests
```

---

## Related Tasks

| Task | Relationship |
|------|--------------|
| M05-T05 | LifecycleStage enum |
| M05-T06 | LifecycleLambdaWeights struct |
| M05-T08 | JohariQuadrant for distribution |
| M05-T17 | ConsolidationPhase for status |
| M05-T22 | UtlProcessor produces metrics |
| M05-T26 | utl_status MCP tool uses UtlStatusResponse |
| M05-T27 | get_memetic_status integration |
