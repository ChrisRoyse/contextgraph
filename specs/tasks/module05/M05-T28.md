# M05-T28: Implement CognitivePulse Header for MCP Responses

```yaml
metadata:
  id: "M05-T28"
  title: "Implement CognitivePulse Header for MCP Responses"
  module: "module-05"
  module_name: "UTL Integration"
  layer: "integration"
  priority: "high"
  estimated_hours: 3
  created: "2026-01-04"
  status: "pending"
  dependencies:
    - "M05-T22"
    - "M05-T18"
  spec_refs:
    - "SPEC-UTL-005 Section 10.3"
```

## Description

Implement CognitivePulse struct for inclusion in every MCP response:
- Fields: entropy (f32), coherence (f32), learning_score (f32), quadrant (JohariQuadrant), suggested_action (SuggestedAction)
- Create MCP middleware/interceptor to inject CognitivePulse into responses
- Document header format in MCP schema
- Performance impact must be < 1ms per response

## File Locations

| Type | Path |
|------|------|
| Implementation | `crates/context-graph-mcp/src/middleware/cognitive_pulse.rs` |
| Test File | `crates/context-graph-mcp/tests/cognitive_pulse_tests.rs` |

## Acceptance Criteria

- [ ] CognitivePulse struct with 5 fields
- [ ] Every MCP response includes CognitivePulse header
- [ ] Middleware correctly computes current UTL state
- [ ] Header format documented
- [ ] Performance impact < 1ms per response

## Technical Requirements

### CognitivePulse Struct

```rust
// crates/context-graph-mcp/src/middleware/cognitive_pulse.rs

use serde::{Deserialize, Serialize};
use context_graph_utl::{JohariQuadrant, SuggestedAction, UtlProcessor};

/// CognitivePulse provides real-time UTL state in every MCP response.
///
/// This lightweight structure is injected into all MCP responses to give
/// the LLM continuous visibility into the system's learning state.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CognitivePulse {
    /// Current entropy (surprise) level in [0, 1]
    /// High entropy indicates novel/surprising information
    pub entropy: f32,

    /// Current coherence level in [0, 1]
    /// High coherence indicates well-integrated knowledge
    pub coherence: f32,

    /// Current learning magnitude in [0, 1]
    /// Combines entropy, coherence, emotional weight, and phase
    pub learning_score: f32,

    /// Current Johari quadrant classification
    /// Informs retrieval strategy and verbosity
    pub quadrant: String,

    /// Suggested action based on current state
    /// Guides LLM behavior for optimal learning
    pub suggested_action: String,
}

impl CognitivePulse {
    /// Create a new CognitivePulse from UTL processor state
    pub fn from_processor(processor: &UtlProcessor) -> Self {
        let status = processor.get_status();

        Self {
            entropy: status.current_entropy,
            coherence: status.current_coherence,
            learning_score: status.learning_magnitude,
            quadrant: status.quadrant.name().to_string(),
            suggested_action: status.suggested_action.name().to_string(),
        }
    }

    /// Create a default pulse for when UTL is unavailable
    pub fn default_pulse() -> Self {
        Self {
            entropy: 0.0,
            coherence: 1.0,
            learning_score: 0.0,
            quadrant: "Open".to_string(),
            suggested_action: "DirectRecall".to_string(),
        }
    }

    /// Validate pulse values are within expected ranges
    pub fn validate(&self) -> bool {
        self.entropy >= 0.0 && self.entropy <= 1.0
            && self.coherence >= 0.0 && self.coherence <= 1.0
            && self.learning_score >= 0.0 && self.learning_score <= 1.0
    }
}

impl Default for CognitivePulse {
    fn default() -> Self {
        Self::default_pulse()
    }
}
```

### Middleware Implementation

```rust
use std::sync::Arc;
use std::time::Instant;
use async_trait::async_trait;
use tracing::{debug, warn};

/// Middleware that injects CognitivePulse into all MCP responses
pub struct CognitivePulseMiddleware {
    utl_processor: Option<Arc<UtlProcessor>>,
}

impl CognitivePulseMiddleware {
    pub fn new(utl_processor: Option<Arc<UtlProcessor>>) -> Self {
        Self { utl_processor }
    }

    /// Compute the current cognitive pulse
    /// Performance target: <1ms
    pub fn compute_pulse(&self) -> CognitivePulse {
        let start = Instant::now();

        let pulse = match &self.utl_processor {
            Some(processor) => CognitivePulse::from_processor(processor),
            None => CognitivePulse::default_pulse(),
        };

        let elapsed = start.elapsed();
        if elapsed.as_micros() > 1000 {
            warn!(
                "CognitivePulse computation exceeded 1ms: {:?}",
                elapsed
            );
        }
        debug!(
            "CognitivePulse computed in {:?}: entropy={}, coherence={}",
            elapsed, pulse.entropy, pulse.coherence
        );

        pulse
    }
}

#[async_trait]
impl McpMiddleware for CognitivePulseMiddleware {
    async fn process_response(
        &self,
        mut response: McpResponse,
    ) -> Result<McpResponse, McpError> {
        let pulse = self.compute_pulse();

        // Inject pulse into response metadata
        response.meta.cognitive_pulse = Some(pulse);

        Ok(response)
    }
}
```

### Response Wrapper

```rust
/// Extended MCP response with cognitive pulse
#[derive(Debug, Clone, Serialize)]
pub struct McpResponseWithPulse<T: Serialize> {
    /// Original tool result
    #[serde(flatten)]
    pub result: T,

    /// Cognitive pulse header (always present)
    #[serde(rename = "_cognitive_pulse")]
    pub cognitive_pulse: CognitivePulse,
}

impl<T: Serialize> McpResponseWithPulse<T> {
    pub fn new(result: T, pulse: CognitivePulse) -> Self {
        Self {
            result,
            cognitive_pulse: pulse,
        }
    }
}
```

### Server Integration

```rust
// In crates/context-graph-mcp/src/server.rs

impl McpServer {
    pub fn with_cognitive_pulse(mut self, utl_processor: Arc<UtlProcessor>) -> Self {
        let middleware = CognitivePulseMiddleware::new(Some(utl_processor));
        self.add_middleware(Box::new(middleware));
        self
    }
}
```

### Example Response with CognitivePulse

```json
{
  "content": [
    {
      "type": "text",
      "text": "Retrieved 5 relevant memories matching your query..."
    }
  ],
  "_cognitive_pulse": {
    "entropy": 0.42,
    "coherence": 0.78,
    "learning_score": 0.55,
    "quadrant": "Open",
    "suggested_action": "DirectRecall"
  }
}
```

### Performance Optimization

```rust
use std::cell::RefCell;
use std::time::{Duration, Instant};

thread_local! {
    /// Cached pulse to avoid redundant computation within same request
    static PULSE_CACHE: RefCell<Option<(Instant, CognitivePulse)>> = RefCell::new(None);
}

impl CognitivePulseMiddleware {
    /// Get pulse with caching (cache valid for 10ms within same thread)
    pub fn get_cached_pulse(&self) -> CognitivePulse {
        const CACHE_TTL: Duration = Duration::from_millis(10);

        PULSE_CACHE.with(|cache| {
            let mut cache = cache.borrow_mut();

            if let Some((timestamp, ref pulse)) = *cache {
                if timestamp.elapsed() < CACHE_TTL {
                    return pulse.clone();
                }
            }

            let pulse = self.compute_pulse();
            *cache = Some((Instant::now(), pulse.clone()));
            pulse
        })
    }
}
```

## Dependencies

### Required Tasks
- M05-T22: UtlProcessor Main Orchestrator
- M05-T18: JohariClassifier with Retrieval Strategies

### Required Crates
```toml
[dependencies]
serde = { version = "1.0", features = ["derive"] }
async-trait = "0.1"
tracing = "0.1"
```

## Test Cases

```rust
// crates/context-graph-mcp/tests/cognitive_pulse_tests.rs

#[test]
fn test_cognitive_pulse_validation() {
    let valid_pulse = CognitivePulse {
        entropy: 0.5,
        coherence: 0.7,
        learning_score: 0.6,
        quadrant: "Open".to_string(),
        suggested_action: "DirectRecall".to_string(),
    };
    assert!(valid_pulse.validate());

    let invalid_pulse = CognitivePulse {
        entropy: 1.5, // Out of range
        coherence: 0.7,
        learning_score: 0.6,
        quadrant: "Open".to_string(),
        suggested_action: "DirectRecall".to_string(),
    };
    assert!(!invalid_pulse.validate());
}

#[tokio::test]
async fn test_cognitive_pulse_in_response() {
    let server = create_test_mcp_server().await;

    let response = server.call_tool("inject_context", json!({
        "query": "test query"
    })).await.unwrap();

    // Verify cognitive pulse is present
    assert!(response.get("_cognitive_pulse").is_some());

    let pulse = response.get("_cognitive_pulse").unwrap();
    assert!(pulse.get("entropy").is_some());
    assert!(pulse.get("coherence").is_some());
    assert!(pulse.get("learning_score").is_some());
    assert!(pulse.get("quadrant").is_some());
    assert!(pulse.get("suggested_action").is_some());
}

#[tokio::test]
async fn test_cognitive_pulse_performance() {
    let processor = Arc::new(UtlProcessor::new(UtlConfig::default()));
    let middleware = CognitivePulseMiddleware::new(Some(processor));

    // Warm up
    for _ in 0..10 {
        middleware.compute_pulse();
    }

    // Measure
    let start = Instant::now();
    for _ in 0..1000 {
        middleware.compute_pulse();
    }
    let elapsed = start.elapsed();

    let avg_us = elapsed.as_micros() / 1000;
    assert!(
        avg_us < 1000,
        "Average pulse computation {}us exceeds 1ms target",
        avg_us
    );
}

#[test]
fn test_cognitive_pulse_serialization() {
    let pulse = CognitivePulse {
        entropy: 0.42,
        coherence: 0.78,
        learning_score: 0.55,
        quadrant: "Open".to_string(),
        suggested_action: "DirectRecall".to_string(),
    };

    let json = serde_json::to_string(&pulse).unwrap();
    assert!(json.contains("entropy"));
    assert!(json.contains("0.42"));

    let deserialized: CognitivePulse = serde_json::from_str(&json).unwrap();
    assert!((deserialized.entropy - 0.42).abs() < 0.001);
}

#[tokio::test]
async fn test_all_tools_include_pulse() {
    let server = create_test_mcp_server().await;

    // List of tools to verify
    let tools = vec![
        ("inject_context", json!({"query": "test"})),
        ("store_memory", json!({"content": "test"})),
        ("get_memetic_status", json!({})),
        ("utl_status", json!({})),
    ];

    for (tool_name, args) in tools {
        let response = server.call_tool(tool_name, args).await.unwrap();
        assert!(
            response.get("_cognitive_pulse").is_some(),
            "Tool {} missing cognitive pulse",
            tool_name
        );
    }
}
```

## Schema Documentation

```json
{
  "CognitivePulse": {
    "type": "object",
    "description": "Real-time UTL learning state included in all MCP responses",
    "properties": {
      "entropy": {
        "type": "number",
        "minimum": 0,
        "maximum": 1,
        "description": "Current entropy/surprise level. High = novel information."
      },
      "coherence": {
        "type": "number",
        "minimum": 0,
        "maximum": 1,
        "description": "Current coherence level. High = well-integrated knowledge."
      },
      "learning_score": {
        "type": "number",
        "minimum": 0,
        "maximum": 1,
        "description": "Learning magnitude combining entropy, coherence, emotion, and phase."
      },
      "quadrant": {
        "type": "string",
        "enum": ["Open", "Blind", "Hidden", "Unknown"],
        "description": "Johari quadrant classification determining retrieval strategy."
      },
      "suggested_action": {
        "type": "string",
        "enum": ["DirectRecall", "TriggerDream", "GetNeighborhood", "EpistemicAction", "CritiqueContext", "Curate"],
        "description": "Recommended action based on current state."
      }
    },
    "required": ["entropy", "coherence", "learning_score", "quadrant", "suggested_action"]
  }
}
```

## Verification

```bash
# Run tests
cargo test --package context-graph-mcp --test cognitive_pulse_tests

# Run performance benchmarks
cargo bench --package context-graph-mcp pulse_perf

# Verify all responses include pulse
cargo test --package context-graph-mcp all_tools_include_pulse
```

## Notes

- CognitivePulse is prefixed with underscore `_cognitive_pulse` to avoid collision with tool results
- Pulse computation is cached per-thread for 10ms to avoid redundant computation
- Performance warning logged if computation exceeds 1ms
- Default pulse returned when UTL processor is unavailable (graceful degradation)
