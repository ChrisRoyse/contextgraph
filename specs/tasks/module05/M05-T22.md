# M05-T22: Implement UtlProcessor Main Orchestrator

```yaml
task_id: M05-T22
title: "Implement UtlProcessor Main Orchestrator"
module: "Module 5: UTL Integration"
layer: "surface"
priority: "critical"
status: "pending"
estimated_hours: 4
created: "2026-01-04"

file_path: "crates/context-graph-utl/src/processor.rs"
test_file: "crates/context-graph-utl/tests/processor_tests.rs"

dependencies:
  - "M05-T11"  # SurpriseCalculator
  - "M05-T13"  # CoherenceTracker
  - "M05-T16"  # EmotionalWeightCalculator
  - "M05-T17"  # PhaseOscillator
  - "M05-T18"  # JohariClassifier
  - "M05-T19"  # LifecycleManager
  - "M05-T20"  # compute_learning_magnitude
  - "M05-T21"  # LearningSignal, UtlState

spec_refs:
  - "TECH-UTL-005 Section 7"
  - "SPEC-UTL-005 Section 9"
```

---

## Description

Implement `UtlProcessor` struct - the main orchestrator that integrates all UTL components (surprise, coherence, emotional, phase, Johari, lifecycle) into a unified computation pipeline.

---

## Architecture

```
                    ┌─────────────────────────────────────────────────────┐
                    │                   UtlProcessor                       │
                    │                                                      │
  ┌──────────┐      │   ┌────────────────┐     ┌─────────────────────┐   │
  │  Input   │──────│──▶│ SurpriseCalc   │────▶│      delta_s        │   │
  │(embedding│      │   └────────────────┘     └──────────┬──────────┘   │
  │ context) │      │                                     │              │
  └──────────┘      │   ┌────────────────┐     ┌──────────▼──────────┐   │
                    │   │ CoherenceTrack │────▶│      delta_c        │   │
                    │   └────────────────┘     └──────────┬──────────┘   │
                    │                                     │              │
  ┌──────────┐      │   ┌────────────────┐     ┌──────────▼──────────┐   │
  │  Input   │──────│──▶│ EmotionalCalc  │────▶│        w_e          │   │
  │ (content)│      │   └────────────────┘     └──────────┬──────────┘   │
  └──────────┘      │                                     │              │
                    │   ┌────────────────┐     ┌──────────▼──────────┐   │
                    │   │ PhaseOscillat  │────▶│        phi          │   │
                    │   └────────────────┘     └──────────┬──────────┘   │
                    │                                     │              │
                    │   ┌────────────────┐     ┌──────────▼──────────┐   │
                    │   │ LifecycleMgr   │────▶│   lambda_weights    │   │
                    │   └────────────────┘     └──────────┬──────────┘   │
                    │                                     │              │
                    │                          ┌──────────▼──────────┐   │
                    │                          │  compute_learning   │   │
                    │                          │     _magnitude      │   │
                    │                          └──────────┬──────────┘   │
                    │                                     │              │
                    │   ┌────────────────┐     ┌──────────▼──────────┐   │  ┌──────────┐
                    │   │ JohariClassify │────▶│   LearningSignal    │───│─▶│  Output  │
                    │   └────────────────┘     └─────────────────────┘   │  └──────────┘
                    │                                                      │
                    └─────────────────────────────────────────────────────┘
```

---

## UtlProcessor Struct

### Fields

| Field | Type | Description |
|-------|------|-------------|
| `surprise_calculator` | `SurpriseCalculator` | Computes delta_s |
| `coherence_tracker` | `CoherenceTracker` | Tracks delta_c |
| `emotional_calculator` | `EmotionalWeightCalculator` | Computes w_e |
| `phase_oscillator` | `PhaseOscillator` | Provides phi |
| `johari_classifier` | `JohariClassifier` | Classifies quadrant |
| `lifecycle_manager` | `LifecycleManager` | Manages lambda weights |
| `config` | `UtlConfig` | Configuration parameters |
| `metrics` | `Arc<Mutex<UtlMetrics>>` | Accumulated metrics |

### Implementation

```rust
use std::sync::{Arc, Mutex};
use std::time::Instant;
use chrono::Utc;

use crate::config::UtlConfig;
use crate::surprise::SurpriseCalculator;
use crate::coherence::{CoherenceTracker, CoherenceEntry};
use crate::emotional::EmotionalWeightCalculator;
use crate::phase::{PhaseOscillator, ConsolidationPhase};
use crate::johari::JohariClassifier;
use crate::lifecycle::LifecycleManager;
use crate::metrics::{UtlMetrics, UtlStatus};
use crate::{LearningSignal, UtlState, compute_learning_magnitude_weighted};
use crate::error::UtlError;

/// Main UTL computation orchestrator
pub struct UtlProcessor {
    /// Surprise calculator component
    surprise_calculator: SurpriseCalculator,

    /// Coherence tracker component
    coherence_tracker: CoherenceTracker,

    /// Emotional weight calculator
    emotional_calculator: EmotionalWeightCalculator,

    /// Phase oscillator
    phase_oscillator: PhaseOscillator,

    /// Johari quadrant classifier
    johari_classifier: JohariClassifier,

    /// Lifecycle state manager
    lifecycle_manager: LifecycleManager,

    /// Configuration
    config: UtlConfig,

    /// Accumulated metrics
    metrics: Arc<Mutex<UtlMetrics>>,
}

impl UtlProcessor {
    /// Create a new UtlProcessor with the given configuration
    pub fn new(config: UtlConfig) -> Self {
        Self {
            surprise_calculator: SurpriseCalculator::new(config.surprise.clone()),
            coherence_tracker: CoherenceTracker::new(config.coherence.clone(), None),
            emotional_calculator: EmotionalWeightCalculator::new(config.emotional.clone()),
            phase_oscillator: PhaseOscillator::new(config.phase.clone()),
            johari_classifier: JohariClassifier::new(config.johari.clone()),
            lifecycle_manager: LifecycleManager::new(config.lifecycle.clone()),
            config,
            metrics: Arc::new(Mutex::new(UtlMetrics::default())),
        }
    }

    /// Create with default configuration
    pub fn with_defaults() -> Self {
        Self::new(UtlConfig::default())
    }

    /// Compute full UTL learning signal
    ///
    /// # Arguments
    /// * `content` - Text content for emotional analysis
    /// * `embedding` - Vector embedding for surprise/coherence
    /// * `context_embeddings` - Recent context embeddings for comparison
    ///
    /// # Returns
    /// Complete `LearningSignal` with all computed values
    pub fn compute_learning(
        &mut self,
        content: &str,
        embedding: &[f32],
        context_embeddings: &[Vec<f32>],
    ) -> Result<LearningSignal, UtlError> {
        let start = Instant::now();

        // 1. Record interaction for lifecycle tracking
        self.lifecycle_manager.record_interaction();

        // 2. Compute surprise (delta_s)
        let delta_s = self.surprise_calculator.compute_surprise_ensemble(
            embedding,
            context_embeddings,
        );

        // 3. Compute coherence (delta_c)
        let delta_c = self.coherence_tracker.compute_coherence(
            embedding,
            content,
        );

        // 4. Compute emotional weight (w_e)
        let w_e = self.emotional_calculator.compute_weight(content);

        // 5. Get phase angle (phi)
        let phi = self.phase_oscillator.get_phi();
        let phase = self.phase_oscillator.get_phase();

        // 6. Get lambda weights from lifecycle
        let lambda_weights = self.lifecycle_manager.get_lambda_weights();

        // 7. Compute learning magnitude with Marblestone weights
        let magnitude = compute_learning_magnitude_weighted(
            delta_s,
            delta_c,
            w_e,
            phi,
            &lambda_weights,
        );

        // 8. Classify Johari quadrant
        let quadrant = self.johari_classifier.classify(delta_s, delta_c);
        let suggested_action = self.johari_classifier.suggested_action(quadrant);

        // 9. Determine consolidation and storage decisions
        let should_consolidate = self.should_consolidate(magnitude, phase);
        let should_store = self.lifecycle_manager.should_store(magnitude, magnitude);

        // Calculate latency
        let latency_us = start.elapsed().as_micros() as u64;

        // Create learning signal
        let signal = LearningSignal::new(
            magnitude,
            delta_s,
            delta_c,
            w_e,
            phi,
            Some(lambda_weights),
            quadrant,
            suggested_action,
            should_consolidate,
            should_store,
            latency_us,
        )?;

        // Update metrics asynchronously
        self.update_metrics(&signal);

        Ok(signal)
    }

    /// Determine if consolidation should occur
    fn should_consolidate(&self, magnitude: f32, phase: ConsolidationPhase) -> bool {
        magnitude > self.config.thresholds.consolidation_trigger
            && phase == ConsolidationPhase::Consolidation
    }

    /// Update accumulated metrics
    fn update_metrics(&self, signal: &LearningSignal) {
        if let Ok(mut metrics) = self.metrics.lock() {
            metrics.computation_count += 1;

            // Update running averages (exponential moving average)
            let alpha = 0.1;
            metrics.avg_learning_magnitude =
                alpha * signal.magnitude + (1.0 - alpha) * metrics.avg_learning_magnitude;
            metrics.avg_delta_s =
                alpha * signal.delta_s + (1.0 - alpha) * metrics.avg_delta_s;
            metrics.avg_delta_c =
                alpha * signal.delta_c + (1.0 - alpha) * metrics.avg_delta_c;

            // Update quadrant distribution
            match signal.quadrant {
                crate::johari::JohariQuadrant::Open => metrics.quadrant_distribution.open += 1,
                crate::johari::JohariQuadrant::Blind => metrics.quadrant_distribution.blind += 1,
                crate::johari::JohariQuadrant::Hidden => metrics.quadrant_distribution.hidden += 1,
                crate::johari::JohariQuadrant::Unknown => metrics.quadrant_distribution.unknown += 1,
            }

            // Update latency tracking
            metrics.avg_latency_us =
                alpha * signal.latency_us as f64 + (1.0 - alpha) * metrics.avg_latency_us;
            if signal.latency_us > metrics.p99_latency_us {
                metrics.p99_latency_us = signal.latency_us;
            }
        }
    }

    /// Get current UTL status
    pub fn get_status(&self) -> UtlStatus {
        let metrics = self.metrics.lock().map(|m| m.clone()).unwrap_or_default();

        UtlStatus {
            lifecycle_stage: self.lifecycle_manager.current_stage(),
            interaction_count: self.lifecycle_manager.interaction_count(),
            current_thresholds: self.lifecycle_manager.get_thresholds(),
            lambda_weights: self.lifecycle_manager.get_lambda_weights(),
            phase_angle: self.phase_oscillator.get_phi(),
            consolidation_phase: self.phase_oscillator.get_phase(),
            metrics,
        }
    }

    /// Update coherence window with a new entry
    pub fn update_coherence_window(&mut self, entry: CoherenceEntry) {
        self.coherence_tracker.update(entry);
    }

    /// Set phase modulation factor
    pub fn set_phase_modulation(&mut self, modulation: f32) {
        self.phase_oscillator.set_modulation(modulation);
    }

    /// Force consolidation phase
    pub fn trigger_consolidation(&mut self) {
        self.phase_oscillator.force_consolidation();
    }

    /// Reset phase to encoding
    pub fn reset_to_encoding(&mut self) {
        self.phase_oscillator.reset_to_encoding();
    }

    /// Get current lifecycle stage
    pub fn lifecycle_stage(&self) -> crate::lifecycle::LifecycleStage {
        self.lifecycle_manager.current_stage()
    }

    /// Get metrics snapshot
    pub fn metrics(&self) -> UtlMetrics {
        self.metrics.lock().map(|m| m.clone()).unwrap_or_default()
    }

    /// Restore lifecycle state (for persistence)
    pub fn restore_lifecycle(&mut self, interaction_count: u64) {
        self.lifecycle_manager.restore(interaction_count);
    }
}
```

---

## SessionContext Struct

Context for a single computation session.

```rust
use uuid::Uuid;
use chrono::{DateTime, Utc};

/// Context for UTL computation session
#[derive(Debug, Clone)]
pub struct SessionContext {
    /// Session identifier
    pub session_id: Uuid,

    /// Recent embeddings for context
    pub recent_embeddings: Vec<Vec<f32>>,

    /// Number of interactions in this session
    pub interaction_count: u64,

    /// Last activity timestamp
    pub last_activity: DateTime<Utc>,
}

impl SessionContext {
    /// Create a new session context
    pub fn new(session_id: Uuid) -> Self {
        Self {
            session_id,
            recent_embeddings: Vec::new(),
            interaction_count: 0,
            last_activity: Utc::now(),
        }
    }

    /// Create an empty session context with new ID
    pub fn new_empty() -> Self {
        Self::new(Uuid::new_v4())
    }

    /// Add an embedding to the context window
    pub fn add_embedding(&mut self, embedding: Vec<f32>, max_window: usize) {
        self.recent_embeddings.push(embedding);
        if self.recent_embeddings.len() > max_window {
            self.recent_embeddings.remove(0);
        }
        self.interaction_count += 1;
        self.last_activity = Utc::now();
    }

    /// Get context embeddings as slice
    pub fn context_embeddings(&self) -> Vec<Vec<f32>> {
        self.recent_embeddings.clone()
    }

    /// Check if session is stale
    pub fn is_stale(&self, max_age_seconds: i64) -> bool {
        let age = Utc::now() - self.last_activity;
        age.num_seconds() > max_age_seconds
    }

    /// Clear the context
    pub fn clear(&mut self) {
        self.recent_embeddings.clear();
        self.interaction_count = 0;
        self.last_activity = Utc::now();
    }
}

impl Default for SessionContext {
    fn default() -> Self {
        Self::new_empty()
    }
}
```

---

## Performance Requirements

| Metric | Target |
|--------|--------|
| Full compute_learning | < 10ms |
| Metrics update | < 100us |
| Status retrieval | < 1ms |

---

## Acceptance Criteria

- [ ] `UtlProcessor` orchestrates all 6 components
- [ ] `compute_learning()` executes full pipeline
- [ ] Records interaction for lifecycle tracking
- [ ] Applies Marblestone lambda weights
- [ ] Classifies Johari quadrant
- [ ] Determines consolidation and storage decisions
- [ ] Validates output for NaN/Infinity
- [ ] Updates metrics asynchronously
- [ ] Performance: < 10ms for full computation
- [ ] `get_status()` returns complete status
- [ ] `SessionContext` manages context window

---

## Test Cases

```rust
#[cfg(test)]
mod tests {
    use super::*;

    fn create_test_embedding(dim: usize, value: f32) -> Vec<f32> {
        vec![value; dim]
    }

    #[test]
    fn test_processor_creation() {
        let processor = UtlProcessor::with_defaults();
        assert_eq!(processor.lifecycle_stage(), LifecycleStage::Infancy);
    }

    #[test]
    fn test_compute_learning_basic() {
        let mut processor = UtlProcessor::with_defaults();

        let content = "This is a test message.";
        let embedding = create_test_embedding(1536, 0.1);
        let context: Vec<Vec<f32>> = vec![
            create_test_embedding(1536, 0.15),
            create_test_embedding(1536, 0.12),
        ];

        let signal = processor.compute_learning(content, &embedding, &context).unwrap();

        assert!(signal.magnitude >= 0.0 && signal.magnitude <= 1.0);
        assert!(signal.delta_s >= 0.0 && signal.delta_s <= 1.0);
        assert!(signal.delta_c >= 0.0 && signal.delta_c <= 1.0);
        assert!(signal.w_e >= 0.5 && signal.w_e <= 1.5);
        assert!(signal.phi >= 0.0 && signal.phi <= std::f32::consts::PI);
    }

    #[test]
    fn test_lifecycle_progression() {
        let mut processor = UtlProcessor::with_defaults();

        // Initial stage is Infancy
        assert_eq!(processor.lifecycle_stage(), LifecycleStage::Infancy);

        // Simulate 50 interactions to transition to Growth
        for _ in 0..50 {
            let _ = processor.compute_learning(
                "test",
                &create_test_embedding(1536, 0.1),
                &[],
            );
        }

        assert_eq!(processor.lifecycle_stage(), LifecycleStage::Growth);
    }

    #[test]
    fn test_metrics_update() {
        let mut processor = UtlProcessor::with_defaults();

        // Perform some computations
        for i in 0..10 {
            let _ = processor.compute_learning(
                &format!("message {}", i),
                &create_test_embedding(1536, 0.1 * i as f32),
                &[],
            );
        }

        let metrics = processor.metrics();
        assert_eq!(metrics.computation_count, 10);
        assert!(metrics.avg_learning_magnitude > 0.0);
    }

    #[test]
    fn test_status_retrieval() {
        let processor = UtlProcessor::with_defaults();
        let status = processor.get_status();

        assert_eq!(status.lifecycle_stage, LifecycleStage::Infancy);
        assert_eq!(status.interaction_count, 0);
    }

    #[test]
    fn test_performance() {
        use std::time::Instant;

        let mut processor = UtlProcessor::with_defaults();
        let content = "Test content for performance measurement.";
        let embedding = create_test_embedding(1536, 0.5);
        let context: Vec<Vec<f32>> = (0..50)
            .map(|i| create_test_embedding(1536, 0.1 * i as f32))
            .collect();

        let start = Instant::now();
        let _ = processor.compute_learning(content, &embedding, &context);
        let elapsed = start.elapsed();

        assert!(elapsed.as_millis() < 10, "Computation took too long: {:?}", elapsed);
    }

    #[test]
    fn test_session_context() {
        let mut ctx = SessionContext::new_empty();

        ctx.add_embedding(vec![1.0; 128], 50);
        ctx.add_embedding(vec![2.0; 128], 50);

        assert_eq!(ctx.interaction_count, 2);
        assert_eq!(ctx.recent_embeddings.len(), 2);
        assert!(!ctx.is_stale(300));
    }
}
```

---

## Verification Commands

```bash
# Run unit tests
cargo test -p context-graph-utl --lib -- processor

# Run integration tests
cargo test -p context-graph-utl tests::processor_tests

# Performance benchmark
cargo bench -p context-graph-utl -- utl_processor
```

---

## Related Tasks

| Task | Relationship |
|------|--------------|
| M05-T11 | SurpriseCalculator component |
| M05-T13 | CoherenceTracker component |
| M05-T16 | EmotionalWeightCalculator component |
| M05-T17 | PhaseOscillator component |
| M05-T18 | JohariClassifier component |
| M05-T19 | LifecycleManager component |
| M05-T20 | compute_learning_magnitude function |
| M05-T21 | LearningSignal output type |
| M05-T24 | UtlMetrics, UtlStatus for monitoring |
| M05-T25 | Integration tests and benchmarks |
| M05-T26 | MCP integration via utl_status tool |
