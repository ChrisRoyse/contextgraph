# M05-T23: Define UtlError Enum

```yaml
task_id: M05-T23
title: "Define UtlError Enum"
module: "Module 5: UTL Integration"
layer: "surface"
priority: "high"
status: "pending"
estimated_hours: 1
created: "2026-01-04"

file_path: "crates/context-graph-utl/src/error.rs"
test_file: "crates/context-graph-utl/tests/error_tests.rs"

dependencies: []

spec_refs:
  - "TECH-UTL-005 Section 11"
  - "SPEC-UTL-005 Section 9.1"
```

---

## Description

Implement comprehensive `UtlError` enum for all UTL-related error conditions. The error type uses `thiserror` for derivation and provides descriptive error messages for debugging and logging.

---

## UtlError Enum

### Variants

| Variant | Description | Fields |
|---------|-------------|--------|
| `InvalidComputation` | UTL computation produced invalid result | `delta_s`, `delta_c`, `w_e`, `phi`, `reason` |
| `InvalidLambdaWeights` | Lambda weights don't sum to 1.0 | `novelty`, `consolidation`, `reason` |
| `MissingContext` | Required context not available | (unit) |
| `DimensionMismatch` | Embedding dimensions don't match | `expected`, `actual` |
| `GraphError` | Error from knowledge graph operations | `String` |
| `ConfigError` | Configuration validation error | `String` |

---

## Implementation

```rust
use thiserror::Error;

/// Error type for UTL computation operations
#[derive(Error, Debug, Clone)]
pub enum UtlError {
    /// UTL computation produced an invalid result (NaN, Infinity, out of bounds)
    #[error("Invalid UTL computation: {reason} (delta_s={delta_s}, delta_c={delta_c}, w_e={w_e}, phi={phi})")]
    InvalidComputation {
        /// Surprise value at time of error
        delta_s: f32,
        /// Coherence value at time of error
        delta_c: f32,
        /// Emotional weight at time of error
        w_e: f32,
        /// Phase angle at time of error
        phi: f32,
        /// Human-readable reason for the error
        reason: String,
    },

    /// Lambda weights do not sum to 1.0 as required
    #[error("Invalid lambda weights: novelty={novelty}, consolidation={consolidation} - {reason}")]
    InvalidLambdaWeights {
        /// Novelty weight value
        novelty: f32,
        /// Consolidation weight value
        consolidation: f32,
        /// Human-readable reason for the error
        reason: String,
    },

    /// Required context embeddings are not available
    #[error("Missing context: no context embeddings available for computation")]
    MissingContext,

    /// Embedding dimension mismatch between expected and actual
    #[error("Dimension mismatch: expected {expected}, got {actual}")]
    DimensionMismatch {
        /// Expected dimension
        expected: usize,
        /// Actual dimension received
        actual: usize,
    },

    /// Error from knowledge graph operations
    #[error("Graph error: {0}")]
    GraphError(String),

    /// Configuration validation error
    #[error("Configuration error: {0}")]
    ConfigError(String),
}

impl UtlError {
    /// Create an InvalidComputation error for NaN detection
    pub fn nan_detected(delta_s: f32, delta_c: f32, w_e: f32, phi: f32, field: &str) -> Self {
        Self::InvalidComputation {
            delta_s,
            delta_c,
            w_e,
            phi,
            reason: format!("{} is NaN", field),
        }
    }

    /// Create an InvalidComputation error for Infinity detection
    pub fn infinity_detected(delta_s: f32, delta_c: f32, w_e: f32, phi: f32, field: &str) -> Self {
        Self::InvalidComputation {
            delta_s,
            delta_c,
            w_e,
            phi,
            reason: format!("{} is Infinity", field),
        }
    }

    /// Create an InvalidComputation error for out-of-bounds values
    pub fn out_of_bounds(
        delta_s: f32,
        delta_c: f32,
        w_e: f32,
        phi: f32,
        field: &str,
        value: f32,
        min: f32,
        max: f32,
    ) -> Self {
        Self::InvalidComputation {
            delta_s,
            delta_c,
            w_e,
            phi,
            reason: format!("{} value {} is out of bounds [{}, {}]", field, value, min, max),
        }
    }

    /// Create an InvalidLambdaWeights error for sum != 1.0
    pub fn weights_sum_invalid(novelty: f32, consolidation: f32) -> Self {
        Self::InvalidLambdaWeights {
            novelty,
            consolidation,
            reason: format!(
                "weights must sum to 1.0, got {} + {} = {}",
                novelty,
                consolidation,
                novelty + consolidation
            ),
        }
    }

    /// Create a dimension mismatch error
    pub fn dimension_mismatch(expected: usize, actual: usize) -> Self {
        Self::DimensionMismatch { expected, actual }
    }

    /// Create a graph error from a string
    pub fn graph_error<S: Into<String>>(message: S) -> Self {
        Self::GraphError(message.into())
    }

    /// Create a config error from a string
    pub fn config_error<S: Into<String>>(message: S) -> Self {
        Self::ConfigError(message.into())
    }

    /// Check if this is a recoverable error
    pub fn is_recoverable(&self) -> bool {
        match self {
            Self::MissingContext => true,  // Can proceed with defaults
            Self::DimensionMismatch { .. } => false,  // Need correct dimensions
            Self::InvalidComputation { .. } => false,  // Computation failed
            Self::InvalidLambdaWeights { .. } => false,  // Config error
            Self::GraphError(_) => true,  // Can proceed without graph
            Self::ConfigError(_) => false,  // Need valid config
        }
    }

    /// Get a short error code for logging/metrics
    pub fn error_code(&self) -> &'static str {
        match self {
            Self::InvalidComputation { .. } => "UTL_INVALID_COMP",
            Self::InvalidLambdaWeights { .. } => "UTL_INVALID_LAMBDA",
            Self::MissingContext => "UTL_MISSING_CTX",
            Self::DimensionMismatch { .. } => "UTL_DIM_MISMATCH",
            Self::GraphError(_) => "UTL_GRAPH_ERR",
            Self::ConfigError(_) => "UTL_CONFIG_ERR",
        }
    }
}

// Ensure UtlError is Send + Sync for async contexts
static_assertions::assert_impl_all!(UtlError: Send, Sync);

/// Result type alias for UTL operations
pub type UtlResult<T> = Result<T, UtlError>;
```

---

## Cargo.toml Dependencies

```toml
[dependencies]
thiserror = "1.0"
static_assertions = "1.1"
```

---

## Acceptance Criteria

- [ ] `UtlError` enum with 6 variants
- [ ] All variants have `#[error()]` messages
- [ ] `InvalidComputation` includes all component values
- [ ] Error is `Send + Sync` (static assertion)
- [ ] `thiserror` derivation works
- [ ] Helper constructors for common error cases
- [ ] `is_recoverable()` method for error handling
- [ ] `error_code()` for logging/metrics
- [ ] Unit tests for all variants

---

## Test Cases

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_invalid_computation_display() {
        let err = UtlError::InvalidComputation {
            delta_s: 0.5,
            delta_c: 0.7,
            w_e: 1.2,
            phi: 1.0,
            reason: "magnitude is NaN".to_string(),
        };

        let msg = format!("{}", err);
        assert!(msg.contains("Invalid UTL computation"));
        assert!(msg.contains("magnitude is NaN"));
        assert!(msg.contains("delta_s=0.5"));
    }

    #[test]
    fn test_nan_detected_helper() {
        let err = UtlError::nan_detected(0.5, 0.7, 1.2, 1.0, "learning_magnitude");

        match err {
            UtlError::InvalidComputation { reason, .. } => {
                assert!(reason.contains("NaN"));
                assert!(reason.contains("learning_magnitude"));
            }
            _ => panic!("Expected InvalidComputation"),
        }
    }

    #[test]
    fn test_invalid_lambda_weights() {
        let err = UtlError::weights_sum_invalid(0.6, 0.6);

        let msg = format!("{}", err);
        assert!(msg.contains("weights must sum to 1.0"));
        assert!(msg.contains("1.2")); // 0.6 + 0.6 = 1.2
    }

    #[test]
    fn test_dimension_mismatch() {
        let err = UtlError::dimension_mismatch(1536, 768);

        let msg = format!("{}", err);
        assert!(msg.contains("expected 1536"));
        assert!(msg.contains("got 768"));
    }

    #[test]
    fn test_missing_context() {
        let err = UtlError::MissingContext;

        let msg = format!("{}", err);
        assert!(msg.contains("Missing context"));
    }

    #[test]
    fn test_graph_error() {
        let err = UtlError::graph_error("connection failed");

        match err {
            UtlError::GraphError(msg) => {
                assert_eq!(msg, "connection failed");
            }
            _ => panic!("Expected GraphError"),
        }
    }

    #[test]
    fn test_config_error() {
        let err = UtlError::config_error("invalid threshold value");

        match err {
            UtlError::ConfigError(msg) => {
                assert_eq!(msg, "invalid threshold value");
            }
            _ => panic!("Expected ConfigError"),
        }
    }

    #[test]
    fn test_is_recoverable() {
        assert!(UtlError::MissingContext.is_recoverable());
        assert!(UtlError::graph_error("test").is_recoverable());

        assert!(!UtlError::dimension_mismatch(100, 50).is_recoverable());
        assert!(!UtlError::config_error("test").is_recoverable());
    }

    #[test]
    fn test_error_codes() {
        assert_eq!(UtlError::MissingContext.error_code(), "UTL_MISSING_CTX");
        assert_eq!(
            UtlError::dimension_mismatch(1, 2).error_code(),
            "UTL_DIM_MISMATCH"
        );
    }

    #[test]
    fn test_error_clone() {
        let err = UtlError::InvalidComputation {
            delta_s: 0.5,
            delta_c: 0.7,
            w_e: 1.2,
            phi: 1.0,
            reason: "test".to_string(),
        };

        let cloned = err.clone();
        assert_eq!(format!("{}", err), format!("{}", cloned));
    }

    #[test]
    fn test_out_of_bounds_helper() {
        let err = UtlError::out_of_bounds(0.5, 0.7, 1.2, 1.0, "w_e", 2.0, 0.5, 1.5);

        match err {
            UtlError::InvalidComputation { reason, .. } => {
                assert!(reason.contains("out of bounds"));
                assert!(reason.contains("w_e"));
                assert!(reason.contains("2"));
                assert!(reason.contains("[0.5, 1.5]"));
            }
            _ => panic!("Expected InvalidComputation"),
        }
    }
}
```

---

## Verification Commands

```bash
# Run unit tests
cargo test -p context-graph-utl --lib -- error

# Check that error is Send + Sync (compile-time check)
cargo check -p context-graph-utl

# Verify thiserror derivation
cargo test -p context-graph-utl tests::error_tests
```

---

## Usage Examples

### In LearningSignal Validation

```rust
impl LearningSignal {
    pub fn validate(&self) -> Result<(), UtlError> {
        if self.magnitude.is_nan() {
            return Err(UtlError::nan_detected(
                self.delta_s,
                self.delta_c,
                self.w_e,
                self.phi,
                "magnitude",
            ));
        }

        if self.magnitude.is_infinite() {
            return Err(UtlError::infinity_detected(
                self.delta_s,
                self.delta_c,
                self.w_e,
                self.phi,
                "magnitude",
            ));
        }

        Ok(())
    }
}
```

### In UtlProcessor

```rust
impl UtlProcessor {
    pub fn compute_learning(
        &mut self,
        content: &str,
        embedding: &[f32],
        context: &[Vec<f32>],
    ) -> UtlResult<LearningSignal> {
        // Dimension check
        if !context.is_empty() && context[0].len() != embedding.len() {
            return Err(UtlError::dimension_mismatch(
                embedding.len(),
                context[0].len(),
            ));
        }

        // ... computation ...

        signal.validate()?;
        Ok(signal)
    }
}
```

---

## Related Tasks

| Task | Relationship |
|------|--------------|
| M05-T21 | LearningSignal.validate() uses UtlError |
| M05-T22 | UtlProcessor returns UtlResult |
| M05-T06 | LifecycleLambdaWeights validation uses InvalidLambdaWeights |
| M05-T35 | Graph integration uses GraphError |
