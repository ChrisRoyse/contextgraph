# M05-T16: Implement EmotionalWeightCalculator

```yaml
metadata:
  id: "M05-T16"
  title: "Implement EmotionalWeightCalculator"
  module: "module-05"
  module_name: "UTL Integration"
  layer: "logic"
  priority: "critical"
  estimated_hours: 3
  created: "2026-01-04"
  status: "pending"
  dependencies:
    - "M05-T15"
  spec_refs:
    - "TECH-UTL-005 Section 9"
    - "SPEC-UTL-005 Section 5"
```

---

## Description

Implement EmotionalWeightCalculator struct for computing the emotional weight (w_e) component of the UTL learning equation.

The emotional weight modulates learning magnitude based on emotional content:
- **Lexicon-based sentiment analysis** extracts valence from text
- **Heuristic arousal detection** uses punctuation, capitalization, etc.
- **Exponential decay blending** smooths state transitions
- **Weight computation** maps emotional intensity to [0.5, 1.5] range

The weight formula ensures that emotionally charged content receives higher learning priority while neutral content remains at baseline weight.

---

## File Path

```
crates/context-graph-utl/src/emotional/calculator.rs
```

---

## Algorithm

### Weight Computation Formula

```
intensity = valence_weight * |valence| + arousal_weight * arousal
weight = baseline_weight + intensity * intensity_scale
weight_clamped = clamp(weight, weight_min, weight_max)
```

Where:
- `valence_weight = 0.6` (from EmotionalConfig)
- `arousal_weight = 0.4` (from EmotionalConfig)
- `baseline_weight = 1.0` (from EmotionalConfig)
- `intensity_scale = 0.5` (from EmotionalConfig)
- `weight_min = 0.5`, `weight_max = 1.5` (from EmotionalConfig)

### State Update with Decay

```
new_state.valence = decay_rate * old_valence + (1 - decay_rate) * extracted_valence
new_state.arousal = decay_rate * old_arousal + (1 - decay_rate) * extracted_arousal
```

---

## Struct Specification

```rust
use crate::config::EmotionalConfig;
use crate::emotional::EmotionalState;

/// Computes the emotional weight (w_e) for UTL learning magnitude.
///
/// The emotional weight modulates how strongly memories are encoded based
/// on their emotional content. High arousal and strong valence increase
/// the weight, leading to stronger memory formation.
///
/// # Weight Range
/// - Minimum: 0.5 (dampened for neutral content)
/// - Maximum: 1.5 (amplified for emotional content)
/// - Baseline: 1.0 (default for neutral state)
///
/// # Example
/// ```rust
/// use context_graph_utl::emotional::{EmotionalWeightCalculator, EmotionalConfig};
///
/// let config = EmotionalConfig::default();
/// let mut calculator = EmotionalWeightCalculator::new(config);
///
/// // Neutral text -> weight near 1.0
/// let neutral_weight = calculator.compute_weight("The meeting is at 3pm.");
/// assert!((neutral_weight - 1.0).abs() < 0.2);
///
/// // Excited text -> weight > 1.0
/// let excited_weight = calculator.compute_weight("This is AMAZING!!!");
/// assert!(excited_weight > 1.1);
/// ```
pub struct EmotionalWeightCalculator {
    /// Configuration parameters
    config: EmotionalConfig,

    /// Current emotional state (with decay)
    state: EmotionalState,
}

impl EmotionalWeightCalculator {
    /// Creates a new EmotionalWeightCalculator with the given configuration.
    pub fn new(config: EmotionalConfig) -> Self {
        Self {
            config,
            state: EmotionalState::default(),
        }
    }

    /// Computes the emotional weight for the given content.
    ///
    /// # Algorithm
    /// 1. Extract emotion from content (valence and arousal)
    /// 2. Update state with exponential decay blending
    /// 3. Convert state to weight in [0.5, 1.5]
    ///
    /// # Arguments
    /// * `content` - Text content to analyze
    ///
    /// # Returns
    /// Emotional weight in [0.5, 1.5] range
    ///
    /// # Performance
    /// Target: <1ms
    pub fn compute_weight(&mut self, content: &str) -> f32 {
        // Step 1: Extract emotion from content
        let extracted = self.extract_emotion(content);

        // Step 2: Update state with decay blending
        self.update_state(extracted);

        // Step 3: Compute weight from state
        self.state_to_weight()
    }

    /// Returns the current emotional state.
    pub fn get_state(&self) -> &EmotionalState {
        &self.state
    }

    /// Resets the emotional state to neutral.
    pub fn reset(&mut self) {
        self.state = EmotionalState::default();
    }

    /// Sets the emotional state directly (for testing/restoration).
    pub fn set_state(&mut self, state: EmotionalState) {
        self.state = state;
    }

    // -------------------------------------------------------------------------
    // Private Methods
    // -------------------------------------------------------------------------

    /// Extracts valence and arousal from text content.
    fn extract_emotion(&self, content: &str) -> EmotionalState {
        let valence = self.extract_valence(content);
        let arousal = self.extract_arousal(content);
        EmotionalState::new(valence, arousal)
    }

    /// Extracts valence using lexicon-based sentiment analysis.
    ///
    /// Scans content for positive/negative words and computes
    /// aggregate sentiment score.
    fn extract_valence(&self, content: &str) -> f32 {
        // Uses sentiment lexicon (M05-T31)
        // For now, simple heuristic implementation
        let lowercase = content.to_lowercase();
        let words: Vec<&str> = lowercase.split_whitespace().collect();

        if words.is_empty() {
            return 0.0;
        }

        let mut positive_score = 0.0;
        let mut negative_score = 0.0;
        let mut word_count = 0;

        // Simple built-in lexicon (expanded in M05-T31)
        let positive_words = [
            "good", "great", "excellent", "amazing", "wonderful", "fantastic",
            "happy", "love", "success", "perfect", "best", "beautiful",
            "awesome", "brilliant", "superb", "nice", "positive", "thanks",
        ];

        let negative_words = [
            "bad", "terrible", "awful", "horrible", "error", "failed",
            "problem", "wrong", "danger", "critical", "bug", "crash",
            "hate", "angry", "sad", "broken", "negative", "issue",
        ];

        for word in &words {
            let clean_word = word.trim_matches(|c: char| !c.is_alphanumeric());

            if positive_words.contains(&clean_word) {
                positive_score += 1.0;
                word_count += 1;
            } else if negative_words.contains(&clean_word) {
                negative_score += 1.0;
                word_count += 1;
            }
        }

        if word_count == 0 {
            return 0.0;
        }

        // Normalize to [-1, 1]
        let net_sentiment = (positive_score - negative_score) / word_count as f32;
        net_sentiment.clamp(-1.0, 1.0)
    }

    /// Extracts arousal using punctuation and capitalization heuristics.
    ///
    /// High arousal indicators:
    /// - Exclamation marks (!!!)
    /// - Question marks (???)
    /// - ALL CAPS words
    /// - Multiple punctuation
    fn extract_arousal(&self, content: &str) -> f32 {
        let total_chars = content.len() as f32;
        if total_chars == 0.0 {
            return 0.0;
        }

        let mut arousal = 0.0;

        // Exclamation marks contribute to arousal
        let exclamation_count = content.matches('!').count() as f32;
        arousal += (exclamation_count / total_chars) * self.config.exclamation_weight * 10.0;

        // Question marks contribute to arousal
        let question_count = content.matches('?').count() as f32;
        arousal += (question_count / total_chars) * self.config.question_weight * 10.0;

        // ALL CAPS words contribute to arousal
        let words: Vec<&str> = content.split_whitespace().collect();
        let caps_count = words
            .iter()
            .filter(|w| {
                let clean = w.trim_matches(|c: char| !c.is_alphanumeric());
                clean.len() >= 2 && clean.chars().all(|c| c.is_uppercase())
            })
            .count() as f32;

        if !words.is_empty() {
            arousal += (caps_count / words.len() as f32) * self.config.caps_weight * 3.0;
        }

        arousal.clamp(0.0, 1.0)
    }

    /// Updates the internal state with exponential decay blending.
    fn update_state(&mut self, extracted: EmotionalState) {
        let decay = self.config.decay_rate;

        let new_valence = decay * self.state.valence + (1.0 - decay) * extracted.valence;
        let new_arousal = decay * self.state.arousal + (1.0 - decay) * extracted.arousal;

        self.state = EmotionalState::new(new_valence, new_arousal);
    }

    /// Converts the current emotional state to a weight in [0.5, 1.5].
    fn state_to_weight(&self) -> f32 {
        // intensity = valence_weight * |valence| + arousal_weight * arousal
        let intensity = self.config.valence_weight * self.state.valence.abs()
            + self.config.arousal_weight * self.state.arousal;

        // weight = baseline + intensity * intensity_scale
        let weight = self.config.baseline_weight + intensity * self.config.intensity_scale;

        // Clamp to output range
        weight.clamp(self.config.weight_min, self.config.weight_max)
    }
}
```

---

## Acceptance Criteria

- [ ] EmotionalWeightCalculator struct has config (EmotionalConfig) and state (EmotionalState) fields
- [ ] compute_weight() returns w_e in [0.5, 1.5] range
- [ ] Lexicon sentiment analysis extracts valence from positive/negative words
- [ ] Punctuation/caps heuristics detect arousal (!, ?, ALL CAPS)
- [ ] Exponential decay blending smooths state transitions
- [ ] Performance: <1ms for compute_weight()
- [ ] get_state() returns current EmotionalState
- [ ] reset() returns to neutral state
- [ ] set_state() allows direct state manipulation (testing/restoration)

---

## Test File

```
crates/context-graph-utl/tests/emotional_tests.rs
```

### Test Cases

```rust
#[cfg(test)]
mod emotional_calculator_tests {
    use super::*;
    use std::time::Instant;

    #[test]
    fn test_neutral_content_baseline_weight() {
        let config = EmotionalConfig::default();
        let mut calculator = EmotionalWeightCalculator::new(config);

        let weight = calculator.compute_weight("The meeting is scheduled for 3pm.");
        // Neutral content should be near baseline (1.0)
        assert!((weight - 1.0).abs() < 0.2);
    }

    #[test]
    fn test_positive_content_higher_weight() {
        let config = EmotionalConfig::default();
        let mut calculator = EmotionalWeightCalculator::new(config);

        let weight = calculator.compute_weight("This is absolutely amazing and wonderful!");
        // Positive content with exclamation should have higher weight
        assert!(weight > 1.0);
    }

    #[test]
    fn test_negative_content_higher_weight() {
        let config = EmotionalConfig::default();
        let mut calculator = EmotionalWeightCalculator::new(config);

        let weight = calculator.compute_weight("This is a terrible error and a critical problem!");
        // Negative content with exclamation should have higher weight
        assert!(weight > 1.0);
    }

    #[test]
    fn test_caps_increases_arousal() {
        let config = EmotionalConfig::default();
        let mut calculator = EmotionalWeightCalculator::new(config);

        let normal = calculator.compute_weight("good news");
        calculator.reset();
        let caps = calculator.compute_weight("GOOD NEWS");

        // CAPS version should have higher weight due to arousal
        assert!(caps > normal);
    }

    #[test]
    fn test_exclamation_increases_arousal() {
        let config = EmotionalConfig::default();
        let mut calculator = EmotionalWeightCalculator::new(config);

        let normal = calculator.compute_weight("wow");
        calculator.reset();
        let excited = calculator.compute_weight("wow!!!");

        // Multiple exclamations should increase weight
        assert!(excited > normal);
    }

    #[test]
    fn test_weight_bounds() {
        let config = EmotionalConfig::default();
        let mut calculator = EmotionalWeightCalculator::new(config);

        // Test extreme positive
        let high = calculator.compute_weight("AMAZING!!! WONDERFUL!!! EXCELLENT!!! FANTASTIC!!!");
        assert!(high >= 0.5 && high <= 1.5);

        calculator.reset();

        // Test extreme negative
        let low = calculator.compute_weight("terrible awful horrible error failed crash bug");
        assert!(low >= 0.5 && low <= 1.5);
    }

    #[test]
    fn test_decay_blending() {
        let config = EmotionalConfig::default();
        let mut calculator = EmotionalWeightCalculator::new(config);

        // First: highly positive
        calculator.compute_weight("amazing wonderful excellent!!!");
        let state_after_positive = calculator.get_state().clone();

        // Second: neutral - state should decay but retain some positivity
        calculator.compute_weight("the meeting is at 3pm");
        let state_after_neutral = calculator.get_state().clone();

        // Valence should decay but not immediately go to zero
        assert!(state_after_neutral.valence < state_after_positive.valence);
        assert!(state_after_neutral.valence > 0.0);
    }

    #[test]
    fn test_performance_under_1ms() {
        let config = EmotionalConfig::default();
        let mut calculator = EmotionalWeightCalculator::new(config);
        let content = "This is a test sentence with some emotional content that is amazing and wonderful!";

        let start = Instant::now();
        for _ in 0..1000 {
            calculator.compute_weight(content);
        }
        let elapsed = start.elapsed();

        // Average should be under 1ms
        let avg_us = elapsed.as_micros() / 1000;
        assert!(avg_us < 1000, "Average took {}us, should be <1000us", avg_us);
    }

    #[test]
    fn test_empty_content() {
        let config = EmotionalConfig::default();
        let mut calculator = EmotionalWeightCalculator::new(config);

        let weight = calculator.compute_weight("");
        // Empty content should return baseline-ish weight
        assert!(weight >= 0.5 && weight <= 1.5);
    }

    #[test]
    fn test_get_state() {
        let config = EmotionalConfig::default();
        let mut calculator = EmotionalWeightCalculator::new(config);

        // Initially neutral
        let initial_state = calculator.get_state();
        assert!(initial_state.is_neutral());

        // After positive content
        calculator.compute_weight("amazing great wonderful");
        let updated_state = calculator.get_state();
        assert!(updated_state.valence > 0.0);
    }

    #[test]
    fn test_reset() {
        let config = EmotionalConfig::default();
        let mut calculator = EmotionalWeightCalculator::new(config);

        calculator.compute_weight("amazing!!!");
        assert!(!calculator.get_state().is_neutral());

        calculator.reset();
        assert!(calculator.get_state().is_neutral());
    }

    #[test]
    fn test_set_state() {
        let config = EmotionalConfig::default();
        let mut calculator = EmotionalWeightCalculator::new(config);

        let custom_state = EmotionalState::new(0.8, 0.9);
        calculator.set_state(custom_state.clone());

        assert_eq!(calculator.get_state().valence, 0.8);
        assert_eq!(calculator.get_state().arousal, 0.9);
    }
}
```

---

## Implementation Notes

1. **Lexicon Integration**: The simple lexicon in extract_valence() will be expanded in M05-T31
2. **Performance**: Use string iteration without heap allocation where possible
3. **Decay Rate**: Default 0.1 means 10% of old state retained, 90% new state
4. **Weight Range**: [0.5, 1.5] ensures emotional content varies importance by up to 50%
5. **Heuristics**: Punctuation weights from EmotionalConfig (exclamation_weight, question_weight, caps_weight)

---

## Dependencies

| Dependency | Purpose |
|------------|---------|
| M05-T15 | EmotionalState struct |
| M05-T04 | EmotionalConfig for parameters |
| M05-T31 | Extended sentiment lexicon (future) |

---

## Related Tasks

| Task ID | Relationship |
|---------|--------------|
| M05-T04 | Provides configuration parameters |
| M05-T15 | EmotionalState struct used internally |
| M05-T22 | Integrates w_e into UtlProcessor |
| M05-T31 | Expands sentiment lexicon |
