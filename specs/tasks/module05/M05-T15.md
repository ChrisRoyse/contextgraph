# M05-T15: Define EmotionalState Struct with Decay

```yaml
metadata:
  id: "M05-T15"
  title: "Define EmotionalState Struct with Decay"
  module: "module-05"
  module_name: "UTL Integration"
  layer: "logic"
  priority: "high"
  estimated_hours: 1
  created: "2026-01-04"
  status: "pending"
  dependencies:
    - "M05-T04"
  spec_refs:
    - "TECH-UTL-005 Section 9"
    - "SPEC-UTL-005 Section 5.2"
```

---

## Description

Implement EmotionalState struct for tracking valence/arousal in the UTL system.

The EmotionalState struct captures the current emotional context for memory processing:
- **Valence**: Measures positive (+1) to negative (-1) emotional tone
- **Arousal**: Measures calm (0) to excited (1) activation level
- **Timestamp**: Records when the emotional state was captured

This struct is foundational for the EmotionalWeightCalculator (M05-T16) which uses it to modulate learning magnitude based on emotional context.

---

## File Path

```
crates/context-graph-utl/src/emotional/calculator.rs
```

---

## Struct Specification

```rust
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};

/// Represents the current emotional state for UTL processing.
///
/// Emotional state influences learning magnitude through the w_e weight.
/// Higher arousal and stronger valence (positive or negative) increase
/// memory salience.
///
/// # Valence-Arousal Model
/// - Valence: positive (+1) to negative (-1) emotional tone
/// - Arousal: calm (0) to excited (1) activation level
///
/// # Example
/// ```rust
/// use context_graph_utl::emotional::EmotionalState;
///
/// // Neutral state (default)
/// let neutral = EmotionalState::default();
/// assert_eq!(neutral.valence, 0.0);
/// assert_eq!(neutral.arousal, 0.0);
///
/// // Excited positive state
/// let excited = EmotionalState::new(0.8, 0.9);
/// assert!(excited.valence > 0.5);
/// assert!(excited.arousal > 0.8);
/// ```
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct EmotionalState {
    /// Valence: positive (+1) to negative (-1) emotional tone.
    /// - +1.0: Extremely positive (joy, excitement)
    /// - 0.0: Neutral
    /// - -1.0: Extremely negative (anger, fear)
    pub valence: f32,

    /// Arousal: calm (0) to excited (1) activation level.
    /// - 1.0: High arousal (excited, alert)
    /// - 0.5: Moderate arousal
    /// - 0.0: Low arousal (calm, relaxed)
    pub arousal: f32,

    /// Timestamp when this emotional state was captured.
    pub timestamp: DateTime<Utc>,
}

impl EmotionalState {
    /// Creates a new EmotionalState with validation.
    ///
    /// # Arguments
    /// * `valence` - Emotional tone in [-1, 1], clamped if out of range
    /// * `arousal` - Activation level in [0, 1], clamped if out of range
    ///
    /// # Returns
    /// New EmotionalState with current timestamp
    pub fn new(valence: f32, arousal: f32) -> Self {
        Self {
            valence: valence.clamp(-1.0, 1.0),
            arousal: arousal.clamp(0.0, 1.0),
            timestamp: Utc::now(),
        }
    }

    /// Creates a neutral emotional state.
    pub fn neutral() -> Self {
        Self::default()
    }

    /// Checks if the state is effectively neutral.
    ///
    /// A state is neutral if valence is near zero and arousal is low.
    pub fn is_neutral(&self) -> bool {
        self.valence.abs() < 0.1 && self.arousal < 0.2
    }

    /// Computes the emotional intensity (magnitude regardless of valence direction).
    ///
    /// Intensity combines absolute valence and arousal:
    /// intensity = (|valence| + arousal) / 2
    pub fn intensity(&self) -> f32 {
        (self.valence.abs() + self.arousal) / 2.0
    }

    /// Creates EmotionalState with a specific timestamp (for testing/restoration).
    pub fn with_timestamp(valence: f32, arousal: f32, timestamp: DateTime<Utc>) -> Self {
        Self {
            valence: valence.clamp(-1.0, 1.0),
            arousal: arousal.clamp(0.0, 1.0),
            timestamp,
        }
    }
}

impl Default for EmotionalState {
    /// Default is neutral state: valence=0.0, arousal=0.0
    fn default() -> Self {
        Self {
            valence: 0.0,
            arousal: 0.0,
            timestamp: Utc::now(),
        }
    }
}

impl PartialEq for EmotionalState {
    fn eq(&self, other: &Self) -> bool {
        (self.valence - other.valence).abs() < f32::EPSILON
            && (self.arousal - other.arousal).abs() < f32::EPSILON
    }
}
```

---

## Acceptance Criteria

- [ ] EmotionalState struct has 3 fields: valence (f32), arousal (f32), timestamp (DateTime<Utc>)
- [ ] Default impl returns valence=0.0, arousal=0.0 (neutral state)
- [ ] Clone, Debug, Default traits implemented
- [ ] Serde Serialize/Deserialize implemented
- [ ] new() constructor clamps valence to [-1, 1] and arousal to [0, 1]
- [ ] is_neutral() correctly identifies neutral states
- [ ] intensity() correctly computes combined emotional magnitude
- [ ] with_timestamp() allows creating state with custom timestamp
- [ ] PartialEq compares valence and arousal within epsilon tolerance

---

## Test File

```
crates/context-graph-utl/tests/emotional_tests.rs
```

### Test Cases

```rust
#[cfg(test)]
mod emotional_state_tests {
    use super::*;
    use chrono::Utc;

    #[test]
    fn test_default_is_neutral() {
        let state = EmotionalState::default();
        assert_eq!(state.valence, 0.0);
        assert_eq!(state.arousal, 0.0);
        assert!(state.is_neutral());
    }

    #[test]
    fn test_new_clamps_valence() {
        let high = EmotionalState::new(1.5, 0.5);
        assert_eq!(high.valence, 1.0);

        let low = EmotionalState::new(-1.5, 0.5);
        assert_eq!(low.valence, -1.0);
    }

    #[test]
    fn test_new_clamps_arousal() {
        let high = EmotionalState::new(0.0, 1.5);
        assert_eq!(high.arousal, 1.0);

        let low = EmotionalState::new(0.0, -0.5);
        assert_eq!(low.arousal, 0.0);
    }

    #[test]
    fn test_intensity_calculation() {
        // Neutral: intensity = 0
        let neutral = EmotionalState::default();
        assert_eq!(neutral.intensity(), 0.0);

        // Positive excited: intensity = (0.8 + 0.9) / 2 = 0.85
        let excited = EmotionalState::new(0.8, 0.9);
        assert!((excited.intensity() - 0.85).abs() < 0.01);

        // Negative high arousal: intensity = (0.6 + 0.8) / 2 = 0.7
        let angry = EmotionalState::new(-0.6, 0.8);
        assert!((angry.intensity() - 0.7).abs() < 0.01);
    }

    #[test]
    fn test_is_neutral() {
        // Clearly neutral
        let neutral = EmotionalState::new(0.0, 0.1);
        assert!(neutral.is_neutral());

        // Slightly positive but low arousal - still neutral
        let mild = EmotionalState::new(0.05, 0.15);
        assert!(mild.is_neutral());

        // Not neutral - positive valence
        let happy = EmotionalState::new(0.5, 0.3);
        assert!(!happy.is_neutral());

        // Not neutral - high arousal
        let aroused = EmotionalState::new(0.0, 0.5);
        assert!(!aroused.is_neutral());
    }

    #[test]
    fn test_serde_serialization() {
        let state = EmotionalState::new(0.5, 0.7);
        let json = serde_json::to_string(&state).unwrap();
        let deserialized: EmotionalState = serde_json::from_str(&json).unwrap();
        assert_eq!(state, deserialized);
    }

    #[test]
    fn test_with_timestamp() {
        let ts = Utc::now();
        let state = EmotionalState::with_timestamp(0.3, 0.4, ts);
        assert_eq!(state.timestamp, ts);
        assert_eq!(state.valence, 0.3);
        assert_eq!(state.arousal, 0.4);
    }

    #[test]
    fn test_clone() {
        let original = EmotionalState::new(0.5, 0.5);
        let cloned = original.clone();
        assert_eq!(original, cloned);
    }
}
```

---

## Implementation Notes

1. **Valence-Arousal Model**: Based on Russell's circumplex model of affect
2. **Clamping**: All inputs are clamped to valid ranges to prevent invalid states
3. **Timestamp**: Uses chrono::DateTime<Utc> for timezone-aware timestamps
4. **Epsilon Comparison**: PartialEq uses epsilon for floating-point comparison
5. **Integration**: This struct is used by EmotionalWeightCalculator (M05-T16)

---

## Dependencies

| Dependency | Purpose |
|------------|---------|
| M05-T04 | EmotionalConfig for configuration parameters |
| chrono | DateTime handling |
| serde | Serialization/deserialization |

---

## Related Tasks

| Task ID | Relationship |
|---------|--------------|
| M05-T04 | Provides EmotionalConfig used by calculator |
| M05-T16 | Uses EmotionalState in EmotionalWeightCalculator |
| M05-T22 | Integrates emotional weight into UtlProcessor |
