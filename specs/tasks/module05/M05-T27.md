# M05-T27: Integrate UTL Metrics into get_memetic_status

```yaml
metadata:
  id: "M05-T27"
  title: "Integrate UTL Metrics into get_memetic_status"
  module: "module-05"
  module_name: "UTL Integration"
  layer: "integration"
  priority: "high"
  estimated_hours: 2
  created: "2026-01-04"
  status: "pending"
  dependencies:
    - "M05-T24"
    - "M05-T26"
  spec_refs:
    - "SPEC-UTL-005 Section 10.2"
```

## Description

Extend existing get_memetic_status MCP tool with UTL metrics:
- Add UTLMetrics field to MemeticStatusResponse
- UTLMetrics struct: entropy, coherence, learning_score, johari_quadrant, phase
- Ensure backward compatibility with existing response fields
- Update MCP schema documentation

## File Locations

| Type | Path |
|------|------|
| Implementation | `crates/context-graph-mcp/src/tools/memetic_status.rs` |
| Test File | `crates/context-graph-mcp/tests/memetic_status_tests.rs` |

## Acceptance Criteria

- [ ] MemeticStatusResponse includes utl_metrics field
- [ ] UTLMetrics has all 5 required fields
- [ ] Existing get_memetic_status functionality unchanged
- [ ] Backward compatible with old response format

## Technical Requirements

### UTLMetrics Struct

```rust
// crates/context-graph-mcp/src/tools/memetic_status.rs

use serde::Serialize;

/// UTL metrics subset for inclusion in memetic status
#[derive(Debug, Clone, Serialize)]
pub struct UTLMetrics {
    /// Current entropy (surprise) in [0, 1]
    pub entropy: f32,

    /// Current coherence in [0, 1]
    pub coherence: f32,

    /// Learning score/magnitude in [0, 1]
    pub learning_score: f32,

    /// Current Johari quadrant classification
    pub johari_quadrant: String,

    /// Current consolidation phase
    pub phase: String,
}

impl Default for UTLMetrics {
    fn default() -> Self {
        Self {
            entropy: 0.0,
            coherence: 1.0,
            learning_score: 0.0,
            johari_quadrant: "Open".to_string(),
            phase: "Encoding".to_string(),
        }
    }
}
```

### Extended MemeticStatusResponse

```rust
/// Existing memetic status response with UTL extension
#[derive(Debug, Clone, Serialize)]
pub struct MemeticStatusResponse {
    // ============================================
    // EXISTING FIELDS (backward compatible)
    // ============================================

    /// Total node count in the graph
    pub node_count: u64,

    /// Total edge count in the graph
    pub edge_count: u64,

    /// Graph density (edges / possible_edges)
    pub graph_density: f64,

    /// Average node importance
    pub avg_importance: f32,

    /// Memory usage statistics
    pub memory_stats: MemoryStats,

    /// Session statistics
    pub session_stats: SessionStats,

    /// Index statistics
    pub index_stats: IndexStats,

    // ============================================
    // NEW UTL FIELDS (optional for backward compat)
    // ============================================

    /// UTL metrics (new in v1.3.0)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub utl_metrics: Option<UTLMetrics>,
}

impl MemeticStatusResponse {
    /// Add UTL metrics to the response
    pub fn with_utl_metrics(mut self, metrics: UTLMetrics) -> Self {
        self.utl_metrics = Some(metrics);
        self
    }
}
```

### Tool Handler Update

```rust
use context_graph_utl::UtlProcessor;

#[async_trait]
impl McpTool for MemeticStatusTool {
    fn name(&self) -> &'static str {
        "get_memetic_status"
    }

    fn description(&self) -> &'static str {
        "Get comprehensive status of the memetic/knowledge graph including \
         node/edge counts, memory stats, and UTL learning metrics."
    }

    async fn execute(
        &self,
        _input: serde_json::Value,
        context: &McpToolContext,
    ) -> McpToolResult<serde_json::Value> {
        // Get existing memetic status
        let graph = context.get_knowledge_graph()?;
        let session_manager = context.get_session_manager()?;

        let mut response = MemeticStatusResponse {
            node_count: graph.node_count(),
            edge_count: graph.edge_count(),
            graph_density: graph.density(),
            avg_importance: graph.average_importance(),
            memory_stats: graph.memory_stats(),
            session_stats: session_manager.stats(),
            index_stats: graph.index_stats(),
            utl_metrics: None,
        };

        // Add UTL metrics if UTL processor is available
        if let Ok(utl_processor) = context.get_utl_processor() {
            let utl_status = utl_processor.get_status();

            let utl_metrics = UTLMetrics {
                entropy: utl_status.current_entropy,
                coherence: utl_status.current_coherence,
                learning_score: utl_status.learning_magnitude,
                johari_quadrant: utl_status.quadrant.name().to_string(),
                phase: utl_status.consolidation_phase.name().to_string(),
            };

            response = response.with_utl_metrics(utl_metrics);
        }

        Ok(serde_json::to_value(response)?)
    }
}
```

### Example Response (with UTL)

```json
{
  "node_count": 15423,
  "edge_count": 87654,
  "graph_density": 0.00037,
  "avg_importance": 0.42,
  "memory_stats": {
    "used_bytes": 1073741824,
    "peak_bytes": 1610612736,
    "rocksdb_size_bytes": 536870912
  },
  "session_stats": {
    "active_sessions": 3,
    "total_interactions": 4521
  },
  "index_stats": {
    "hnsw_node_count": 15423,
    "hnsw_layers": 4
  },
  "utl_metrics": {
    "entropy": 0.45,
    "coherence": 0.78,
    "learning_score": 0.52,
    "johari_quadrant": "Open",
    "phase": "Encoding"
  }
}
```

### Example Response (without UTL - backward compatible)

```json
{
  "node_count": 15423,
  "edge_count": 87654,
  "graph_density": 0.00037,
  "avg_importance": 0.42,
  "memory_stats": {
    "used_bytes": 1073741824,
    "peak_bytes": 1610612736,
    "rocksdb_size_bytes": 536870912
  },
  "session_stats": {
    "active_sessions": 3,
    "total_interactions": 4521
  },
  "index_stats": {
    "hnsw_node_count": 15423,
    "hnsw_layers": 4
  }
}
```

## Dependencies

### Required Tasks
- M05-T24: UtlMetrics and UtlStatus Structs
- M05-T26: utl_status MCP Tool

### Required Crates
```toml
[dependencies]
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
```

## Test Cases

```rust
// crates/context-graph-mcp/tests/memetic_status_tests.rs

#[tokio::test]
async fn test_memetic_status_includes_utl_metrics() {
    let server = create_test_mcp_server().await;

    let response = server.call_tool("get_memetic_status", json!({})).await.unwrap();

    // Verify UTL metrics field exists when UTL is enabled
    assert!(response.get("utl_metrics").is_some());

    let utl = response.get("utl_metrics").unwrap();
    assert!(utl.get("entropy").is_some());
    assert!(utl.get("coherence").is_some());
    assert!(utl.get("learning_score").is_some());
    assert!(utl.get("johari_quadrant").is_some());
    assert!(utl.get("phase").is_some());
}

#[tokio::test]
async fn test_memetic_status_backward_compatibility() {
    let server = create_test_mcp_server().await;

    let response = server.call_tool("get_memetic_status", json!({})).await.unwrap();

    // Verify all existing fields still present
    assert!(response.get("node_count").is_some());
    assert!(response.get("edge_count").is_some());
    assert!(response.get("graph_density").is_some());
    assert!(response.get("avg_importance").is_some());
    assert!(response.get("memory_stats").is_some());
    assert!(response.get("session_stats").is_some());
    assert!(response.get("index_stats").is_some());
}

#[tokio::test]
async fn test_utl_metrics_value_ranges() {
    let server = create_test_mcp_server().await;

    let response = server.call_tool("get_memetic_status", json!({})).await.unwrap();
    let utl = response.get("utl_metrics").unwrap();

    let entropy = utl["entropy"].as_f64().unwrap() as f32;
    let coherence = utl["coherence"].as_f64().unwrap() as f32;
    let learning_score = utl["learning_score"].as_f64().unwrap() as f32;

    assert!(entropy >= 0.0 && entropy <= 1.0, "entropy out of range: {}", entropy);
    assert!(coherence >= 0.0 && coherence <= 1.0, "coherence out of range: {}", coherence);
    assert!(learning_score >= 0.0 && learning_score <= 1.0, "learning_score out of range: {}", learning_score);
}

#[tokio::test]
async fn test_memetic_status_without_utl_processor() {
    // Create server without UTL processor initialized
    let server = create_test_mcp_server_no_utl().await;

    let response = server.call_tool("get_memetic_status", json!({})).await.unwrap();

    // Should still work, just without utl_metrics
    assert!(response.get("node_count").is_some());

    // utl_metrics should be absent (not null)
    assert!(response.get("utl_metrics").is_none());
}
```

## Schema Documentation Update

```json
{
  "name": "get_memetic_status",
  "description": "Get comprehensive status of the memetic/knowledge graph including node/edge counts, memory stats, and UTL learning metrics.",
  "inputSchema": {
    "type": "object",
    "properties": {},
    "required": []
  },
  "outputSchema": {
    "type": "object",
    "properties": {
      "node_count": { "type": "integer" },
      "edge_count": { "type": "integer" },
      "graph_density": { "type": "number" },
      "avg_importance": { "type": "number" },
      "memory_stats": { "type": "object" },
      "session_stats": { "type": "object" },
      "index_stats": { "type": "object" },
      "utl_metrics": {
        "type": "object",
        "description": "UTL learning metrics (optional, present when UTL is enabled)",
        "properties": {
          "entropy": { "type": "number", "minimum": 0, "maximum": 1 },
          "coherence": { "type": "number", "minimum": 0, "maximum": 1 },
          "learning_score": { "type": "number", "minimum": 0, "maximum": 1 },
          "johari_quadrant": { "type": "string", "enum": ["Open", "Blind", "Hidden", "Unknown"] },
          "phase": { "type": "string", "enum": ["Encoding", "Transition", "Consolidation"] }
        }
      }
    },
    "required": ["node_count", "edge_count", "graph_density", "avg_importance", "memory_stats", "session_stats", "index_stats"]
  }
}
```

## Verification

```bash
# Run tests
cargo test --package context-graph-mcp --test memetic_status_tests

# Verify backward compatibility
cargo test --package context-graph-mcp backward_compat

# Test MCP tool manually
echo '{"jsonrpc":"2.0","method":"tools/call","params":{"name":"get_memetic_status","arguments":{}},"id":1}' | cargo run --package context-graph-mcp
```

## Notes

- UTL metrics field is optional to maintain backward compatibility
- Use `#[serde(skip_serializing_if = "Option::is_none")]` to omit field when empty
- UTL processor unavailability should not break existing functionality
- Document schema changes in MCP API documentation
