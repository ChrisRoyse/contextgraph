# Task Specification: M03-L37

```xml
<task_spec id="M03-L37" version="1.0">
<metadata>
  <title>L1 Unicode Sanitization &amp; NFC Normalization</title>
  <status>ready</status>
  <layer>logic</layer>
  <sequence>75</sequence>
  <implements>
    - Pre-PII input validation layer
    - Constitution: security.SEC-01 (validate/sanitize all input)
    - PRD: L1_Sensing layer input preprocessing
  </implements>
  <depends_on>
    - M03-F06 (ModelInput)
    - M03-F08 (EmbeddingError)
  </depends_on>
  <estimated_hours>3</estimated_hours>
</metadata>

<context>
Implement an input sanitization layer that runs BEFORE PII scrubbing (M03-L25).
GPU kernels (especially custom ones like HDC) are extremely sensitive to malformed
Unicode, null bytes, or control characters.

**The Problem:**
M03-L25 handles PII detection and removal, but it assumes well-formed UTF-8 input.
If a user sends a string with:
- Byte Order Mark (BOM)
- Invalid UTF-8 sequences
- Null bytes (\0)
- Control characters (U+0000-U+001F)
- Overlong encodings
- Surrogate pairs

The PII scrubber may pass it through, but the GPU kernel hits an invalid memory
address or produces NaNs that propagate through FuseMoE.

**Key Responsibilities:**
1. UTF-8 validation with lossy recovery
2. NFC normalization (Canonical Decomposition, followed by Canonical Composition)
3. Control character stripping
4. Empty/whitespace-only detection
5. BOM removal
6. Maximum length enforcement
7. Null byte rejection

**Layer Position:**
```
User Input → [M03-L37: Sanitize] → [M03-L25: PII Scrub] → Tokenizer → Models
```

**Performance Target:**
- Sanitization latency: <500μs for typical input (<4KB)
- Throughput: >10,000 inputs/second
</context>

<definition_of_done>
  <signatures>
```rust
/// Sanitization result
#[derive(Debug, Clone)]
pub struct SanitizationResult {
    pub sanitized: String,
    pub original_len: usize,
    pub sanitized_len: usize,
    pub was_normalized: bool,
    pub characters_removed: usize,
    pub replacements_made: usize,
    pub issues: Vec<SanitizationIssue>,
}

/// Issues detected during sanitization
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum SanitizationIssue {
    InvalidUtf8 { byte_position: usize },
    BomRemoved,
    NullBytesRemoved { count: usize },
    ControlCharsRemoved { count: usize },
    OverlongEncoding { byte_position: usize },
    SurrogatePair { byte_position: usize },
    NfcNormalized,
    TruncatedToMaxLength { original_len: usize, max_len: usize },
    WhitespaceOnly,
    Empty,
}

/// Sanitization configuration
#[derive(Debug, Clone)]
pub struct SanitizerConfig {
    /// Maximum input length (bytes)
    pub max_length: usize,
    /// Remove control characters (U+0000-U+001F except \n, \r, \t)
    pub strip_control_chars: bool,
    /// Apply NFC normalization
    pub normalize_nfc: bool,
    /// Remove BOM
    pub strip_bom: bool,
    /// Replace invalid UTF-8 with replacement character
    pub lossy_utf8: bool,
    /// Reject null bytes entirely (vs stripping)
    pub reject_null_bytes: bool,
    /// Minimum content length after sanitization
    pub min_content_length: usize,
}

impl Default for SanitizerConfig {
    fn default() -> Self {
        Self {
            max_length: 65536,         // PRD: content:str[≤65536]
            strip_control_chars: true,
            normalize_nfc: true,
            strip_bom: true,
            lossy_utf8: true,
            reject_null_bytes: true,
            min_content_length: 1,
        }
    }
}

pub struct InputSanitizer {
    config: SanitizerConfig,
}

impl InputSanitizer {
    /// Create sanitizer with configuration
    pub fn new(config: SanitizerConfig) -> Self;

    /// Create sanitizer with default configuration
    pub fn default() -> Self;

    /// Sanitize input string, returning result with diagnostics
    pub fn sanitize(&self, input: &str) -> SanitizationResult;

    /// Sanitize input bytes (may not be valid UTF-8)
    pub fn sanitize_bytes(&self, input: &[u8]) -> EmbeddingResult<SanitizationResult>;

    /// Quick validation without full sanitization
    pub fn validate(&self, input: &str) -> Result<(), Vec<SanitizationIssue>>;

    /// Check if input requires sanitization
    pub fn needs_sanitization(&self, input: &str) -> bool;

    /// Sanitize for specific model type (some models have stricter requirements)
    pub fn sanitize_for_model(&self, input: &str, model_id: ModelId) -> SanitizationResult;
}

/// Extension trait for ModelInput
impl ModelInput {
    /// Apply sanitization to text content
    pub fn sanitized(self, sanitizer: &InputSanitizer) -> EmbeddingResult<Self>;
}

/// Pre-processing stage for EmbeddingPipeline
pub struct PreProcessor {
    sanitizer: InputSanitizer,
    pii_scrubber: PiiScrubber, // M03-L25
}

impl PreProcessor {
    /// Full pre-processing: sanitize → PII scrub
    pub fn process(&self, input: &str) -> EmbeddingResult<ProcessedInput>;
}

/// Result of full pre-processing
#[derive(Debug, Clone)]
pub struct ProcessedInput {
    pub text: String,
    pub sanitization_result: SanitizationResult,
    pub pii_result: PiiScrubResult,
}
```
  </signatures>

  <constraints>
    - UTF-8 validation using std::str::from_utf8 with lossy fallback
    - NFC normalization using unicode-normalization crate
    - Control character detection via Unicode category Cc
    - BOM detection: EF BB BF (UTF-8), FE FF / FF FE (UTF-16)
    - Preserve newlines (\n), carriage returns (\r), and tabs (\t)
    - Thread-safe (stateless sanitization)
    - No allocations for already-clean input (fast path)
    - Latency budget: <500μs for 4KB input
    - Must integrate with PII scrubber (M03-L25) pipeline
  </constraints>

  <verification>
    <step>Invalid UTF-8 bytes are replaced with U+FFFD</step>
    <step>BOM is stripped from start of input</step>
    <step>Null bytes cause rejection (with reject_null_bytes=true)</step>
    <step>Control characters are stripped (except \n, \r, \t)</step>
    <step>NFC normalization is applied correctly</step>
    <step>Long inputs are truncated to max_length</step>
    <step>Empty/whitespace-only inputs are flagged</step>
    <step>Clean inputs pass through with minimal overhead</step>
    <step>Sanitization issues are accurately reported</step>
  </verification>
</definition_of_done>

<files_to_create>
  <file>crates/context-graph-embeddings/src/preprocess/mod.rs</file>
  <file>crates/context-graph-embeddings/src/preprocess/sanitizer.rs</file>
  <file>crates/context-graph-embeddings/src/preprocess/unicode.rs</file>
</files_to_create>

<validation_criteria>
  <criterion>cargo check passes</criterion>
  <criterion>cargo test preprocess passes</criterion>
  <criterion>Fuzz testing with arbitrary bytes doesn't panic</criterion>
  <criterion>Known malformed inputs are correctly sanitized</criterion>
  <criterion>Performance: >10K ops/sec on 4KB inputs</criterion>
  <criterion>Zero-copy fast path for clean inputs</criterion>
</validation_criteria>
</task_spec>
```

## Implementation Notes

### Core Sanitization Logic

```rust
use unicode_normalization::UnicodeNormalization;

impl InputSanitizer {
    pub fn sanitize(&self, input: &str) -> SanitizationResult {
        let original_len = input.len();
        let mut issues = Vec::new();
        let mut chars_removed = 0;
        let mut replacements = 0;

        // Fast path: check if sanitization needed
        if !self.needs_sanitization(input) {
            return SanitizationResult {
                sanitized: input.to_string(),
                original_len,
                sanitized_len: input.len(),
                was_normalized: false,
                characters_removed: 0,
                replacements_made: 0,
                issues: vec![],
            };
        }

        let mut result = input.to_string();

        // Step 1: Remove BOM
        if result.starts_with('\u{FEFF}') {
            result = result[3..].to_string();
            issues.push(SanitizationIssue::BomRemoved);
        }

        // Step 2: Check for null bytes
        if self.config.reject_null_bytes && result.contains('\0') {
            let count = result.matches('\0').count();
            issues.push(SanitizationIssue::NullBytesRemoved { count });
            result = result.replace('\0', "");
            chars_removed += count;
        }

        // Step 3: Strip control characters
        if self.config.strip_control_chars {
            let before_len = result.chars().count();
            result = result.chars()
                .filter(|&c| !is_control_char(c))
                .collect();
            let after_len = result.chars().count();
            let removed = before_len - after_len;
            if removed > 0 {
                issues.push(SanitizationIssue::ControlCharsRemoved { count: removed });
                chars_removed += removed;
            }
        }

        // Step 4: NFC normalization
        let was_normalized = if self.config.normalize_nfc {
            let normalized: String = result.nfc().collect();
            let changed = normalized != result;
            if changed {
                issues.push(SanitizationIssue::NfcNormalized);
            }
            result = normalized;
            changed
        } else {
            false
        };

        // Step 5: Truncate to max length
        if result.len() > self.config.max_length {
            issues.push(SanitizationIssue::TruncatedToMaxLength {
                original_len: result.len(),
                max_len: self.config.max_length,
            });
            // Truncate at character boundary
            result = result.char_indices()
                .take_while(|(i, _)| *i < self.config.max_length)
                .map(|(_, c)| c)
                .collect();
        }

        // Step 6: Check for empty/whitespace-only
        if result.is_empty() {
            issues.push(SanitizationIssue::Empty);
        } else if result.trim().is_empty() {
            issues.push(SanitizationIssue::WhitespaceOnly);
        }

        SanitizationResult {
            sanitized_len: result.len(),
            sanitized: result,
            original_len,
            was_normalized,
            characters_removed: chars_removed,
            replacements_made: replacements,
            issues,
        }
    }

    pub fn needs_sanitization(&self, input: &str) -> bool {
        // Quick checks without allocating
        if input.is_empty() {
            return false;
        }

        // BOM check
        if input.starts_with('\u{FEFF}') {
            return true;
        }

        // Null byte check
        if input.contains('\0') {
            return true;
        }

        // Control character check
        if input.chars().any(is_control_char) {
            return true;
        }

        // NFC check (expensive, do last)
        if self.config.normalize_nfc {
            let normalized: String = input.nfc().collect();
            if normalized != input {
                return true;
            }
        }

        // Length check
        if input.len() > self.config.max_length {
            return true;
        }

        false
    }
}

/// Check if character is a control character (except \n, \r, \t)
fn is_control_char(c: char) -> bool {
    matches!(c, '\u{0000}'..='\u{0008}'
           | '\u{000B}'..='\u{000C}'
           | '\u{000E}'..='\u{001F}'
           | '\u{007F}'
           | '\u{0080}'..='\u{009F}')
}
```

### Bytes Sanitization (for raw input)

```rust
impl InputSanitizer {
    pub fn sanitize_bytes(&self, input: &[u8]) -> EmbeddingResult<SanitizationResult> {
        // Handle invalid UTF-8 with lossy conversion
        let text = if self.config.lossy_utf8 {
            String::from_utf8_lossy(input).into_owned()
        } else {
            String::from_utf8(input.to_vec())
                .map_err(|e| EmbeddingError::InvalidUtf8 {
                    byte_position: e.utf8_error().valid_up_to(),
                })?
        };

        let mut result = self.sanitize(&text);

        // Track UTF-8 issues
        if input != text.as_bytes() {
            let invalid_positions: Vec<_> = input.iter()
                .enumerate()
                .filter(|(i, _)| !is_valid_utf8_start(input, *i))
                .map(|(i, _)| i)
                .collect();

            for pos in invalid_positions {
                result.issues.push(SanitizationIssue::InvalidUtf8 { byte_position: pos });
                result.replacements_made += 1;
            }
        }

        Ok(result)
    }
}
```

### Model-Specific Sanitization

```rust
impl InputSanitizer {
    pub fn sanitize_for_model(&self, input: &str, model_id: ModelId) -> SanitizationResult {
        match model_id {
            // HDC is particularly sensitive to special characters
            ModelId::HDC => {
                let mut config = self.config.clone();
                config.strip_control_chars = true;
                config.normalize_nfc = true;
                InputSanitizer::new(config).sanitize(input)
            }

            // Code model needs to preserve more characters
            ModelId::Code => {
                let mut config = self.config.clone();
                config.strip_control_chars = false; // Keep indentation
                InputSanitizer::new(config).sanitize(input)
            }

            // Default for all others
            _ => self.sanitize(input),
        }
    }
}
```

### Integration with Pipeline

```rust
impl EmbeddingPipeline {
    pub async fn embed(&self, input: &str) -> EmbeddingResult<FusedEmbedding> {
        // Step 0: Sanitize input (M03-L37) - BEFORE PII
        let sanitized = self.sanitizer.sanitize(input);

        if sanitized.issues.contains(&SanitizationIssue::Empty) {
            return Err(EmbeddingError::EmptyInput);
        }

        // Step 1: PII scrub (M03-L25)
        let scrubbed = self.pii_scrubber.scrub(&sanitized.sanitized)?;

        // Step 2: Continue with embedding...
        self.embed_internal(&scrubbed.text).await
    }
}
```

---
*Task ID: M03-L37*
*Layer: Logic*
*Module: 03 - 12-Model Embedding Pipeline*
