# Task Specification: M03-F17

```xml
<task_spec id="M03-F17" version="1.0">
<metadata>
  <title>Optimized Binary Protocol for Graph Storage (FlatBuffers/Bincode)</title>
  <status>ready</status>
  <layer>foundation</layer>
  <sequence>76</sequence>
  <implements>
    - Module 4 Glue: Compact binary serialization for disk-based Knowledge Graph
    - Constitution: storage optimization for 10TB+ deployment
    - PRD: O(1) loading via GDS (GPU Direct Storage)
  </implements>
  <depends_on>
    - M03-F05 (FusedEmbedding)
    - M03-F03 (ModelEmbedding)
    - M03-S15 (GPU Direct Storage)
  </depends_on>
  <estimated_hours>4</estimated_hours>
</metadata>

<context>
Implement a zero-copy binary serialization format for FusedEmbedding storage in the
Knowledge Graph (Module 4). Without this, saving JSON strings to SQLite/RocksDB will
balloon the 10TB storage requirement by 5x.

**The Problem:**
FusedEmbedding (M03-F05) has Serde JSON serialization, but JSON is:
- 4-5x larger than binary (3.2KB vs 6.2KB per embedding)
- Requires parsing and allocation on read
- Cannot leverage GDS (GPU Direct Storage) for direct NVMe→GPU transfer

**Key Requirements:**
1. **Zero-Copy Deserialization**: Load embeddings directly into GPU without CPU copies
2. **GDS Compatible**: Fixed-size, aligned byte layout for O(1) seeking
3. **Version Resilient**: Forward/backward compatible schema evolution
4. **Compact**: <7KB per 1536D embedding (including metadata)
5. **Fast**: <50μs per embedding serialization/deserialization

**Format Comparison:**
| Format | Size/Embed | Deser Time | Zero-Copy | GDS Compatible |
|--------|------------|------------|-----------|----------------|
| JSON | 12KB | 200μs | No | No |
| Bincode | 6.3KB | 15μs | Partial | Yes |
| FlatBuffers | 6.5KB | 5μs | Yes | Yes |
| Custom Binary | 6.2KB | 3μs | Yes | Yes |

**Chosen Approach: Custom Binary Protocol**
Using a custom fixed-layout binary format provides:
- Minimal overhead
- Perfect GDS alignment
- Zero-copy GPU loading
- Version field for future evolution
</context>

<definition_of_done>
  <signatures>
```rust
/// Binary format version
pub const EMBEDDING_BINARY_VERSION: u16 = 1;

/// Magic bytes for file identification
pub const EMBEDDING_MAGIC: [u8; 4] = [0x43, 0x47, 0x45, 0x42]; // "CGEB" = Context Graph Embedding Binary

/// Fixed-size binary header (64 bytes, cache-line aligned)
#[repr(C, align(64))]
#[derive(Debug, Clone, Copy, bytemuck::Pod, bytemuck::Zeroable)]
pub struct EmbeddingHeader {
    /// Magic bytes: "CGEB"
    pub magic: [u8; 4],
    /// Format version
    pub version: u16,
    /// Flags (reserved for future use)
    pub flags: u16,
    /// Vector dimension (1536 for FusedEmbedding)
    pub dimension: u32,
    /// Number of experts
    pub num_experts: u8,
    /// Top-K experts selected
    pub top_k: u8,
    /// Padding for alignment
    pub _reserved: [u8; 2],
    /// Content hash for integrity
    pub content_hash: u64,
    /// Pipeline latency in microseconds
    pub pipeline_latency_us: u64,
    /// Auxiliary data offset (0 if none)
    pub aux_data_offset: u64,
    /// Auxiliary data length (0 if none)
    pub aux_data_length: u64,
    /// Padding to 64 bytes
    pub _padding: [u8; 16],
}

/// Binary encoder/decoder for FusedEmbedding
pub struct EmbeddingBinaryCodec {
    /// Whether to include auxiliary data
    include_aux_data: bool,
    /// Compression for aux_data (None, LZ4, Zstd)
    aux_compression: Option<CompressionType>,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum CompressionType {
    None,
    Lz4,
    Zstd,
}

impl EmbeddingBinaryCodec {
    /// Create codec with default settings
    pub fn new() -> Self;

    /// Create codec with auxiliary data support
    pub fn with_aux_data(compression: Option<CompressionType>) -> Self;

    /// Encode FusedEmbedding to bytes
    /// Returns: [Header (64B) | Vector (6144B) | ExpertWeights (32B) | Selected (2B) | AuxData?]
    pub fn encode(&self, embedding: &FusedEmbedding) -> Vec<u8>;

    /// Encode directly to a pre-allocated buffer (zero-copy)
    pub fn encode_to_buffer(&self, embedding: &FusedEmbedding, buffer: &mut [u8]) -> Result<usize, EncodeError>;

    /// Encode to a file (for batch storage)
    pub fn encode_to_file(&self, embedding: &FusedEmbedding, file: &mut File) -> io::Result<u64>;

    /// Decode FusedEmbedding from bytes
    pub fn decode(&self, bytes: &[u8]) -> Result<FusedEmbedding, DecodeError>;

    /// Decode header only (for seeking/filtering)
    pub fn decode_header(&self, bytes: &[u8]) -> Result<EmbeddingHeader, DecodeError>;

    /// Decode directly from memory-mapped region (zero-copy vector)
    pub fn decode_zero_copy<'a>(&self, bytes: &'a [u8]) -> Result<FusedEmbeddingRef<'a>, DecodeError>;

    /// Compute serialized size for an embedding
    pub fn serialized_size(&self, embedding: &FusedEmbedding) -> usize;

    /// Minimum buffer size required (without aux_data)
    pub const MIN_BUFFER_SIZE: usize = 6242; // 64 + 6144 + 32 + 2
}

/// Zero-copy reference to FusedEmbedding in memory-mapped buffer
pub struct FusedEmbeddingRef<'a> {
    header: &'a EmbeddingHeader,
    vector: &'a [f32; 1536],
    expert_weights: &'a [f32; 8],
    selected_experts: &'a [u8; 2],
    aux_data: Option<&'a [u8]>,
}

impl<'a> FusedEmbeddingRef<'a> {
    /// Get vector slice without copying
    pub fn vector(&self) -> &[f32; 1536];

    /// Convert to owned FusedEmbedding (allocates)
    pub fn to_owned(&self) -> FusedEmbedding;

    /// Get content hash
    pub fn content_hash(&self) -> u64;

    /// Check if this embedding has auxiliary data
    pub fn has_aux_data(&self) -> bool;
}

/// Batch encoder for efficient multi-embedding serialization
pub struct BatchBinaryEncoder {
    codec: EmbeddingBinaryCodec,
    buffer: Vec<u8>,
    offsets: Vec<u64>,
}

impl BatchBinaryEncoder {
    /// Create batch encoder with capacity
    pub fn with_capacity(count: usize) -> Self;

    /// Add embedding to batch
    pub fn push(&mut self, embedding: &FusedEmbedding);

    /// Finalize and get bytes with offset table
    pub fn finalize(self) -> (Vec<u8>, Vec<u64>);

    /// Write to GDS-compatible file
    pub fn write_gds_file(&self, path: &Path) -> io::Result<()>;
}

/// Index file format for batch embeddings
#[repr(C)]
pub struct EmbeddingIndexHeader {
    pub magic: [u8; 4],           // "CGEI" = Context Graph Embedding Index
    pub version: u16,
    pub entry_count: u64,
    pub data_file_hash: u64,      // Hash of associated data file
}

/// Errors during encoding/decoding
#[derive(Debug, thiserror::Error)]
pub enum EncodeError {
    #[error("Buffer too small: need {needed}, have {available}")]
    BufferTooSmall { needed: usize, available: usize },

    #[error("Invalid embedding dimension: {0}")]
    InvalidDimension(usize),

    #[error("IO error: {0}")]
    Io(#[from] io::Error),
}

#[derive(Debug, thiserror::Error)]
pub enum DecodeError {
    #[error("Invalid magic bytes")]
    InvalidMagic,

    #[error("Unsupported version: {0}")]
    UnsupportedVersion(u16),

    #[error("Buffer too short: need {needed}, have {available}")]
    BufferTooShort { needed: usize, available: usize },

    #[error("Corrupted data: hash mismatch")]
    HashMismatch,

    #[error("IO error: {0}")]
    Io(#[from] io::Error),
}
```
  </signatures>

  <constraints>
    - Header must be exactly 64 bytes (cache-line aligned)
    - Vector data must be 64-byte aligned for GDS
    - Big-endian byte order for network/cross-platform compatibility
    - Version field for forward compatibility
    - Content hash verification optional (can skip for performance)
    - bytemuck crate for safe transmutation
    - No unsafe code except through bytemuck abstractions
    - Must support both owned and borrowed (zero-copy) access patterns
  </constraints>

  <verification>
    <step>encode/decode round-trip preserves all data</step>
    <step>Zero-copy decode doesn't allocate heap memory</step>
    <step>Header parsing is O(1)</step>
    <step>GDS file format is readable by cuFile</step>
    <step>Version 1 files are readable by version 2 code</step>
    <step>Invalid magic bytes are rejected</step>
    <step>Truncated files are detected</step>
    <step>Content hash mismatch is detected</step>
  </verification>
</definition_of_done>

<files_to_create>
  <file>crates/context-graph-embeddings/src/storage/mod.rs</file>
  <file>crates/context-graph-embeddings/src/storage/binary.rs</file>
  <file>crates/context-graph-embeddings/src/storage/batch.rs</file>
  <file>crates/context-graph-embeddings/src/storage/gds.rs</file>
</files_to_create>

<validation_criteria>
  <criterion>cargo check passes</criterion>
  <criterion>cargo test storage passes</criterion>
  <criterion>Round-trip encode/decode preserves exact values</criterion>
  <criterion>Serialized size is ≤6.5KB per embedding (without aux_data)</criterion>
  <criterion>Decode latency <10μs for single embedding</criterion>
  <criterion>GDS cuFile can read the batch format</criterion>
</validation_criteria>
</task_spec>
```

## Implementation Notes

### Binary Layout

```
Offset  | Size   | Field
--------|--------|------------------------------------------
0       | 4      | Magic: "CGEB" (0x43 0x47 0x45 0x42)
4       | 2      | Version: 1
6       | 2      | Flags: 0x0000
8       | 4      | Dimension: 1536
12      | 1      | NumExperts: 8
13      | 1      | TopK: 2
14      | 2      | Reserved: 0x0000
16      | 8      | ContentHash: u64
24      | 8      | PipelineLatencyUs: u64
32      | 8      | AuxDataOffset: u64 (0 if none)
40      | 8      | AuxDataLength: u64 (0 if none)
48      | 16     | Padding: zeros
--------|--------|------------------------------------------
64      | 6144   | Vector: [f32; 1536] (1536 * 4 bytes)
6208    | 32     | ExpertWeights: [f32; 8] (8 * 4 bytes)
6240    | 2      | SelectedExperts: [u8; 2]
--------|--------|------------------------------------------
6242    | var    | AuxData (optional, compressed)

Total fixed size: 6242 bytes
With 100-token ColBERT aux_data (compressed): ~19KB
```

### Core Implementation

```rust
use bytemuck::{Pod, Zeroable, bytes_of, from_bytes};

impl EmbeddingBinaryCodec {
    pub fn encode(&self, embedding: &FusedEmbedding) -> Vec<u8> {
        let aux_data = if self.include_aux_data {
            embedding.aux_data.as_ref().map(|a| self.compress_aux_data(a))
        } else {
            None
        };

        let aux_offset = if aux_data.is_some() { Self::MIN_BUFFER_SIZE as u64 } else { 0 };
        let aux_length = aux_data.as_ref().map(|d| d.len() as u64).unwrap_or(0);

        let header = EmbeddingHeader {
            magic: EMBEDDING_MAGIC,
            version: EMBEDDING_BINARY_VERSION,
            flags: 0,
            dimension: FusedEmbedding::DIMENSION as u32,
            num_experts: FusedEmbedding::NUM_EXPERTS as u8,
            top_k: FusedEmbedding::TOP_K as u8,
            _reserved: [0; 2],
            content_hash: embedding.content_hash,
            pipeline_latency_us: embedding.pipeline_latency_us,
            aux_data_offset: aux_offset,
            aux_data_length: aux_length,
            _padding: [0; 16],
        };

        let total_size = Self::MIN_BUFFER_SIZE + aux_length as usize;
        let mut buffer = Vec::with_capacity(total_size);

        // Header (64 bytes)
        buffer.extend_from_slice(bytes_of(&header));

        // Vector (6144 bytes)
        for &val in &embedding.vector {
            buffer.extend_from_slice(&val.to_be_bytes());
        }

        // Expert weights (32 bytes)
        for &weight in &embedding.expert_weights {
            buffer.extend_from_slice(&weight.to_be_bytes());
        }

        // Selected experts (2 bytes)
        buffer.extend_from_slice(&embedding.selected_experts);

        // Auxiliary data (variable)
        if let Some(aux) = aux_data {
            buffer.extend_from_slice(&aux);
        }

        buffer
    }

    pub fn decode(&self, bytes: &[u8]) -> Result<FusedEmbedding, DecodeError> {
        if bytes.len() < Self::MIN_BUFFER_SIZE {
            return Err(DecodeError::BufferTooShort {
                needed: Self::MIN_BUFFER_SIZE,
                available: bytes.len(),
            });
        }

        let header: &EmbeddingHeader = from_bytes(&bytes[0..64]);

        if header.magic != EMBEDDING_MAGIC {
            return Err(DecodeError::InvalidMagic);
        }

        if header.version > EMBEDDING_BINARY_VERSION {
            return Err(DecodeError::UnsupportedVersion(header.version));
        }

        // Parse vector
        let mut vector = Vec::with_capacity(1536);
        for i in 0..1536 {
            let offset = 64 + i * 4;
            let val = f32::from_be_bytes([
                bytes[offset], bytes[offset + 1],
                bytes[offset + 2], bytes[offset + 3],
            ]);
            vector.push(val);
        }

        // Parse expert weights
        let mut expert_weights = [0.0f32; 8];
        for i in 0..8 {
            let offset = 6208 + i * 4;
            expert_weights[i] = f32::from_be_bytes([
                bytes[offset], bytes[offset + 1],
                bytes[offset + 2], bytes[offset + 3],
            ]);
        }

        // Parse selected experts
        let selected_experts = [bytes[6240], bytes[6241]];

        // Parse aux data if present
        let aux_data = if header.aux_data_offset > 0 && header.aux_data_length > 0 {
            let start = header.aux_data_offset as usize;
            let end = start + header.aux_data_length as usize;
            if end > bytes.len() {
                return Err(DecodeError::BufferTooShort {
                    needed: end,
                    available: bytes.len(),
                });
            }
            Some(self.decompress_aux_data(&bytes[start..end])?)
        } else {
            None
        };

        Ok(FusedEmbedding {
            vector,
            expert_weights,
            selected_experts,
            pipeline_latency_us: header.pipeline_latency_us,
            content_hash: header.content_hash,
            aux_data,
        })
    }
}
```

### GDS-Compatible Batch Format

```rust
impl BatchBinaryEncoder {
    pub fn write_gds_file(&self, path: &Path) -> io::Result<()> {
        use std::fs::OpenOptions;

        // Data file
        let data_path = path.with_extension("cgeb");
        let mut data_file = OpenOptions::new()
            .create(true)
            .write(true)
            .open(&data_path)?;

        // Align writes to 4KB pages for GDS
        const PAGE_SIZE: usize = 4096;
        let mut offset = 0u64;

        for (i, embedding_bytes) in self.chunks().enumerate() {
            // Pad to page boundary for GDS alignment
            let padding = (PAGE_SIZE - (offset as usize % PAGE_SIZE)) % PAGE_SIZE;
            if padding > 0 {
                data_file.write_all(&vec![0u8; padding])?;
                offset += padding as u64;
            }

            self.offsets[i] = offset;
            data_file.write_all(embedding_bytes)?;
            offset += embedding_bytes.len() as u64;
        }

        // Index file
        let index_path = path.with_extension("cgei");
        let mut index_file = OpenOptions::new()
            .create(true)
            .write(true)
            .open(&index_path)?;

        let index_header = EmbeddingIndexHeader {
            magic: [0x43, 0x47, 0x45, 0x49], // "CGEI"
            version: 1,
            entry_count: self.offsets.len() as u64,
            data_file_hash: compute_file_hash(&data_path)?,
        };

        index_file.write_all(bytes_of(&index_header))?;
        for &offset in &self.offsets {
            index_file.write_all(&offset.to_be_bytes())?;
        }

        Ok(())
    }
}
```

### Integration with Module 4 Knowledge Graph

```rust
// In Module 4 (context-graph-core)
impl KnowledgeNode {
    /// Store embedding using binary format
    pub fn serialize_embedding(&self) -> Vec<u8> {
        let codec = EmbeddingBinaryCodec::new();
        codec.encode(&self.embedding)
    }

    /// Load embedding from binary format
    pub fn deserialize_embedding(bytes: &[u8]) -> EmbeddingResult<FusedEmbedding> {
        let codec = EmbeddingBinaryCodec::new();
        codec.decode(bytes).map_err(Into::into)
    }

    /// Zero-copy load for read-only access
    pub fn embedding_ref<'a>(bytes: &'a [u8]) -> EmbeddingResult<FusedEmbeddingRef<'a>> {
        let codec = EmbeddingBinaryCodec::new();
        codec.decode_zero_copy(bytes).map_err(Into::into)
    }
}
```

---
*Task ID: M03-F17*
*Layer: Foundation*
*Module: 03 - 12-Model Embedding Pipeline*
