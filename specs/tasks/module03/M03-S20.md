# Task Specification: M03-S20

```xml
<task_spec id="M03-S20" version="1.0">
<metadata>
  <title>CUDA System Pre-flight & Capability Check</title>
  <status>ready</status>
  <layer>surface</layer>
  <sequence>20</sequence>
  <implements>
    - PRD Section 9.2: Hardware compatibility
    - Constitution: reliability.graceful_degradation
    - Technical Engine: Blackwell-specific feature detection
  </implements>
  <depends_on>
    - M03-S04 (CUDA Device Trait)
    - M03-F16 (Module Exports)
  </depends_on>
  <estimated_hours>4</estimated_hours>
</metadata>

<context>
The embedding pipeline targets specific NVIDIA Blackwell hardware (RTX 5090 / CUDA 13.1)
with advanced features:
- Green Contexts (SM partitioning) - M03-S14
- FP8/FP4 quantization - M03-L28
- GPU Direct Storage (GDS) - M03-S15
- Grouped GEMM for MoE - M03-L30

If the pipeline starts on a machine with:
- RTX 4090 (Ada Lovelace) - Missing FP4, limited Green Contexts
- Older driver versions - cuFile (GDS) unavailable
- Non-Blackwell GPU - All Blackwell features fail

WITHOUT pre-flight checks:
- Cryptic CUDA errors at runtime
- Silent fallback to suboptimal paths
- Inconsistent behavior across hardware

This task implements a comprehensive hardware capability check that runs BEFORE
model loading and AUTOMATICALLY enters "Compatibility Mode" when running on
non-Blackwell hardware.

Critical for production deployment across heterogeneous GPU fleets.
</context>

<definition_of_done>
  <signatures>
```rust
use std::collections::HashSet;

/// GPU architecture generation
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub enum GpuArchitecture {
    /// Pre-Ampere (SM < 80)
    Legacy,
    /// Ampere (SM 80-86): A100, RTX 30xx
    Ampere,
    /// Ada Lovelace (SM 89): RTX 40xx
    AdaLovelace,
    /// Hopper (SM 90): H100
    Hopper,
    /// Blackwell (SM 100+): RTX 50xx, B100
    Blackwell,
    /// Unknown/unsupported
    Unknown,
}

/// Hardware capability flags
#[derive(Debug, Clone, Default)]
pub struct GpuCapabilities {
    /// GPU architecture generation
    pub architecture: GpuArchitecture,
    /// CUDA compute capability (e.g., 8.9 for Ada)
    pub compute_capability: (u32, u32),
    /// Number of Streaming Multiprocessors
    pub sm_count: u32,
    /// Total device memory in bytes
    pub memory_bytes: u64,
    /// CUDA driver version (e.g., 13.1)
    pub driver_version: (u32, u32),
    /// CUDA runtime version
    pub runtime_version: (u32, u32),
    /// Feature support flags
    pub features: GpuFeatures,
}

/// Feature-specific support flags
#[derive(Debug, Clone, Default)]
pub struct GpuFeatures {
    /// FP8 (E4M3/E5M2) tensor core support
    pub fp8_tensor_cores: bool,
    /// FP4 (NVFP4) support - Blackwell only
    pub fp4_support: bool,
    /// Green Contexts (SM partitioning)
    pub green_contexts: bool,
    /// GPU Direct Storage (cuFile)
    pub gds_available: bool,
    /// cuFile driver version (if available)
    pub cufile_version: Option<(u32, u32)>,
    /// Grouped GEMM via CUTLASS 3.x
    pub grouped_gemm: bool,
    /// Async memory operations
    pub async_copy: bool,
    /// Tensor Memory Accelerator (TMA)
    pub tma: bool,
    /// Dynamic parallelism
    pub dynamic_parallelism: bool,
    /// Unified memory
    pub unified_memory: bool,
    /// Multi-GPU P2P access
    pub p2p_access: HashSet<u32>,
}

/// Pre-flight check result
#[derive(Debug, Clone)]
pub struct PreflightResult {
    /// Overall status
    pub status: PreflightStatus,
    /// Detected GPU capabilities
    pub capabilities: GpuCapabilities,
    /// Recommended operating mode
    pub recommended_mode: OperatingMode,
    /// Warnings and recommendations
    pub warnings: Vec<PreflightWarning>,
    /// Features that will be disabled
    pub disabled_features: Vec<String>,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum PreflightStatus {
    /// All features available
    FullCapability,
    /// Some features unavailable, compatibility mode recommended
    CompatibilityMode,
    /// Minimum requirements not met
    Unsupported,
    /// No GPU detected
    NoGpu,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum OperatingMode {
    /// Full Blackwell optimization
    Blackwell,
    /// Ada Lovelace / Hopper compatibility
    Modern,
    /// Ampere compatibility
    Ampere,
    /// CPU-only fallback
    CpuOnly,
}

#[derive(Debug, Clone)]
pub struct PreflightWarning {
    pub severity: WarningSeverity,
    pub code: String,
    pub message: String,
    pub recommendation: String,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum WarningSeverity {
    Info,
    Warning,
    Critical,
}

/// Pre-flight checker
pub struct PreflightChecker {
    /// Minimum required CUDA driver version
    min_driver_version: (u32, u32),
    /// Minimum required GPU memory (bytes)
    min_memory: u64,
    /// Required SM count for full performance
    recommended_sm_count: u32,
}

impl PreflightChecker {
    /// Create checker with default requirements
    pub fn new() -> Self;

    /// Create checker with custom requirements
    pub fn with_requirements(
        min_driver: (u32, u32),
        min_memory_gb: u64,
        min_sm_count: u32,
    ) -> Self;

    /// Run complete pre-flight check
    pub fn check(&self) -> PreflightResult;

    /// Check specific GPU by device ID
    pub fn check_device(&self, device_id: u32) -> PreflightResult;

    /// Check all available GPUs
    pub fn check_all_devices(&self) -> Vec<PreflightResult>;

    /// Determine architecture from compute capability
    pub fn detect_architecture(compute_capability: (u32, u32)) -> GpuArchitecture;

    /// Check GDS/cuFile availability
    pub fn check_gds_support() -> Option<(u32, u32)>;

    /// Check Green Context support
    pub fn check_green_context_support(sm_count: u32) -> bool;

    /// Generate human-readable report
    pub fn generate_report(&self, result: &PreflightResult) -> String;
}

/// Automatic mode selection based on pre-flight
pub struct CompatibilityModeSelector;

impl CompatibilityModeSelector {
    /// Select operating mode based on pre-flight result
    pub fn select_mode(result: &PreflightResult) -> OperatingMode;

    /// Configure pipeline for selected mode
    pub fn configure_pipeline(
        config: &mut EmbeddingConfig,
        mode: OperatingMode,
    );

    /// Get feature overrides for mode
    pub fn get_feature_overrides(mode: OperatingMode) -> FeatureOverrides;
}

/// Feature overrides for compatibility modes
#[derive(Debug, Clone, Default)]
pub struct FeatureOverrides {
    pub disable_fp4: bool,
    pub disable_fp8: bool,
    pub disable_gds: bool,
    pub disable_green_contexts: bool,
    pub disable_grouped_gemm: bool,
    pub force_fp32: bool,
    pub max_batch_size: Option<usize>,
}
```
  </signatures>

  <constraints>
    - Pre-flight check MUST complete in <100ms
    - Check MUST run before any model loading
    - No GPU memory allocation during check
    - Handle missing CUDA runtime gracefully
    - Support multi-GPU systems
    - Thread-safe for parallel checks
    - Logging of all detected capabilities
    - Human-readable error messages
    - Blackwell detection: SM count >= 170 (for RTX 5090)
    - GDS check: cuFile driver presence, not just library
  </constraints>

  <verification>
    <step>check() returns FullCapability on RTX 5090</step>
    <step>check() returns CompatibilityMode on RTX 4090</step>
    <step>check() returns Unsupported on pre-Ampere GPUs</step>
    <step>check() returns NoGpu on CPU-only systems</step>
    <step>GDS detection matches cuFile driver availability</step>
    <step>Green Context detection matches SM count >= 170</step>
    <step>FP4 only enabled on Blackwell (SM 100+)</step>
    <step>generate_report() produces clear, actionable output</step>
    <step>configure_pipeline() correctly disables unavailable features</step>
  </verification>
</definition_of_done>

<files_to_create>
  <file>crates/context-graph-embeddings/src/cuda/preflight.rs</file>
  <file>crates/context-graph-embeddings/src/cuda/capabilities.rs</file>
  <file>crates/context-graph-embeddings/src/cuda/compatibility.rs</file>
</files_to_create>

<validation_criteria>
  <criterion>cargo check passes</criterion>
  <criterion>cargo test cuda::preflight passes</criterion>
  <criterion>Pre-flight completes in <100ms</criterion>
  <criterion>Correct architecture detection for known GPUs</criterion>
  <criterion>Compatibility mode correctly disables advanced features</criterion>
  <criterion>Pipeline functions correctly in all detected modes</criterion>
</validation_criteria>
</task_spec>
```

## Implementation Notes

### Architecture Detection from Compute Capability

```rust
impl PreflightChecker {
    pub fn detect_architecture(compute_capability: (u32, u32)) -> GpuArchitecture {
        let (major, minor) = compute_capability;
        match major {
            10.. => GpuArchitecture::Blackwell,  // SM 100+ (Blackwell)
            9 => GpuArchitecture::Hopper,        // SM 90 (H100)
            8 if minor == 9 => GpuArchitecture::AdaLovelace,  // SM 89 (RTX 40xx)
            8 => GpuArchitecture::Ampere,        // SM 80-86 (A100, RTX 30xx)
            _ => GpuArchitecture::Legacy,
        }
    }
}
```

### GDS/cuFile Detection

```rust
impl PreflightChecker {
    pub fn check_gds_support() -> Option<(u32, u32)> {
        // Check if cuFile library is available
        #[cfg(target_os = "linux")]
        {
            // Check for cuFile driver
            let cufile_path = std::path::Path::new("/dev/nvidia-fs0");
            if !cufile_path.exists() {
                return None;
            }

            // Try to get cuFile version
            unsafe {
                // cuFileDriverGetProperties to get version
                // This is a simplified check - actual implementation would use FFI
                Some((1, 7))  // Example: cuFile 1.7
            }
        }

        #[cfg(not(target_os = "linux"))]
        {
            None  // GDS only available on Linux
        }
    }
}
```

### Green Context Support Detection

```rust
impl PreflightChecker {
    pub fn check_green_context_support(sm_count: u32, architecture: GpuArchitecture) -> bool {
        // Green Contexts require:
        // 1. Blackwell architecture (SM 100+)
        // 2. Sufficient SM count for partitioning (170+ for RTX 5090)
        // 3. CUDA 13.0+ driver
        match architecture {
            GpuArchitecture::Blackwell => sm_count >= 170,
            GpuArchitecture::Hopper => sm_count >= 132,  // H100 has limited support
            _ => false,
        }
    }
}
```

### Complete Pre-flight Check

```rust
impl PreflightChecker {
    pub fn check(&self) -> PreflightResult {
        // Check if CUDA is available
        let cuda_available = match cuda_runtime::init() {
            Ok(_) => true,
            Err(_) => return PreflightResult::no_gpu(),
        };

        // Get device count
        let device_count = cuda_runtime::get_device_count().unwrap_or(0);
        if device_count == 0 {
            return PreflightResult::no_gpu();
        }

        // Check primary device (device 0)
        let props = cuda_runtime::get_device_properties(0).expect("Failed to get device properties");

        let architecture = Self::detect_architecture((props.major, props.minor));
        let gds_version = Self::check_gds_support();
        let green_contexts = Self::check_green_context_support(props.sm_count, architecture);

        let features = GpuFeatures {
            fp8_tensor_cores: matches!(architecture, GpuArchitecture::Hopper | GpuArchitecture::Blackwell),
            fp4_support: matches!(architecture, GpuArchitecture::Blackwell),
            green_contexts,
            gds_available: gds_version.is_some(),
            cufile_version: gds_version,
            grouped_gemm: matches!(architecture, GpuArchitecture::AdaLovelace | GpuArchitecture::Hopper | GpuArchitecture::Blackwell),
            async_copy: props.major >= 8,
            tma: matches!(architecture, GpuArchitecture::Hopper | GpuArchitecture::Blackwell),
            dynamic_parallelism: props.major >= 3,
            unified_memory: props.managed_memory != 0,
            p2p_access: self.detect_p2p_access(device_count),
        };

        let capabilities = GpuCapabilities {
            architecture,
            compute_capability: (props.major, props.minor),
            sm_count: props.sm_count,
            memory_bytes: props.total_global_mem,
            driver_version: cuda_runtime::get_driver_version().unwrap_or((0, 0)),
            runtime_version: cuda_runtime::get_runtime_version().unwrap_or((0, 0)),
            features,
        };

        let mut warnings = Vec::new();
        let mut disabled_features = Vec::new();

        // Generate warnings based on capabilities
        if !capabilities.features.fp4_support {
            warnings.push(PreflightWarning {
                severity: WarningSeverity::Info,
                code: "FP4_UNAVAILABLE".into(),
                message: "FP4 quantization not available on this GPU".into(),
                recommendation: "Using FP8 or FP16 as fallback".into(),
            });
            disabled_features.push("FP4 Quantization".into());
        }

        if !capabilities.features.gds_available {
            warnings.push(PreflightWarning {
                severity: WarningSeverity::Warning,
                code: "GDS_UNAVAILABLE".into(),
                message: "GPU Direct Storage not available".into(),
                recommendation: "Install cuFile driver for faster model loading".into(),
            });
            disabled_features.push("GPU Direct Storage".into());
        }

        if !capabilities.features.green_contexts {
            warnings.push(PreflightWarning {
                severity: WarningSeverity::Info,
                code: "GREEN_CTX_UNAVAILABLE".into(),
                message: "Green Contexts not available on this GPU".into(),
                recommendation: "Using standard CUDA streams for parallelism".into(),
            });
            disabled_features.push("Green Contexts".into());
        }

        let status = match architecture {
            GpuArchitecture::Blackwell => PreflightStatus::FullCapability,
            GpuArchitecture::Hopper | GpuArchitecture::AdaLovelace => PreflightStatus::CompatibilityMode,
            GpuArchitecture::Ampere => PreflightStatus::CompatibilityMode,
            _ => PreflightStatus::Unsupported,
        };

        let recommended_mode = CompatibilityModeSelector::select_mode_from_arch(architecture);

        PreflightResult {
            status,
            capabilities,
            recommended_mode,
            warnings,
            disabled_features,
        }
    }
}
```

### Report Generation

```rust
impl PreflightChecker {
    pub fn generate_report(&self, result: &PreflightResult) -> String {
        let mut report = String::new();

        report.push_str("╔══════════════════════════════════════════════════════════════╗\n");
        report.push_str("║           CUDA Pre-flight Capability Report                  ║\n");
        report.push_str("╠══════════════════════════════════════════════════════════════╣\n");

        let status_icon = match result.status {
            PreflightStatus::FullCapability => "✓",
            PreflightStatus::CompatibilityMode => "⚠",
            PreflightStatus::Unsupported => "✗",
            PreflightStatus::NoGpu => "○",
        };

        report.push_str(&format!("║ Status: {} {:?}\n", status_icon, result.status));
        report.push_str(&format!("║ Architecture: {:?}\n", result.capabilities.architecture));
        report.push_str(&format!("║ Compute Capability: {}.{}\n",
            result.capabilities.compute_capability.0,
            result.capabilities.compute_capability.1));
        report.push_str(&format!("║ SM Count: {}\n", result.capabilities.sm_count));
        report.push_str(&format!("║ Memory: {} GB\n",
            result.capabilities.memory_bytes / (1024 * 1024 * 1024)));
        report.push_str(&format!("║ Driver: {}.{}\n",
            result.capabilities.driver_version.0,
            result.capabilities.driver_version.1));

        report.push_str("║\n║ Features:\n");
        let cap = &result.capabilities.features;
        report.push_str(&format!("║   FP8 Tensor Cores: {}\n", if cap.fp8_tensor_cores { "✓" } else { "✗" }));
        report.push_str(&format!("║   FP4 Support:      {}\n", if cap.fp4_support { "✓" } else { "✗" }));
        report.push_str(&format!("║   Green Contexts:   {}\n", if cap.green_contexts { "✓" } else { "✗" }));
        report.push_str(&format!("║   GDS (cuFile):     {}\n", if cap.gds_available { "✓" } else { "✗" }));
        report.push_str(&format!("║   Grouped GEMM:     {}\n", if cap.grouped_gemm { "✓" } else { "✗" }));
        report.push_str(&format!("║   TMA:              {}\n", if cap.tma { "✓" } else { "✗" }));

        report.push_str(&format!("║\n║ Recommended Mode: {:?}\n", result.recommended_mode));

        if !result.warnings.is_empty() {
            report.push_str("║\n║ Warnings:\n");
            for warning in &result.warnings {
                let icon = match warning.severity {
                    WarningSeverity::Info => "ℹ",
                    WarningSeverity::Warning => "⚠",
                    WarningSeverity::Critical => "⛔",
                };
                report.push_str(&format!("║   {} [{}] {}\n", icon, warning.code, warning.message));
            }
        }

        report.push_str("╚══════════════════════════════════════════════════════════════╝\n");

        report
    }
}
```

### Integration with Pipeline Initialization

```rust
impl EmbeddingPipeline {
    pub async fn new(config: EmbeddingConfig) -> EmbeddingResult<Self> {
        // Run pre-flight check FIRST
        let checker = PreflightChecker::new();
        let preflight = checker.check();

        tracing::info!("{}", checker.generate_report(&preflight));

        // Apply compatibility mode if needed
        let mut adjusted_config = config;
        if preflight.status != PreflightStatus::FullCapability {
            CompatibilityModeSelector::configure_pipeline(
                &mut adjusted_config,
                preflight.recommended_mode,
            );

            tracing::warn!(
                "Running in {:?} mode. Disabled features: {:?}",
                preflight.recommended_mode,
                preflight.disabled_features
            );
        }

        // Continue with pipeline initialization using adjusted config
        Self::initialize_with_config(adjusted_config, preflight).await
    }
}
```

---
*Task ID: M03-S20*
*Layer: Surface*
*Module: 03 - 12-Model Embedding Pipeline*
