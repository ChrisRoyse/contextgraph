# M03-F13: BatchConfig Struct Enhancement

## Task Status: IN PROGRESS (Partial Implementation Exists)

**CRITICAL**: A `BatchConfig` struct already exists in `crates/context-graph-embeddings/src/config.rs` (lines 160-244). This task requires ENHANCING the existing implementation to match the constitution spec, NOT creating a new file.

---

## Current State Analysis

### Existing Implementation Location
```
crates/context-graph-embeddings/src/config.rs:160-244
```

### Existing Fields
| Field | Type | Default | Status |
|-------|------|---------|--------|
| `max_batch_size` | `usize` | 32 | DONE |
| `max_wait_ms` | `u64` | 50 | DONE |
| `sort_by_length` | `bool` | true | DONE |
| `padding_strategy` | `String` | "longest" | NEEDS CHANGE |

### Missing Fields (Per constitution.yaml)
| Field | Type | Default | Status |
|-------|------|---------|--------|
| `min_batch_size` | `usize` | 1 | MISSING |
| `dynamic_batching` | `bool` | true | MISSING |

### Required Type Change
The `padding_strategy` field must change from `String` to `PaddingStrategy` enum.

---

## Exact Changes Required

### 1. Add PaddingStrategy Enum

**Insert BEFORE the BatchConfig struct definition (before line 160):**

```rust
/// Padding strategy for variable-length sequences in a batch.
///
/// Controls how inputs of different lengths are padded to form uniform batches.
/// Choice affects memory usage and computational efficiency.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize, Default)]
#[serde(rename_all = "snake_case")]
pub enum PaddingStrategy {
    /// Pad all sequences to the model's max_tokens limit.
    /// Most memory-intensive but safest for models with fixed expectations.
    MaxLength,

    /// Pad to the longest sequence in the current batch.
    /// Most memory-efficient for variable-length inputs.
    #[default]
    DynamicMax,

    /// Pad to next power of two (cache-friendly).
    /// Good for GPU memory alignment and tensor core efficiency.
    PowerOfTwo,

    /// Use predefined length buckets (64, 128, 256, 512).
    /// Balances padding efficiency with kernel optimization.
    Bucket,
}

impl PaddingStrategy {
    /// Returns all valid padding strategies.
    pub fn all() -> &'static [PaddingStrategy] {
        &[
            PaddingStrategy::MaxLength,
            PaddingStrategy::DynamicMax,
            PaddingStrategy::PowerOfTwo,
            PaddingStrategy::Bucket,
        ]
    }

    /// Returns the strategy name as snake_case string.
    pub fn as_str(&self) -> &'static str {
        match self {
            PaddingStrategy::MaxLength => "max_length",
            PaddingStrategy::DynamicMax => "dynamic_max",
            PaddingStrategy::PowerOfTwo => "power_of_two",
            PaddingStrategy::Bucket => "bucket",
        }
    }
}
```

### 2. Update BatchConfig Struct

**Replace the existing BatchConfig struct with:**

```rust
/// Configuration for batch processing.
///
/// Controls how embedding requests are batched for efficient GPU utilization.
/// The batch processor accumulates requests and triggers batch inference when:
/// - Batch reaches `max_batch_size`, OR
/// - `max_wait_ms` timeout expires (if `min_batch_size` is met)
///
/// This enables high throughput (>100 items/sec) by amortizing model invocation overhead.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BatchConfig {
    /// Maximum number of inputs per batch before triggering inference.
    /// Larger batches improve throughput but use more GPU memory.
    /// Constitution spec: max 32
    #[serde(default = "default_max_batch_size")]
    pub max_batch_size: usize,

    /// Minimum batch size to wait for before processing.
    /// If timeout expires and batch size >= min_batch_size, process immediately.
    /// Set to 1 for latency-sensitive applications.
    /// Default: 1
    #[serde(default = "default_min_batch_size")]
    pub min_batch_size: usize,

    /// Maximum time to wait for a full batch (milliseconds).
    /// After this time, partial batch is processed (if >= min_batch_size).
    /// Constitution spec: 50ms (latency-sensitive: 10-100ms range)
    #[serde(default = "default_max_wait_ms")]
    pub max_wait_ms: u64,

    /// Whether to enable dynamic batching based on system load.
    /// When enabled, batch sizes adjust based on queue depth and GPU utilization.
    /// Default: true
    #[serde(default = "default_dynamic_batching")]
    pub dynamic_batching: bool,

    /// Padding strategy for variable-length inputs.
    /// Controls how sequences of different lengths are padded in a batch.
    #[serde(default)]
    pub padding_strategy: PaddingStrategy,

    /// Whether to sort inputs by sequence length before batching.
    /// Reduces padding waste by grouping similar-length sequences.
    /// Can reduce padding overhead by 20-40%.
    /// Default: true
    #[serde(default = "default_sort_by_length")]
    pub sort_by_length: bool,
}
```

### 3. Add Default Functions

**Add these default functions (update existing ones as needed):**

```rust
fn default_min_batch_size() -> usize {
    1
}

fn default_dynamic_batching() -> bool {
    true
}
```

### 4. Update Default Implementation

**Replace the BatchConfig Default impl:**

```rust
impl Default for BatchConfig {
    fn default() -> Self {
        Self {
            max_batch_size: default_max_batch_size(),
            min_batch_size: default_min_batch_size(),
            max_wait_ms: default_max_wait_ms(),
            dynamic_batching: default_dynamic_batching(),
            padding_strategy: PaddingStrategy::default(),
            sort_by_length: default_sort_by_length(),
        }
    }
}
```

### 5. Update Validation

**Replace the BatchConfig validate() method:**

```rust
impl BatchConfig {
    /// Validate batch configuration values.
    ///
    /// # Errors
    /// - `EmbeddingError::ConfigError` if max_batch_size is 0
    /// - `EmbeddingError::ConfigError` if min_batch_size > max_batch_size
    /// - `EmbeddingError::ConfigError` if max_wait_ms is 0 when min_batch_size > 1
    pub fn validate(&self) -> EmbeddingResult<()> {
        if self.max_batch_size == 0 {
            return Err(EmbeddingError::ConfigError {
                message: "max_batch_size must be > 0".to_string(),
            });
        }

        if self.min_batch_size > self.max_batch_size {
            return Err(EmbeddingError::ConfigError {
                message: format!(
                    "min_batch_size ({}) cannot exceed max_batch_size ({})",
                    self.min_batch_size, self.max_batch_size
                ),
            });
        }

        if self.max_wait_ms == 0 && self.min_batch_size > 1 {
            return Err(EmbeddingError::ConfigError {
                message: "max_wait_ms must be > 0 when min_batch_size > 1".to_string(),
            });
        }

        Ok(())
    }
}
```

---

## Tests to Add/Update

**Add these tests to the `#[cfg(test)] mod tests` section in config.rs:**

```rust
// =========================================================================
// PADDING STRATEGY TESTS
// =========================================================================

#[test]
fn test_padding_strategy_default_is_dynamic_max() {
    assert_eq!(PaddingStrategy::default(), PaddingStrategy::DynamicMax);
}

#[test]
fn test_padding_strategy_all_variants() {
    let all = PaddingStrategy::all();
    assert_eq!(all.len(), 4);
    assert!(all.contains(&PaddingStrategy::MaxLength));
    assert!(all.contains(&PaddingStrategy::DynamicMax));
    assert!(all.contains(&PaddingStrategy::PowerOfTwo));
    assert!(all.contains(&PaddingStrategy::Bucket));
}

#[test]
fn test_padding_strategy_as_str() {
    assert_eq!(PaddingStrategy::MaxLength.as_str(), "max_length");
    assert_eq!(PaddingStrategy::DynamicMax.as_str(), "dynamic_max");
    assert_eq!(PaddingStrategy::PowerOfTwo.as_str(), "power_of_two");
    assert_eq!(PaddingStrategy::Bucket.as_str(), "bucket");
}

#[test]
fn test_padding_strategy_serde_roundtrip() {
    for strategy in PaddingStrategy::all() {
        let json = serde_json::to_string(strategy).unwrap();
        let restored: PaddingStrategy = serde_json::from_str(&json).unwrap();
        assert_eq!(*strategy, restored);
    }
}

#[test]
fn test_padding_strategy_serde_snake_case() {
    // Verify snake_case serialization
    let json = serde_json::to_string(&PaddingStrategy::DynamicMax).unwrap();
    assert_eq!(json, "\"dynamic_max\"");

    let json = serde_json::to_string(&PaddingStrategy::PowerOfTwo).unwrap();
    assert_eq!(json, "\"power_of_two\"");
}

#[test]
fn test_padding_strategy_copy() {
    // PaddingStrategy must be Copy for efficiency
    let a = PaddingStrategy::Bucket;
    let b = a; // Copy
    assert_eq!(a, b);
}

// =========================================================================
// BATCH CONFIG NEW FIELD TESTS
// =========================================================================

#[test]
fn test_batch_config_new_defaults() {
    let config = BatchConfig::default();
    assert_eq!(config.min_batch_size, 1);
    assert!(config.dynamic_batching);
    assert_eq!(config.padding_strategy, PaddingStrategy::DynamicMax);
}

#[test]
fn test_batch_validate_min_exceeds_max() {
    let config = BatchConfig {
        min_batch_size: 64,
        max_batch_size: 32,
        ..Default::default()
    };
    let result = config.validate();
    assert!(result.is_err());
    let msg = result.unwrap_err().to_string();
    assert!(msg.contains("min_batch_size"));
    assert!(msg.contains("cannot exceed"));
}

#[test]
fn test_batch_validate_zero_wait_with_min_batch() {
    let config = BatchConfig {
        min_batch_size: 4,
        max_wait_ms: 0,
        ..Default::default()
    };
    let result = config.validate();
    assert!(result.is_err());
    let msg = result.unwrap_err().to_string();
    assert!(msg.contains("max_wait_ms"));
    assert!(msg.contains("min_batch_size > 1"));
}

#[test]
fn test_batch_validate_zero_wait_with_min_one_succeeds() {
    // Special case: max_wait_ms=0 is OK if min_batch_size=1
    let config = BatchConfig {
        min_batch_size: 1,
        max_wait_ms: 0,
        max_batch_size: 32,
        dynamic_batching: true,
        padding_strategy: PaddingStrategy::DynamicMax,
        sort_by_length: true,
    };
    assert!(config.validate().is_ok());
}

#[test]
fn test_batch_config_toml_roundtrip() {
    let original = BatchConfig {
        max_batch_size: 64,
        min_batch_size: 4,
        max_wait_ms: 100,
        dynamic_batching: false,
        padding_strategy: PaddingStrategy::PowerOfTwo,
        sort_by_length: false,
    };

    let toml_str = toml::to_string(&original).unwrap();
    let restored: BatchConfig = toml::from_str(&toml_str).unwrap();

    assert_eq!(original.max_batch_size, restored.max_batch_size);
    assert_eq!(original.min_batch_size, restored.min_batch_size);
    assert_eq!(original.max_wait_ms, restored.max_wait_ms);
    assert_eq!(original.dynamic_batching, restored.dynamic_batching);
    assert_eq!(original.padding_strategy, restored.padding_strategy);
    assert_eq!(original.sort_by_length, restored.sort_by_length);
}
```

---

## Update Existing Tests

**Update these existing tests to reflect new structure:**

### test_batch_config_default
```rust
#[test]
fn test_batch_config_default() {
    let config = BatchConfig::default();
    assert_eq!(config.max_batch_size, 32);
    assert_eq!(config.min_batch_size, 1);  // NEW
    assert_eq!(config.max_wait_ms, 50);
    assert!(config.dynamic_batching);  // NEW
    assert!(config.sort_by_length);
    assert_eq!(config.padding_strategy, PaddingStrategy::DynamicMax);  // CHANGED
}
```

### Remove test_batch_invalid_padding_fails
The old test checked for invalid padding strategy strings. Since we now use an enum, this validation is compile-time enforced. Remove this test.

---

## Exports Update

**In `crates/context-graph-embeddings/src/lib.rs`, add PaddingStrategy to exports:**

```rust
pub use config::{
    BatchConfig,
    CacheConfig,
    EmbeddingConfig,
    FusionConfig,
    GpuConfig,
    ModelRegistryConfig,
    PaddingStrategy,  // ADD THIS
};
```

---

## Validation Commands

Run these commands to verify implementation:

```bash
# 1. Compile check (must pass)
cargo check --package context-graph-embeddings

# 2. Run all tests (must pass)
cargo test --package context-graph-embeddings

# 3. Clippy (0 warnings)
cargo clippy --package context-graph-embeddings -- -D warnings

# 4. Verify default config validates
cargo test --package context-graph-embeddings test_default_config_validates

# 5. Verify new batch tests pass
cargo test --package context-graph-embeddings test_batch_config_new_defaults
cargo test --package context-graph-embeddings test_batch_validate_min_exceeds_max
cargo test --package context-graph-embeddings test_padding_strategy
```

---

## Full State Verification Protocol

After completing the implementation, execute these verification steps:

### Source of Truth
The final result is stored in:
- **File**: `crates/context-graph-embeddings/src/config.rs`
- **Struct**: `BatchConfig` (must have 6 fields)
- **Enum**: `PaddingStrategy` (must have 4 variants)

### Execute & Inspect

1. **Struct Field Verification**:
```bash
grep -A 30 "pub struct BatchConfig" crates/context-graph-embeddings/src/config.rs | head -40
```
Expected output must show all 6 fields: `max_batch_size`, `min_batch_size`, `max_wait_ms`, `dynamic_batching`, `padding_strategy`, `sort_by_length`.

2. **Enum Variant Verification**:
```bash
grep -A 25 "pub enum PaddingStrategy" crates/context-graph-embeddings/src/config.rs | head -30
```
Expected output must show 4 variants: `MaxLength`, `DynamicMax`, `PowerOfTwo`, `Bucket`.

3. **Export Verification**:
```bash
grep "PaddingStrategy" crates/context-graph-embeddings/src/lib.rs
```
Must show `PaddingStrategy` in the exports.

### Boundary & Edge Case Audit

**Edge Case 1: Empty Configuration (min_batch_size defaults)**
```bash
echo '[batch]' | cargo test --package context-graph-embeddings test_from_toml_str_partial_config -- --nocapture
```
Before: BatchConfig uses default min_batch_size=1
After: Test passes, min_batch_size=1

**Edge Case 2: Maximum Limits (min > max rejected)**
```bash
cargo test --package context-graph-embeddings test_batch_validate_min_exceeds_max -- --nocapture
```
Before: Invalid config
After: Returns EmbeddingError::ConfigError with message containing "min_batch_size cannot exceed"

**Edge Case 3: Zero Timeout with min_batch_size > 1**
```bash
cargo test --package context-graph-embeddings test_batch_validate_zero_wait_with_min_batch -- --nocapture
```
Before: Invalid config (max_wait_ms=0, min_batch_size=4)
After: Returns EmbeddingError::ConfigError

### Evidence of Success

**Required Log Output:**
```bash
cargo test --package context-graph-embeddings 2>&1 | tail -20
```

Expected output must show:
```
test config::tests::test_batch_config_default ... ok
test config::tests::test_batch_config_new_defaults ... ok
test config::tests::test_batch_validate_min_exceeds_max ... ok
test config::tests::test_batch_validate_zero_wait_with_min_batch ... ok
test config::tests::test_batch_validate_zero_wait_with_min_one_succeeds ... ok
test config::tests::test_padding_strategy_default_is_dynamic_max ... ok
test config::tests::test_padding_strategy_all_variants ... ok
test config::tests::test_padding_strategy_as_str ... ok
test config::tests::test_padding_strategy_serde_roundtrip ... ok
test config::tests::test_padding_strategy_serde_snake_case ... ok
test config::tests::test_padding_strategy_copy ... ok
test config::tests::test_batch_config_toml_roundtrip ... ok
```

---

## Final Sherlock Holmes Verification

After all implementation is complete, use the `sherlock-holmes` subagent to verify:

1. **File exists and compiles**: Verify `config.rs` compiles without errors
2. **All 6 BatchConfig fields present**: Count fields in struct definition
3. **All 4 PaddingStrategy variants present**: Verify enum definition
4. **All tests pass**: `cargo test` output shows 0 failures
5. **No clippy warnings**: `cargo clippy` output shows 0 warnings
6. **Exports correct**: `PaddingStrategy` exported from lib.rs
7. **Serde roundtrip works**: JSON/TOML serialization produces identical objects
8. **Validation logic correct**: Invalid configs return proper errors

---

## Dependencies

- **M03-F08**: EmbeddingError (DONE - already exists)
- **None other**: This task has no unmet dependencies

---

## Constitution.yaml Compliance

| Requirement | Source | Implementation |
|-------------|--------|----------------|
| max_batch_size = 32 | constitution.yaml:embeddings.batch | Default::default() |
| max_wait_ms = 50 | constitution.yaml:perf.latency | Default::default() |
| >100 items/sec throughput | constitution.yaml:perf.throughput | BatchProcessor (M03-L17) |
| sort_by_length reduces padding | PRD Section 4.3 | sort_by_length=true default |
| Dynamic batching | constitution.yaml:embeddings.batch | dynamic_batching=true default |

---

## NO BACKWARDS COMPATIBILITY

- Remove the old `padding_strategy: String` field completely
- Do not add migration code or fallback parsing
- If tests fail due to hardcoded "longest" string, update the test to use `PaddingStrategy::DynamicMax`
- Any code that depends on the old string-based padding strategy MUST be updated or it will fail to compile

---

## Task Metadata

```yaml
task_id: M03-F13
title: BatchConfig Struct Enhancement
status: in_progress
layer: foundation
sequence: 13
implements: constitution.yaml:embeddings.batch, PRD Section 4.3
depends_on: M03-F08
estimated_hours: 1.5
file_to_modify: crates/context-graph-embeddings/src/config.rs
created: 2026-01-01
updated: 2026-01-01
```
