<?xml version="1.0" encoding="UTF-8"?>
<task_spec id="M03-L02" version="2.0">
<metadata>
  <title>MemoryTracker for Model Memory Budget Management</title>
  <status>completed</status>
  <layer>logic</layer>
  <sequence>2</sequence>
  <implements>PRD: GPU memory management, model allocation tracking</implements>
  <depends_on>M03-F15 (GpuConfig)</depends_on>
  <actual_hours>1.5</actual_hours>
  <completed_date>2026-01-01</completed_date>
  <last_updated>2026-01-01</last_updated>
</metadata>

<context>
MemoryTracker provides model-based memory allocation tracking to prevent OOM conditions.
Unlike the original device-centric design, the implemented solution tracks allocations
PER MODEL (via ModelId), which aligns with ModelRegistry's per-model loading architecture.

Key responsibilities (AS IMPLEMENTED):
- Track memory allocations per ModelId (not per device)
- Enforce total memory budget before allocation
- Provide budget/remaining/current queries
- Support deallocation when models unload
- Integrate with ModelRegistry via RwLock wrapper

CRITICAL DESIGN PRINCIPLES:
- NO BACKWARDS COMPATIBILITY: System works correctly or fails fast
- NO MOCK DATA: All tests use real MEMORY_ESTIMATES from model_factory.rs
- NO WORKAROUNDS/FALLBACKS: Errors propagate immediately with full context
- FAIL FAST: Budget exceeded = immediate EmbeddingError::MemoryBudgetExceeded
</context>

<implementation_status>
  <completed>true</completed>
  <files_created>
    <file path="crates/context-graph-embeddings/src/models/memory_tracker.rs" lines="559">
      Full MemoryTracker implementation with 24 tests
    </file>
    <file path="crates/context-graph-embeddings/src/models/registry.rs" lines="1641">
      ModelRegistry with MemoryTracker integration, 35+ tests
    </file>
    <file path="crates/context-graph-embeddings/src/models/mod.rs" lines="51">
      Module exports for MemoryTracker, ModelRegistry, ModelRegistryConfig, RegistryStats
    </file>
  </files_created>
  <exports_in_lib>
    pub use models::{MemoryTracker, ModelRegistry, ModelRegistryConfig, RegistryStats};
  </exports_in_lib>
</implementation_status>

<codebase_alignment>
  <existing_infrastructure>
    <file path="crates/context-graph-embeddings/src/traits/model_factory.rs">
      MEMORY_ESTIMATES constant array: 12 models totaling ~24.7GB
      get_memory_estimate(ModelId) helper function
    </file>
    <file path="crates/context-graph-embeddings/src/error.rs">
      EmbeddingError::MemoryBudgetExceeded { requested_bytes, available_bytes, budget_bytes }
      EmbeddingError::ModelAlreadyLoaded { model_id }
      EmbeddingError::ModelNotLoaded { model_id }
    </file>
    <file path="crates/context-graph-embeddings/src/types/model_id.rs">
      ModelId enum with 12 variants
    </file>
    <file path="crates/context-graph-embeddings/src/config.rs">
      GpuConfig with memory_fraction field (default 0.9)
    </file>
  </existing_infrastructure>
</codebase_alignment>

<definition_of_done>
  <signatures>
```rust
// File: crates/context-graph-embeddings/src/models/memory_tracker.rs

use std::collections::HashMap;
use crate::error::{EmbeddingError, EmbeddingResult};
use crate::types::ModelId;

/// Tracks memory usage across loaded models.
/// NOT thread-safe by itself - wrapped in RwLock by ModelRegistry.
#[derive(Debug)]
pub struct MemoryTracker {
    /// Current total memory usage in bytes
    current_bytes: usize,
    /// Maximum allowed memory in bytes
    budget_bytes: usize,
    /// Per-model memory allocations
    allocations: HashMap<ModelId, usize>,
}

impl MemoryTracker {
    /// Create with budget (RTX 5090 = 32GB, RTX 4090 = 24GB)
    pub fn new(budget_bytes: usize) -> Self;

    /// Check if allocation is possible within budget
    pub fn can_allocate(&self, bytes: usize) -> bool;

    /// Allocate memory for a model
    /// FAILS FAST: Returns MemoryBudgetExceeded or ModelAlreadyLoaded
    pub fn allocate(&mut self, model_id: ModelId, bytes: usize) -> EmbeddingResult<()>;

    /// Deallocate memory when model unloaded
    /// FAILS FAST: Returns ModelNotLoaded if not allocated
    pub fn deallocate(&mut self, model_id: ModelId) -> EmbeddingResult<usize>;

    /// Get current total memory usage in bytes
    pub fn current_usage(&self) -> usize;

    /// Get remaining budget in bytes
    pub fn remaining(&self) -> usize;

    /// Get configured budget in bytes
    pub fn budget(&self) -> usize;

    /// Get memory allocated for a specific model (0 if not loaded)
    pub fn allocation_for(&self, model_id: ModelId) -> usize;

    /// Get number of models with allocations
    pub fn allocation_count(&self) -> usize;

    /// Check if a model has memory allocated
    pub fn is_allocated(&self, model_id: ModelId) -> bool;

    /// Get all model IDs with allocations
    pub fn allocated_models(&self) -> Vec<ModelId>;
}
```
  </signatures>

  <constraints>
    <constraint>Budget check via can_allocate() before allocation</constraint>
    <constraint>Allocation fails with MemoryBudgetExceeded if budget exceeded</constraint>
    <constraint>Allocation fails with ModelAlreadyLoaded if model already allocated</constraint>
    <constraint>Deallocation fails with ModelNotLoaded if not allocated</constraint>
    <constraint>Uses saturating_add/saturating_sub for overflow protection</constraint>
    <constraint>NOT thread-safe by itself (wrapped in RwLock by ModelRegistry)</constraint>
    <constraint>Per-model tracking (NOT per-device as original spec)</constraint>
  </constraints>

  <verification>
    <step>can_allocate returns false when budget would be exceeded</step>
    <step>allocate fails with EmbeddingError::MemoryBudgetExceeded when over budget</step>
    <step>allocate fails with EmbeddingError::ModelAlreadyLoaded for duplicate allocation</step>
    <step>deallocate correctly reduces tracked memory and returns bytes freed</step>
    <step>remaining() returns budget - current_usage at all times</step>
    <step>All 12 models can be allocated if budget sufficient</step>
    <step>Overflow protection with saturating arithmetic</step>
  </verification>
</definition_of_done>

<source_of_truth>
  <truth id="SOT-1" name="Memory Allocation State">
    <description>HashMap of per-model allocations keyed by ModelId</description>
    <location>MemoryTracker.allocations: HashMap&lt;ModelId, usize&gt;</location>
    <verification>allocation_count() == allocations.len(); is_allocated() checks contains_key</verification>
  </truth>
  <truth id="SOT-2" name="Current Usage State">
    <description>Sum of all allocations in bytes</description>
    <location>MemoryTracker.current_bytes: usize</location>
    <verification>current_usage() == current_bytes; sum(allocations.values()) == current_bytes</verification>
  </truth>
  <truth id="SOT-3" name="Budget Constraint">
    <description>Maximum allowed memory in bytes</description>
    <location>MemoryTracker.budget_bytes: usize</location>
    <verification>budget() returns budget_bytes; remaining() == budget_bytes - current_bytes</verification>
  </truth>
</source_of_truth>

<full_state_verification>
  <execute_and_inspect>
    <step id="FSV-1">After allocate(): Verify model_id in allocations AND current_bytes increased by exact amount</step>
    <step id="FSV-2">After deallocate(): Verify model_id removed from allocations AND current_bytes decreased</step>
    <step id="FSV-3">Invariant: sum(allocations.values()) == current_bytes at all times</step>
    <step id="FSV-4">Invariant: current_bytes &lt;= budget_bytes when all operations succeed</step>
    <step id="FSV-5">After failed allocation: Verify allocations unchanged, current_bytes unchanged</step>
  </execute_and_inspect>

  <edge_case_audit>
    <case id="EDGE-1" name="Exact Budget Allocation">
      <precondition>Tracker with 1_400_000_000 budget, empty</precondition>
      <action>allocate(Semantic, 1_400_000_000)</action>
      <expected>Ok(()), remaining() == 0, can_allocate(1) == false</expected>
      <postcondition>current_usage() == 1_400_000_000</postcondition>
    </case>
    <case id="EDGE-2" name="Budget Exceeded by 1 Byte">
      <precondition>Tracker with 1_000_000_000 budget, empty</precondition>
      <action>allocate(Multimodal, 1_000_000_001)</action>
      <expected>Err(MemoryBudgetExceeded) with requested=1_000_000_001, available=1_000_000_000</expected>
      <postcondition>current_usage() == 0, allocations empty</postcondition>
    </case>
    <case id="EDGE-3" name="Duplicate Allocation Attempt">
      <precondition>Tracker with Semantic already allocated</precondition>
      <action>allocate(Semantic, any_amount)</action>
      <expected>Err(ModelAlreadyLoaded { model_id: Semantic })</expected>
      <postcondition>Original allocation unchanged</postcondition>
    </case>
    <case id="EDGE-4" name="Deallocate Not Loaded">
      <precondition>Empty tracker</precondition>
      <action>deallocate(Semantic)</action>
      <expected>Err(ModelNotLoaded { model_id: Semantic })</expected>
      <postcondition>Tracker unchanged</postcondition>
    </case>
    <case id="EDGE-5" name="Zero Budget">
      <precondition>Tracker with budget_bytes = 0</precondition>
      <action>can_allocate(1)</action>
      <expected>false; can_allocate(0) returns true</expected>
    </case>
    <case id="EDGE-6" name="Overflow Protection">
      <precondition>Tracker with large allocation near usize::MAX</precondition>
      <action>can_allocate(usize::MAX)</action>
      <expected>false (saturating_add prevents overflow)</expected>
    </case>
  </edge_case_audit>

  <evidence_of_success>
    <log level="DEBUG">MemoryTracker::allocate model_id={:?} allocated_bytes={} total_bytes={} remaining_bytes={}</log>
    <log level="DEBUG">MemoryTracker::deallocate model_id={:?} freed_bytes={} remaining_total={}</log>
    <log level="WARN">ModelRegistry::load_model budget_check_failed required={} available={}</log>
    <log level="ERROR">ModelRegistry::load_model FAILED model_id={:?} error={:?}</log>
  </evidence_of_success>
</full_state_verification>

<manual_output_verification>
  <verify id="MOV-1" name="Allocation Recorded in HashMap">
    <method>After allocate(model_id, N), call is_allocated(model_id) and allocation_for(model_id)</method>
    <assertion>is_allocated() == true AND allocation_for() == N</assertion>
  </verify>
  <verify id="MOV-2" name="Current Usage Accuracy">
    <method>Allocate 3 models with known sizes; compare current_usage() with sum</method>
    <assertion>current_usage() == sum of allocated bytes exactly</assertion>
  </verify>
  <verify id="MOV-3" name="Remaining Budget Accuracy">
    <method>remaining() == budget() - current_usage() at all times</method>
    <assertion>Values match exactly</assertion>
  </verify>
  <verify id="MOV-4" name="Deallocate Returns Correct Bytes">
    <method>Allocate known amount, deallocate, verify returned bytes</method>
    <assertion>Returned value equals originally allocated amount</assertion>
  </verify>
</manual_output_verification>

<test_requirements>
  <requirement>NO MOCK DATA: Tests use real MEMORY_ESTIMATES from model_factory.rs</requirement>
  <requirement>All edge cases (EDGE-1 through EDGE-6) have corresponding tests</requirement>
  <requirement>All manual verification steps (MOV-1 through MOV-4) have tests</requirement>
  <requirement>Error messages contain full context (requested, available, budget)</requirement>
  <requirement>No unwrap() in production code</requirement>

  <test_structure>
    <module>crates/context-graph-embeddings/src/models/memory_tracker.rs (co-located)</module>
    <test_count>24 tests implemented</test_count>
    <categories>
      <category name="construction">new() with various budgets (3 tests)</category>
      <category name="can_allocate">budget checking (4 tests)</category>
      <category name="allocate">successful and failed allocations (5 tests)</category>
      <category name="deallocate">successful and failed deallocations (4 tests)</category>
      <category name="usage_tracking">current/remaining/per-model queries (4 tests)</category>
      <category name="edge_cases">overflow protection, exact budget, zero budget (4 tests)</category>
    </categories>
  </test_structure>
</test_requirements>

<validation_criteria>
  <criterion>cargo check passes</criterion>
  <criterion>cargo test passes with all 24 tests</criterion>
  <criterion>cargo clippy -- -D warnings passes</criterion>
  <criterion>Memory accounting accurate to byte level (no approximation)</criterion>
  <criterion>No overflow in arithmetic operations (saturating math used)</criterion>
  <criterion>All errors contain full diagnostic context</criterion>
  <criterion>No unwrap() in production code</criterion>
</validation_criteria>

<design_deviation_notes>
  <deviation>
    <original>Device-based tracking (GPU per device ID + CPU)</original>
    <implemented>Model-based tracking (per ModelId)</implemented>
    <rationale>Aligns with ModelRegistry architecture which manages models, not devices.
    Device placement handled at model creation time via DevicePlacement enum.</rationale>
  </deviation>
  <deviation>
    <original>GpuMemoryInfo struct with peak tracking</original>
    <implemented>Simple per-model allocation map</implemented>
    <rationale>Peak tracking not needed for current use case. Can be added later if required.</rationale>
  </deviation>
  <deviation>
    <original>File: src/models/memory.rs</original>
    <implemented>File: src/models/memory_tracker.rs</implemented>
    <rationale>More descriptive filename matching struct name</rationale>
  </deviation>
</design_deviation_notes>

<final_verification>
  <requirement>MANDATORY: Use sherlock-holmes subagent for comprehensive task verification</requirement>
  <sherlock_checklist>
    <check status="PASS">memory_tracker.rs created with MemoryTracker implementation</check>
    <check status="PASS">registry.rs integrates MemoryTracker via RwLock</check>
    <check status="PASS">mod.rs exports MemoryTracker</check>
    <check status="PASS">lib.rs re-exports from models module</check>
    <check status="PASS">All signatures match definition_of_done</check>
    <check status="PASS">All 6 edge cases have corresponding tests</check>
    <check status="PASS">All 4 manual verification steps have tests</check>
    <check status="PASS">24 tests exist and pass</check>
    <check status="PASS">Uses real MEMORY_ESTIMATES in test_allocate_all_12_models</check>
    <check status="PASS">Log statements implemented (tracing::debug)</check>
    <check status="PASS">cargo check, cargo test, cargo clippy all pass</check>
    <check status="PASS">Source of Truth locations verified as implemented</check>
  </sherlock_checklist>
</final_verification>
</task_spec>
