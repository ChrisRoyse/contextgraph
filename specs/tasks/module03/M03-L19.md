<?xml version="1.0" encoding="UTF-8"?>
<task_spec id="M03-L19" version="2.0">
<metadata>
  <title>CacheManager Implementation with LRU Eviction</title>
  <status>ready</status>
  <layer>logic</layer>
  <sequence>19</sequence>
  <implements>PRD-EMB-003: Embedding Cache System</implements>
  <depends_on>M03-L18 (COMPLETE: 19/19 tests passing)</depends_on>
  <estimated_hours>4</estimated_hours>
</metadata>

<context>
Implement embedding cache manager with LRU eviction and optional disk persistence.
The CacheManager stores FusedEmbeddings keyed by content hash, supporting fast
lookups (<100μs target per constitution.yaml reflex_cache budget) and configurable
eviction policies. The cache is critical for achieving >80% hit rate on repeated
content, reducing embedding computation costs significantly.

DEPENDENCY STATUS: M03-L18 is COMPLETE. CacheKey and CacheEntry types exist in
`crates/context-graph-embeddings/src/cache/types.rs` with 19 passing tests.
</context>

<source_of_truth>
  <primary>In-memory LinkedHashMap&lt;CacheKey, CacheEntry&gt; wrapped in RwLock</primary>
  <secondary>Optional disk file at configured persistence path (bincode format)</secondary>
  <metrics>CacheMetrics struct with atomic counters for hits/misses/evictions/bytes</metrics>
</source_of_truth>

<existing_types>
<!-- These types already exist - DO NOT recreate -->
<type location="crates/context-graph-embeddings/src/cache/types.rs">
```rust
// CacheKey: 8-byte xxhash content hash (u64)
pub struct CacheKey(pub u64);

// CacheEntry: embedding wrapper with access tracking
pub struct CacheEntry {
    pub embedding: FusedEmbedding,
    pub created_at: DateTime<Utc>,
    pub last_accessed: DateTime<Utc>,
    pub access_count: u64,
}
impl CacheEntry {
    pub fn memory_size(&self) -> usize; // Returns embedding memory footprint
}
```
</type>

<type location="crates/context-graph-embeddings/src/config.rs:578-650">
```rust
pub enum EvictionPolicy {
    Lru,      // Least Recently Used
    Lfu,      // Least Frequently Used
    TtlLru,   // TTL with LRU fallback
    Arc,      // Adaptive Replacement Cache
}

pub struct CacheConfig {
    pub enabled: bool,
    pub max_entries: usize,      // Default: 100_000
    pub max_bytes: usize,        // Default: 1GB (1_073_741_824)
    pub ttl_seconds: Option<u64>,
    pub eviction_policy: EvictionPolicy,
    pub persist_to_disk: bool,
    pub persistence_path: Option<PathBuf>,
}
```
</type>

<type location="crates/context-graph-embeddings/src/types/fused.rs">
```rust
pub struct FusedEmbedding {
    pub data: Vec<f32>,           // 1536 dimensions
    pub source_model: ModelType,
    pub created_at: DateTime<Utc>,
    pub metadata: FusedMetadata,
}
```
</type>
</existing_types>

<definition_of_done>
  <file_to_create>crates/context-graph-embeddings/src/cache/manager.rs</file_to_create>

  <signatures>
```rust
use std::sync::atomic::{AtomicU64, AtomicUsize, Ordering};
use std::sync::RwLock;
use linked_hash_map::LinkedHashMap;
use crate::cache::types::{CacheKey, CacheEntry};
use crate::types::FusedEmbedding;
use crate::config::CacheConfig;
use crate::error::EmbeddingResult;

/// Thread-safe cache metrics with atomic counters
pub struct CacheMetrics {
    pub hits: AtomicU64,
    pub misses: AtomicU64,
    pub evictions: AtomicU64,
    pub bytes_used: AtomicUsize,
}

/// LRU-based embedding cache manager
///
/// FAIL-FAST: All errors propagate immediately. No fallbacks.
pub struct CacheManager {
    entries: RwLock<LinkedHashMap<CacheKey, CacheEntry>>,
    config: CacheConfig,
    metrics: CacheMetrics,
}

impl CacheManager {
    /// Create new cache manager with given configuration
    /// ERRORS: Returns Err if config validation fails
    pub fn new(config: CacheConfig) -> EmbeddingResult<Self>;

    /// Get embedding by key, updating LRU order
    /// Returns None if key not found or entry expired
    /// Updates metrics.hits or metrics.misses
    pub fn get(&self, key: &CacheKey) -> Option<FusedEmbedding>;

    /// Insert embedding, evicting LRU entries if needed
    /// ERRORS: Returns Err if embedding exceeds max_bytes alone
    pub fn put(&self, key: CacheKey, embedding: FusedEmbedding) -> EmbeddingResult<()>;

    /// Check if key exists (does not update LRU order)
    pub fn contains(&self, key: &CacheKey) -> bool;

    /// Remove entry by key
    pub fn remove(&self, key: &CacheKey) -> Option<FusedEmbedding>;

    /// Clear all entries, reset metrics
    pub fn clear(&self);

    /// Current entry count
    pub fn len(&self) -> usize;

    /// Check if cache is empty
    pub fn is_empty(&self) -> bool;

    /// Calculate hit rate: hits / (hits + misses)
    /// Returns 0.0 if no accesses yet
    pub fn hit_rate(&self) -> f32;

    /// Current memory usage in bytes
    pub fn memory_usage(&self) -> usize;

    /// Persist cache to disk (bincode format)
    /// ERRORS: Returns Err on I/O failure or serialization error
    pub async fn persist(&self) -> EmbeddingResult<()>;

    /// Load cache from disk, replacing current entries
    /// ERRORS: Returns Err on I/O failure, deserialization error, or checksum mismatch
    pub async fn load(&self) -> EmbeddingResult<()>;
}
```
  </signatures>

  <constraints>
    <constraint id="C1">Cache lookup latency: &lt;100μs (per constitution.yaml reflex_cache)</constraint>
    <constraint id="C2">LRU eviction when max_entries exceeded</constraint>
    <constraint id="C3">Memory-based eviction when max_bytes exceeded</constraint>
    <constraint id="C4">TTL-based expiration if ttl_seconds configured</constraint>
    <constraint id="C5">Hit rate target: &gt;80% under normal workload</constraint>
    <constraint id="C6">Thread-safe via RwLock (read-heavy workload optimized)</constraint>
    <constraint id="C7">LinkedHashMap maintains insertion order for LRU</constraint>
    <constraint id="C8">Disk persistence uses bincode serialization</constraint>
    <constraint id="C9">FAIL-FAST: No unwrap() in production code (constitution.yaml)</constraint>
    <constraint id="C10">Use Arc&lt;RwLock&lt;T&gt;&gt; pattern for shared state (constitution.yaml)</constraint>
  </constraints>
</definition_of_done>

<cargo_dependencies>
<!-- ADD these to crates/context-graph-embeddings/Cargo.toml -->
```toml
[dependencies]
# ... existing deps ...
linked-hash-map = "0.5"   # O(1) LRU operations
bincode = "1.3"           # Fast binary serialization for persistence
```
</cargo_dependencies>

<module_exports>
<!-- UPDATE crates/context-graph-embeddings/src/cache/mod.rs -->
```rust
pub mod types;
pub mod manager;  // ADD THIS LINE

pub use types::{CacheKey, CacheEntry};
pub use manager::{CacheManager, CacheMetrics};  // ADD THIS LINE
```
</module_exports>

<implementation_notes>
LinkedHashMap from linked-hash-map crate provides O(1) operations with LRU semantics:
- get() moves entry to end (most recently used)
- Eviction removes from front (least recently used)

For TTL expiration:
- Check entry.created_at + ttl_seconds against current time in get()
- Remove expired entries lazily on access

Disk persistence format:
- Header: magic bytes [0x43, 0x47, 0x45, 0x43], version u8, entry_count u64
- Entries: bincode-serialized Vec&lt;(CacheKey, CacheEntry)&gt;
- Footer: xxhash64 checksum of all preceding bytes

Error handling (FAIL-FAST):
- Use ? operator for all fallible operations
- Log errors with tracing::error! before returning
- Never use unwrap() or expect() in production paths
</implementation_notes>

<validation_criteria>
  <criterion id="V1">cargo check passes</criterion>
  <criterion id="V2">cargo clippy passes without warnings</criterion>
  <criterion id="V3">Unit test: put/get round-trip works correctly</criterion>
  <criterion id="V4">Unit test: LRU eviction removes oldest entry first</criterion>
  <criterion id="V5">Unit test: max_entries limit enforced</criterion>
  <criterion id="V6">Unit test: max_bytes limit enforced</criterion>
  <criterion id="V7">Unit test: TTL expiration returns None for expired entries</criterion>
  <criterion id="V8">Unit test: hit_rate calculation accurate</criterion>
  <criterion id="V9">Integration test: persist/load round-trip preserves all entries</criterion>
  <criterion id="V10">Benchmark: get() latency &lt;100μs (measure with criterion)</criterion>
</validation_criteria>

<edge_case_audit>
  <edge_case id="EC1">
    <scenario>Empty cache get()</scenario>
    <before_state>entries.len() == 0, metrics.hits == 0, metrics.misses == 0</before_state>
    <action>cache.get(&amp;CacheKey(12345))</action>
    <after_state>Returns None, metrics.misses == 1, entries.len() == 0</after_state>
    <verification>assert!(cache.get(&amp;key).is_none()); assert_eq!(cache.metrics.misses.load(Ordering::Relaxed), 1);</verification>
  </edge_case>

  <edge_case id="EC2">
    <scenario>Put at max_entries capacity</scenario>
    <before_state>entries.len() == config.max_entries, oldest_key = first entry key</before_state>
    <action>cache.put(new_key, new_embedding)</action>
    <after_state>entries.len() == config.max_entries, oldest_key removed, new_key present, metrics.evictions += 1</after_state>
    <verification>assert!(!cache.contains(&amp;oldest_key)); assert!(cache.contains(&amp;new_key)); assert_eq!(cache.len(), config.max_entries);</verification>
  </edge_case>

  <edge_case id="EC3">
    <scenario>Get expired TTL entry</scenario>
    <before_state>Entry exists with created_at 2 seconds ago, config.ttl_seconds = Some(1)</before_state>
    <action>cache.get(&amp;key)</action>
    <after_state>Returns None, entry removed from cache, metrics.misses += 1</after_state>
    <verification>assert!(cache.get(&amp;key).is_none()); assert!(!cache.contains(&amp;key));</verification>
  </edge_case>
</edge_case_audit>

<test_requirements>
  <requirement>NO MOCK DATA: All tests use real FusedEmbedding instances with actual 1536D vectors</requirement>
  <requirement>Use rand crate to generate realistic f32 values in [-1.0, 1.0] range</requirement>
  <requirement>Test helper: fn create_test_embedding() -&gt; FusedEmbedding that creates real data</requirement>
  <requirement>Integration tests must use actual file I/O for persist/load tests</requirement>
  <requirement>Benchmark tests must measure real latency, not simulated</requirement>
</test_requirements>

<execute_and_inspect>
  <step id="E1">
    <command>cargo test -p context-graph-embeddings cache::manager --nocapture</command>
    <expected_output>All tests pass with visible println! showing actual cache state</expected_output>
  </step>
  <step id="E2">
    <command>cargo bench -p context-graph-embeddings cache_get</command>
    <expected_output>get() latency reported as &lt; 100μs (e.g., "time: [45.123 μs 46.789 μs 48.012 μs]")</expected_output>
  </step>
  <step id="E3">
    <command>ls -la /tmp/context-graph-cache-test.bin</command>
    <expected_output>Persistence file exists after persist() test, size &gt; 0 bytes</expected_output>
  </step>
</execute_and_inspect>

<evidence_of_success>
  <log_requirement>
    Tests MUST include println! statements showing actual data:
    ```rust
    println!("Cache state after put: len={}, bytes={}, hit_rate={:.2}%",
             cache.len(), cache.memory_usage(), cache.hit_rate() * 100.0);
    println!("Eviction triggered: removed key {:?}, new len={}", evicted_key, cache.len());
    println!("Persist complete: wrote {} entries to {:?}", count, path);
    ```
  </log_requirement>

  <metric_verification>
    After test run, verify in terminal:
    - Total tests: &gt;= 10
    - All tests PASSED
    - No clippy warnings
    - Benchmark shows latency &lt; 100μs
  </metric_verification>
</evidence_of_success>

<final_verification>
  <sherlock_holmes_audit>
    After implementation, spawn sherlock-holmes subagent with prompt:
    "FORENSIC AUDIT of crates/context-graph-embeddings/src/cache/manager.rs:
    1. Verify ALL methods from signatures section are implemented
    2. Verify NO unwrap() or expect() in non-test code
    3. Verify LRU eviction removes OLDEST entry (front of LinkedHashMap)
    4. Verify memory tracking updates bytes_used on put/remove
    5. Verify persist/load includes checksum validation
    6. Verify all error paths use tracing::error! before returning Err
    7. Cross-reference with types.rs to ensure CacheEntry.memory_size() is used
    Report: GUILTY (bugs found) or INNOCENT (implementation correct)"
  </sherlock_holmes_audit>
</final_verification>

</task_spec>
