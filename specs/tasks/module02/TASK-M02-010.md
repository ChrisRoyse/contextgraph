# TASK-M02-010: Define GraphEdge Struct with Marblestone Fields

## TASK STATUS: READY

## CRITICAL CONTEXT FOR IMPLEMENTING AGENT

**READ THIS FIRST**: A basic `GraphEdge` struct already exists in `crates/context-graph-core/src/types/graph_edge.rs`. This task requires **enhancing** that struct to include all 13 Marblestone architecture fields AND moving the `EdgeId` type alias to `marblestone.rs` alongside the other Marblestone types. The existing struct in `graph_edge.rs` should be **REPLACED** with the complete version that uses all Marblestone fields.

**NO BACKWARDS COMPATIBILITY** - If the old struct is incompatible, remove it completely and replace with the new one.

---

## 1. Current Codebase State (Verified 2025-12-31)

### 1.1 Existing GraphEdge (TO BE REPLACED)
**File**: `crates/context-graph-core/src/types/graph_edge.rs` (lines 17-39)

```rust
// CURRENT STATE - 7 fields, missing Marblestone fields
pub type EdgeId = Uuid;

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct GraphEdge {
    pub id: EdgeId,
    pub source: NodeId,          // Field name differs from spec
    pub target: NodeId,          // Field name differs from spec
    pub edge_type: EdgeType,
    pub weight: f32,
    pub created_at: DateTime<Utc>,
    pub metadata: EdgeMetadata,  // Not in spec - REMOVE
}
```

**ISSUES WITH CURRENT STRUCT**:
1. Missing `source_id` / `target_id` naming (currently `source` / `target`)
2. Missing `confidence` field [0.0, 1.0]
3. Missing `domain: Domain` field
4. Missing `neurotransmitter_weights: NeurotransmitterWeights` field
5. Missing `is_amortized_shortcut: bool` field
6. Missing `steering_reward: f32` field [-1.0, 1.0]
7. Missing `traversal_count: u64` field
8. Missing `last_traversed_at: Option<DateTime<Utc>>` field
9. Has `metadata: EdgeMetadata` which is NOT in the specification - REMOVE
10. EdgeId should be in marblestone.rs with other Marblestone types

### 1.2 Dependencies (ALL VERIFIED COMPLETE)
| Task | Type | Location | Status |
|------|------|----------|--------|
| TASK-M02-007 | Domain enum | `marblestone.rs:35-141` | ✅ COMPLETE |
| TASK-M02-008 | NeurotransmitterWeights | `marblestone.rs:143-310` | ✅ COMPLETE |
| TASK-M02-009 | EdgeType enum | `marblestone.rs:312-407` | ✅ COMPLETE |

### 1.3 NodeId Type Location
**File**: `crates/context-graph-core/src/types/memory_node.rs` (line 12)
```rust
pub type NodeId = Uuid;
```

### 1.4 Constitution Reference (Source of Truth)
From `docs2/constitution.yaml` lines 170-184:
```yaml
edge_model:
  attrs: [source:UUID, target:UUID, type:Semantic|Temporal|Causal|Hierarchical|Relational, weight:[0,1], confidence:[0,1]]
  nt_weights:
    formula: "w_eff = base × (1 + excitatory - inhibitory + 0.5×modulatory)"
    excitatory: "[0,1] strengthen"
    inhibitory: "[0,1] weaken"
    modulatory: "[0,1] domain-adjust"
    domain: Code|Legal|Medical|Creative|Research|General
  amortized:
    trigger: "3+ hop path traversed ≥5×"
    weight: "product(path_weights)"
    confidence: "≥0.7"
  steering_reward: "[-1,1]"
```

From `docs2/contextprd.md` Section 4.2:
```
source,target:UUID, edge_type:Semantic|Temporal|Causal|Hierarchical|Relational,
weight,confidence:f32[0,1], nt_weights:{excitatory,inhibitory,modulatory}[0,1],
is_amortized_shortcut:bool, steering_reward:f32[-1,1],
domain:Code|Legal|Medical|Creative|Research|General
```

---

## 2. Exact Implementation Requirements

### 2.1 Add EdgeId Type Alias to marblestone.rs

**File**: `crates/context-graph-core/src/marblestone.rs`
**Location**: After imports, before Domain enum (around line 11)

```rust
use chrono::{DateTime, Utc};
use uuid::Uuid;

// Add this new import at the top of the file
// (memory_node module provides NodeId type)

/// Type alias for edge identifiers (UUID v4).
pub type EdgeId = Uuid;
```

### 2.2 Replace GraphEdge Struct in graph_edge.rs

**File**: `crates/context-graph-core/src/types/graph_edge.rs`

**REPLACE the entire file with**:

```rust
//! Graph edge connecting two memory nodes with Marblestone architecture support.
//!
//! This module provides the GraphEdge struct which represents directed relationships
//! between MemoryNodes in the Context Graph. It implements the Marblestone architecture
//! features for neurotransmitter-based weight modulation, amortized shortcuts, and
//! steering rewards.
//!
//! # Constitution Reference
//! - edge_model: Full edge specification
//! - edge_model.nt_weights: Neurotransmitter modulation formula
//! - edge_model.amortized: Shortcut learning criteria
//! - edge_model.steering_reward: [-1,1] reward signal

use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use uuid::Uuid;

use super::NodeId;
use crate::marblestone::{Domain, EdgeType, NeurotransmitterWeights};

/// Type alias for edge identifiers (UUID v4).
pub type EdgeId = Uuid;

/// A directed edge between two nodes in the Context Graph.
///
/// Implements Marblestone architecture features:
/// - Neurotransmitter-based weight modulation
/// - Amortized shortcuts (learned during dream consolidation)
/// - Steering rewards for reinforcement learning
///
/// # Fields
/// All 13 fields per PRD Section 4.2 and constitution.yaml edge_model:
/// - `id`: Unique edge identifier (UUID v4)
/// - `source_id`: Source node UUID
/// - `target_id`: Target node UUID
/// - `edge_type`: Relationship type (Semantic|Temporal|Causal|Hierarchical)
/// - `weight`: Base edge weight [0.0, 1.0]
/// - `confidence`: Confidence in validity [0.0, 1.0]
/// - `domain`: Knowledge domain for context-aware retrieval
/// - `neurotransmitter_weights`: NT modulation weights
/// - `is_amortized_shortcut`: True if learned during dream consolidation
/// - `steering_reward`: Steering Subsystem feedback [-1.0, 1.0]
/// - `traversal_count`: Number of times edge was traversed
/// - `created_at`: Creation timestamp
/// - `last_traversed_at`: Last traversal timestamp (None until first traversal)
///
/// # Performance Characteristics
/// - Serialized size: ~200 bytes
/// - Traversal latency target: <50μs
///
/// # Example
/// ```rust
/// use context_graph_core::types::GraphEdge;
/// use context_graph_core::marblestone::{Domain, EdgeType, NeurotransmitterWeights};
/// use uuid::Uuid;
///
/// let source = Uuid::new_v4();
/// let target = Uuid::new_v4();
///
/// // Create edge with all Marblestone fields
/// let edge = GraphEdge {
///     id: Uuid::new_v4(),
///     source_id: source,
///     target_id: target,
///     edge_type: EdgeType::Causal,
///     weight: 0.8,
///     confidence: 0.9,
///     domain: Domain::Code,
///     neurotransmitter_weights: NeurotransmitterWeights::for_domain(Domain::Code),
///     is_amortized_shortcut: false,
///     steering_reward: 0.0,
///     traversal_count: 0,
///     created_at: chrono::Utc::now(),
///     last_traversed_at: None,
/// };
///
/// assert!(edge.weight >= 0.0 && edge.weight <= 1.0);
/// assert!(edge.confidence >= 0.0 && edge.confidence <= 1.0);
/// assert!(edge.steering_reward >= -1.0 && edge.steering_reward <= 1.0);
/// ```
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct GraphEdge {
    /// Unique identifier for this edge (UUID v4).
    pub id: EdgeId,

    /// Source node ID (edge starts here).
    pub source_id: NodeId,

    /// Target node ID (edge ends here).
    pub target_id: NodeId,

    /// Type of relationship this edge represents.
    pub edge_type: EdgeType,

    /// Base weight of the edge [0.0, 1.0].
    /// Higher weight = stronger connection.
    pub weight: f32,

    /// Confidence in this edge's validity [0.0, 1.0].
    /// Higher confidence = more reliable relationship.
    pub confidence: f32,

    /// Knowledge domain this edge belongs to.
    /// Used for context-aware retrieval weighting.
    pub domain: Domain,

    /// Neurotransmitter weights for modulation.
    /// Applied via: w_eff = base × (1 + excitatory - inhibitory + 0.5×modulatory)
    pub neurotransmitter_weights: NeurotransmitterWeights,

    /// Whether this edge is an amortized shortcut (learned during dreams).
    /// Shortcuts are created when 3+ hop paths are traversed ≥5 times.
    pub is_amortized_shortcut: bool,

    /// Steering reward signal from the Steering Subsystem [-1.0, 1.0].
    /// Positive = reinforce, Negative = discourage, Zero = neutral.
    pub steering_reward: f32,

    /// Number of times this edge has been traversed.
    /// Used for amortized shortcut detection.
    pub traversal_count: u64,

    /// Timestamp when this edge was created.
    pub created_at: DateTime<Utc>,

    /// Timestamp when this edge was last traversed.
    /// None until the first traversal occurs.
    pub last_traversed_at: Option<DateTime<Utc>>,
}

#[cfg(test)]
mod tests {
    use super::*;
    use chrono::Utc;

    // =========================================================================
    // Struct Field Existence Tests
    // =========================================================================

    #[test]
    fn test_graph_edge_has_all_13_fields() {
        let source = Uuid::new_v4();
        let target = Uuid::new_v4();

        // This test verifies all 13 fields compile and are accessible
        let edge = GraphEdge {
            id: Uuid::new_v4(),
            source_id: source,
            target_id: target,
            edge_type: EdgeType::Semantic,
            weight: 0.5,
            confidence: 0.8,
            domain: Domain::General,
            neurotransmitter_weights: NeurotransmitterWeights::default(),
            is_amortized_shortcut: false,
            steering_reward: 0.0,
            traversal_count: 0,
            created_at: Utc::now(),
            last_traversed_at: None,
        };

        // Verify all fields are accessible
        let _id: EdgeId = edge.id;
        let _src: NodeId = edge.source_id;
        let _tgt: NodeId = edge.target_id;
        let _et: EdgeType = edge.edge_type;
        let _w: f32 = edge.weight;
        let _c: f32 = edge.confidence;
        let _d: Domain = edge.domain;
        let _nt: NeurotransmitterWeights = edge.neurotransmitter_weights;
        let _short: bool = edge.is_amortized_shortcut;
        let _sr: f32 = edge.steering_reward;
        let _tc: u64 = edge.traversal_count;
        let _ca: DateTime<Utc> = edge.created_at;
        let _lt: Option<DateTime<Utc>> = edge.last_traversed_at;
    }

    #[test]
    fn test_edge_id_is_uuid() {
        let edge_id: EdgeId = Uuid::new_v4();
        assert_eq!(edge_id.get_version_num(), 4);
    }

    // =========================================================================
    // Field Type Tests
    // =========================================================================

    #[test]
    fn test_source_id_is_node_id() {
        let source: NodeId = Uuid::new_v4();
        let edge = create_test_edge();
        let _: NodeId = edge.source_id;
        assert_ne!(source, edge.source_id); // Just verifying type compatibility
    }

    #[test]
    fn test_target_id_is_node_id() {
        let edge = create_test_edge();
        let _: NodeId = edge.target_id;
    }

    #[test]
    fn test_edge_type_uses_marblestone_enum() {
        let edge = create_test_edge();
        // Verify it's the Marblestone EdgeType (has default_weight method)
        let _weight = edge.edge_type.default_weight();
    }

    #[test]
    fn test_domain_uses_marblestone_enum() {
        let edge = create_test_edge();
        // Verify it's the Marblestone Domain (has description method)
        let _desc = edge.domain.description();
    }

    #[test]
    fn test_nt_weights_uses_marblestone_struct() {
        let edge = create_test_edge();
        // Verify it's the Marblestone NeurotransmitterWeights
        let _eff = edge.neurotransmitter_weights.compute_effective_weight(0.5);
    }

    // =========================================================================
    // Serde Serialization Tests
    // =========================================================================

    #[test]
    fn test_serde_roundtrip() {
        let edge = create_test_edge();
        let json = serde_json::to_string(&edge).expect("serialize failed");
        let restored: GraphEdge = serde_json::from_str(&json).expect("deserialize failed");
        assert_eq!(edge, restored);
    }

    #[test]
    fn test_serde_json_contains_all_fields() {
        let edge = create_test_edge();
        let json = serde_json::to_string(&edge).unwrap();

        // Verify all field names appear in JSON
        assert!(json.contains("\"id\""), "JSON missing id field");
        assert!(json.contains("\"source_id\""), "JSON missing source_id field");
        assert!(json.contains("\"target_id\""), "JSON missing target_id field");
        assert!(json.contains("\"edge_type\""), "JSON missing edge_type field");
        assert!(json.contains("\"weight\""), "JSON missing weight field");
        assert!(json.contains("\"confidence\""), "JSON missing confidence field");
        assert!(json.contains("\"domain\""), "JSON missing domain field");
        assert!(json.contains("\"neurotransmitter_weights\""), "JSON missing neurotransmitter_weights field");
        assert!(json.contains("\"is_amortized_shortcut\""), "JSON missing is_amortized_shortcut field");
        assert!(json.contains("\"steering_reward\""), "JSON missing steering_reward field");
        assert!(json.contains("\"traversal_count\""), "JSON missing traversal_count field");
        assert!(json.contains("\"created_at\""), "JSON missing created_at field");
        assert!(json.contains("\"last_traversed_at\""), "JSON missing last_traversed_at field");
    }

    #[test]
    fn test_serde_with_last_traversed_at_some() {
        let mut edge = create_test_edge();
        edge.last_traversed_at = Some(Utc::now());

        let json = serde_json::to_string(&edge).unwrap();
        let restored: GraphEdge = serde_json::from_str(&json).unwrap();

        assert!(restored.last_traversed_at.is_some());
    }

    #[test]
    fn test_serde_with_last_traversed_at_none() {
        let edge = create_test_edge();
        assert!(edge.last_traversed_at.is_none());

        let json = serde_json::to_string(&edge).unwrap();
        let restored: GraphEdge = serde_json::from_str(&json).unwrap();

        assert!(restored.last_traversed_at.is_none());
    }

    #[test]
    fn test_serde_edge_type_snake_case() {
        let mut edge = create_test_edge();
        edge.edge_type = EdgeType::Hierarchical;

        let json = serde_json::to_string(&edge).unwrap();
        assert!(json.contains("\"hierarchical\""), "EdgeType should serialize to snake_case");
    }

    #[test]
    fn test_serde_domain_snake_case() {
        let mut edge = create_test_edge();
        edge.domain = Domain::Medical;

        let json = serde_json::to_string(&edge).unwrap();
        assert!(json.contains("\"medical\""), "Domain should serialize to snake_case");
    }

    // =========================================================================
    // Derive Trait Tests
    // =========================================================================

    #[test]
    fn test_debug_format() {
        let edge = create_test_edge();
        let debug = format!("{:?}", edge);
        assert!(debug.contains("GraphEdge"));
        assert!(debug.contains("source_id"));
        assert!(debug.contains("target_id"));
    }

    #[test]
    fn test_clone() {
        let edge = create_test_edge();
        let cloned = edge.clone();
        assert_eq!(edge, cloned);
    }

    #[test]
    fn test_partial_eq() {
        let edge1 = create_test_edge();
        let edge2 = edge1.clone();
        assert_eq!(edge1, edge2);

        let mut edge3 = edge1.clone();
        edge3.weight = 0.9;
        assert_ne!(edge1, edge3);
    }

    // =========================================================================
    // Field Value Range Tests
    // =========================================================================

    #[test]
    fn test_weight_boundary_zero() {
        let mut edge = create_test_edge();
        edge.weight = 0.0;
        assert_eq!(edge.weight, 0.0);
    }

    #[test]
    fn test_weight_boundary_one() {
        let mut edge = create_test_edge();
        edge.weight = 1.0;
        assert_eq!(edge.weight, 1.0);
    }

    #[test]
    fn test_confidence_boundary_zero() {
        let mut edge = create_test_edge();
        edge.confidence = 0.0;
        assert_eq!(edge.confidence, 0.0);
    }

    #[test]
    fn test_confidence_boundary_one() {
        let mut edge = create_test_edge();
        edge.confidence = 1.0;
        assert_eq!(edge.confidence, 1.0);
    }

    #[test]
    fn test_steering_reward_boundary_negative_one() {
        let mut edge = create_test_edge();
        edge.steering_reward = -1.0;
        assert_eq!(edge.steering_reward, -1.0);
    }

    #[test]
    fn test_steering_reward_boundary_positive_one() {
        let mut edge = create_test_edge();
        edge.steering_reward = 1.0;
        assert_eq!(edge.steering_reward, 1.0);
    }

    #[test]
    fn test_steering_reward_zero_is_neutral() {
        let edge = create_test_edge();
        assert_eq!(edge.steering_reward, 0.0);
    }

    #[test]
    fn test_traversal_count_starts_at_zero() {
        let edge = create_test_edge();
        assert_eq!(edge.traversal_count, 0);
    }

    #[test]
    fn test_is_amortized_shortcut_defaults_false() {
        let edge = create_test_edge();
        assert!(!edge.is_amortized_shortcut);
    }

    #[test]
    fn test_is_amortized_shortcut_can_be_true() {
        let mut edge = create_test_edge();
        edge.is_amortized_shortcut = true;
        assert!(edge.is_amortized_shortcut);
    }

    // =========================================================================
    // All EdgeType Variants Test
    // =========================================================================

    #[test]
    fn test_all_edge_types_work() {
        for edge_type in EdgeType::all() {
            let mut edge = create_test_edge();
            edge.edge_type = edge_type;

            let json = serde_json::to_string(&edge).unwrap();
            let restored: GraphEdge = serde_json::from_str(&json).unwrap();
            assert_eq!(restored.edge_type, edge_type);
        }
    }

    // =========================================================================
    // All Domain Variants Test
    // =========================================================================

    #[test]
    fn test_all_domains_work() {
        for domain in Domain::all() {
            let mut edge = create_test_edge();
            edge.domain = domain;
            edge.neurotransmitter_weights = NeurotransmitterWeights::for_domain(domain);

            let json = serde_json::to_string(&edge).unwrap();
            let restored: GraphEdge = serde_json::from_str(&json).unwrap();
            assert_eq!(restored.domain, domain);
        }
    }

    // =========================================================================
    // Timestamp Tests
    // =========================================================================

    #[test]
    fn test_created_at_is_required() {
        let edge = create_test_edge();
        let _: DateTime<Utc> = edge.created_at;
    }

    #[test]
    fn test_timestamps_preserved_through_serde() {
        let edge = create_test_edge();
        let original_created = edge.created_at;

        let json = serde_json::to_string(&edge).unwrap();
        let restored: GraphEdge = serde_json::from_str(&json).unwrap();

        assert_eq!(restored.created_at, original_created);
    }

    // =========================================================================
    // UUID Tests
    // =========================================================================

    #[test]
    fn test_id_is_v4_uuid() {
        let edge = create_test_edge();
        assert_eq!(edge.id.get_version_num(), 4);
    }

    #[test]
    fn test_source_and_target_are_different() {
        let edge = create_test_edge();
        assert_ne!(edge.source_id, edge.target_id, "Source and target should be different UUIDs");
    }

    // =========================================================================
    // Helper Function
    // =========================================================================

    fn create_test_edge() -> GraphEdge {
        GraphEdge {
            id: Uuid::new_v4(),
            source_id: Uuid::new_v4(),
            target_id: Uuid::new_v4(),
            edge_type: EdgeType::Semantic,
            weight: 0.5,
            confidence: 0.8,
            domain: Domain::General,
            neurotransmitter_weights: NeurotransmitterWeights::default(),
            is_amortized_shortcut: false,
            steering_reward: 0.0,
            traversal_count: 0,
            created_at: Utc::now(),
            last_traversed_at: None,
        }
    }
}
```

### 2.3 Update lib.rs Re-exports (if needed)

**File**: `crates/context-graph-core/src/lib.rs`

Verify the re-exports include EdgeId from types:
```rust
// Current line 31 should already have:
pub use marblestone::{Domain, EdgeType, NeurotransmitterWeights};
```

The types module should export `EdgeId` and `GraphEdge`. Check `crates/context-graph-core/src/types/mod.rs` and ensure it re-exports from graph_edge.

---

## 3. File Changes Summary

| File | Action | Details |
|------|--------|---------|
| `crates/context-graph-core/src/types/graph_edge.rs` | REPLACE | Complete rewrite with 13-field struct + 30 tests |
| `crates/context-graph-core/src/types/mod.rs` | VERIFY | Ensure GraphEdge and EdgeId are exported |

---

## 4. Validation Commands (MUST ALL PASS)

```bash
# 1. Build the package
cargo build --package context-graph-core

# 2. Run all tests
cargo test --package context-graph-core -- --nocapture

# 3. Run only graph_edge tests
cargo test --package context-graph-core graph_edge -- --nocapture

# 4. Clippy must show 0 warnings
cargo clippy --package context-graph-core -- -D warnings

# 5. Verify field count in struct
grep -c "pub " crates/context-graph-core/src/types/graph_edge.rs | head -1
# Expected: Should show 13 for 13 public fields
```

**Expected Results**:
- Build: SUCCESS
- Tests: All pass (existing tests + 30 new graph_edge tests)
- Clippy: 0 warnings

---

## 5. Full State Verification Protocol (MANDATORY)

### 5.1 Source of Truth
The GraphEdge struct is the authoritative edge definition. After implementation:
- GraphEdge has exactly 13 public fields
- All Marblestone fields are present (neurotransmitter_weights, is_amortized_shortcut, steering_reward, domain)
- Field naming matches spec (source_id, target_id NOT source, target)
- EdgeMetadata is NOT present (removed)

### 5.2 Execute & Inspect Protocol
After implementing, run these verification steps:

```bash
# 1. Verify struct has 13 fields (count 'pub' in struct definition)
awk '/^pub struct GraphEdge/,/^}/' crates/context-graph-core/src/types/graph_edge.rs | grep -c "pub "
# Expected: 13

# 2. Verify OLD field names are GONE
grep -n "pub source:" crates/context-graph-core/src/types/graph_edge.rs
# Expected: NO OUTPUT

grep -n "pub target:" crates/context-graph-core/src/types/graph_edge.rs
# Expected: NO OUTPUT

# 3. Verify NEW field names exist
grep -n "pub source_id:" crates/context-graph-core/src/types/graph_edge.rs
# Expected: line number shown

grep -n "pub target_id:" crates/context-graph-core/src/types/graph_edge.rs
# Expected: line number shown

# 4. Verify Marblestone fields exist
grep -n "neurotransmitter_weights:" crates/context-graph-core/src/types/graph_edge.rs
grep -n "is_amortized_shortcut:" crates/context-graph-core/src/types/graph_edge.rs
grep -n "steering_reward:" crates/context-graph-core/src/types/graph_edge.rs
grep -n "domain:" crates/context-graph-core/src/types/graph_edge.rs

# 5. Verify EdgeMetadata is REMOVED
grep -n "EdgeMetadata" crates/context-graph-core/src/types/graph_edge.rs
# Expected: NO OUTPUT (struct removed) or only in old code if you kept backwards compat (DON'T)

# 6. Count test functions
grep -c "#\[test\]" crates/context-graph-core/src/types/graph_edge.rs
# Expected: 30 or more

# 7. Run tests and verify count
cargo test --package context-graph-core graph_edge 2>&1 | grep "passed"
# Expected: "30 passed" or similar
```

### 5.3 Boundary & Edge Case Audit (MANDATORY)

You MUST manually verify these 3 edge cases and print before/after state:

**Test Case 1: Weight boundaries**
```rust
// Verify weight field accepts [0.0, 1.0]
let mut edge = create_test_edge();
println!("BEFORE: weight = {}", edge.weight);
edge.weight = 0.0;
println!("AFTER (min): weight = {}", edge.weight);
edge.weight = 1.0;
println!("AFTER (max): weight = {}", edge.weight);
assert!(edge.weight >= 0.0 && edge.weight <= 1.0);
```

**Test Case 2: Steering reward boundaries**
```rust
// Verify steering_reward accepts [-1.0, 1.0]
let mut edge = create_test_edge();
println!("BEFORE: steering_reward = {}", edge.steering_reward);
edge.steering_reward = -1.0;
println!("AFTER (min): steering_reward = {}", edge.steering_reward);
edge.steering_reward = 1.0;
println!("AFTER (max): steering_reward = {}", edge.steering_reward);
assert!(edge.steering_reward >= -1.0 && edge.steering_reward <= 1.0);
```

**Test Case 3: Serde roundtrip with all domains**
```rust
// Verify each Domain variant survives serialization
for domain in Domain::all() {
    let mut edge = create_test_edge();
    edge.domain = domain;
    println!("BEFORE: domain = {:?}", edge.domain);
    let json = serde_json::to_string(&edge).unwrap();
    let restored: GraphEdge = serde_json::from_str(&json).unwrap();
    println!("AFTER: domain = {:?}", restored.domain);
    assert_eq!(edge.domain, restored.domain);
}
```

### 5.4 Evidence of Success Log
After all tests pass, capture this output:

```bash
cargo test --package context-graph-core graph_edge -- --nocapture 2>&1 | tee /tmp/graph_edge_test_output.txt
```

Expected output pattern:
```
test types::graph_edge::tests::test_graph_edge_has_all_13_fields ... ok
test types::graph_edge::tests::test_serde_roundtrip ... ok
test types::graph_edge::tests::test_all_domains_work ... ok
[... all 30 tests ...]
test result: ok. 30 passed; 0 failed; 0 ignored
```

---

## 6. Constraints & Anti-Patterns

### 6.1 Constitution Compliance
- `AP-009`: No NaN/Infinity - all f32 fields must be valid
- `naming.types`: PascalCase for struct (GraphEdge)
- `naming.vars`: snake_case for fields (source_id, not sourceId)
- `naming.json`: snake_case for serde

### 6.2 Anti-Patterns to Avoid
- ❌ DO NOT keep EdgeMetadata struct (not in spec)
- ❌ DO NOT use `source`/`target` - use `source_id`/`target_id`
- ❌ DO NOT add backwards compatibility shims
- ❌ DO NOT exceed 500 lines per module (excluding tests)
- ❌ DO NOT use mock data in tests - use real struct instantiation

---

## 7. Dependencies & Downstream Impact

### 7.1 Prerequisites (ALL VERIFIED COMPLETE)
- ✅ TASK-M02-007: Domain enum (marblestone.rs:35-141)
- ✅ TASK-M02-008: NeurotransmitterWeights (marblestone.rs:143-310)
- ✅ TASK-M02-009: EdgeType enum (marblestone.rs:312-407)

### 7.2 Downstream Tasks
After this task completes:
- TASK-M02-011 (GraphEdge methods) can proceed
- TASK-M02-018 (Edge CRUD operations) can use this struct
- All edge storage/retrieval will use this 13-field format

---

## 8. Final Verification: Sherlock-Holmes Audit (MANDATORY)

After completing all implementation, you MUST spawn a sherlock-holmes agent to verify:

1. **Field Count**: GraphEdge has exactly 13 fields
2. **Field Names**: Uses source_id/target_id (NOT source/target)
3. **Marblestone Fields**: neurotransmitter_weights, is_amortized_shortcut, steering_reward, domain all present
4. **No EdgeMetadata**: The old EdgeMetadata struct is REMOVED
5. **All Tests Pass**: 30+ graph_edge tests pass
6. **No Clippy Warnings**: cargo clippy produces 0 warnings
7. **Serde Works**: All field serialize/deserialize correctly

**Sherlock-Holmes Agent Prompt**:
```
FORENSIC INVESTIGATION: Verify TASK-M02-010 GraphEdge completion

EVIDENCE COLLECTION:
1. Read crates/context-graph-core/src/types/graph_edge.rs
2. Count public fields in GraphEdge struct (MUST be exactly 13)
3. Verify field names: source_id, target_id (NOT source, target)
4. Verify Marblestone fields exist: neurotransmitter_weights, is_amortized_shortcut, steering_reward, domain
5. Verify EdgeMetadata struct does NOT exist
6. Run: cargo test --package context-graph-core graph_edge -- verify 30+ tests pass
7. Run: cargo clippy --package context-graph-core -- verify 0 warnings

VERDICT CRITERIA:
- GUILTY (FAIL): Any missing fields, wrong names, failed tests, or clippy warnings
- INNOCENT (PASS): All 13 fields correct, all tests pass, 0 clippy warnings

Report your verdict with specific evidence for each check.
```

---

## 9. Success Criteria Checklist

- [ ] GraphEdge struct has exactly 13 public fields
- [ ] Field names are source_id/target_id (NOT source/target)
- [ ] EdgeId type alias defined
- [ ] weight field: f32 [0.0, 1.0]
- [ ] confidence field: f32 [0.0, 1.0]
- [ ] steering_reward field: f32 [-1.0, 1.0]
- [ ] domain field: Domain
- [ ] neurotransmitter_weights field: NeurotransmitterWeights
- [ ] is_amortized_shortcut field: bool (defaults false)
- [ ] traversal_count field: u64 (starts at 0)
- [ ] created_at field: DateTime<Utc>
- [ ] last_traversed_at field: Option<DateTime<Utc>> (initially None)
- [ ] EdgeMetadata struct REMOVED
- [ ] 30+ unit tests added and passing
- [ ] Serde roundtrip works for all fields
- [ ] cargo build succeeds
- [ ] cargo test succeeds
- [ ] cargo clippy shows 0 warnings
- [ ] Sherlock-Holmes verification complete

---

*Task ID: TASK-M02-010*
*Module: 02 - Core Infrastructure*
*Layer: Foundation*
*Estimated Hours: 2.0*
*Dependencies: TASK-M02-007 ✅, TASK-M02-008 ✅, TASK-M02-009 ✅*
*Last Updated: 2025-12-31*
