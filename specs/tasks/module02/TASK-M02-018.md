# TASK-M02-018: Implement Edge CRUD Operations

```xml
<task_spec id="TASK-M02-018" version="2.0">
<metadata>
  <title>Implement Edge CRUD Operations</title>
  <status>ready</status>
  <layer>logic</layer>
  <module>module-02</module>
  <sequence>18</sequence>
  <priority>high</priority>
  <estimated_hours>3</estimated_hours>
  <implements>
    <item>TECH-CORE-002 Section 3.2: RocksDB backend specification</item>
    <item>Marblestone Integration Spec: Edge storage with NT weights</item>
  </implements>
  <depends_on>
    <task_ref status="completed">TASK-M02-011 (GraphEdge Methods)</task_ref>
    <task_ref status="completed">TASK-M02-017 (Node CRUD Operations)</task_ref>
  </depends_on>
  <estimated_complexity>medium</estimated_complexity>
</metadata>

<context>
This task implements CRUD operations for GraphEdge storage, including efficient lookups for edges by source and target nodes. The implementation uses composite keys (source_id:target_id:edge_type) for efficient prefix scanning and must preserve all 13 Marblestone fields.

CRITICAL: This uses SYNCHRONOUS methods (NOT async) to match the existing Node CRUD pattern in rocksdb_backend.rs.
</context>

<input_context_files>
  <file purpose="GraphEdge struct definition (13 fields)" path="crates/context-graph-core/src/types/graph_edge.rs">
    - GraphEdge struct with 13 fields: id, source_id, target_id, edge_type, weight, confidence, domain, neurotransmitter_weights, is_amortized_shortcut, steering_reward, traversal_count, created_at, last_traversed_at
    - EdgeId = Uuid type alias
    - Methods: new(), with_weight(), get_modulated_weight(), apply_steering_reward(), decay_steering(), record_traversal(), is_reliable_shortcut(), mark_as_shortcut(), age_seconds()
    - Derives: Debug, Clone, PartialEq, Serialize, Deserialize
  </file>
  <file purpose="RocksDB backend with Node CRUD (SYNC pattern)" path="crates/context-graph-storage/src/rocksdb_backend.rs">
    - RocksDbMemex struct with db: DB, cache: Cache, path: String
    - SYNC methods (NOT async): store_node(), get_node(), update_node(), delete_node()
    - Uses WriteBatch for atomic operations
    - Helper functions: format_temporal_key(), format_tag_key(), format_source_key()
    - StorageError enum with NotFound, Serialization, ValidationFailed variants
  </file>
  <file purpose="Serialization functions (bincode for edges)" path="crates/context-graph-storage/src/serialization.rs">
    - serialize_edge() - uses bincode::serialize (NOT MessagePack)
    - deserialize_edge() - uses bincode::deserialize
    - serialize_uuid() - returns [u8; 16]
    - SerializationError enum
  </file>
  <file purpose="Column family definitions" path="crates/context-graph-storage/src/column_families.rs">
    - cf_names::EDGES = "edges"
    - cf_names::ALL contains all 12 CFs
  </file>
  <file purpose="lib.rs exports" path="crates/context-graph-storage/src/lib.rs">
    - Re-exports: serialize_edge, deserialize_edge, GraphEdge, EdgeType, Domain, NeurotransmitterWeights
  </file>
</input_context_files>

<prerequisites>
  <check status="verified">TASK-M02-011 (GraphEdge Methods) completed - GraphEdge struct exists with all 13 fields and methods</check>
  <check status="verified">TASK-M02-017 (Node CRUD Operations) completed - store_node, get_node, update_node, delete_node implemented</check>
  <check status="verified">serialize_edge/deserialize_edge exist in serialization.rs (using bincode)</check>
  <check status="verified">cf_names::EDGES defined in column_families.rs</check>
</prerequisites>

<scope>
  <in_scope>
    - store_edge() method - store GraphEdge with composite key (SYNC, not async)
    - get_edge() method - retrieve edge by source, target, and type
    - update_edge() method - update existing edge (same as store - RocksDB overwrites)
    - delete_edge() method - remove edge
    - get_edges_from() method - get all outgoing edges from a node (prefix scan)
    - get_edges_to() method - get all incoming edges to a node (full scan with filter)
    - Composite key format: 16-byte source_uuid + 16-byte target_uuid + 1-byte edge_type = 33 bytes
    - Prefix scan for efficient edge queries
    - All 13 GraphEdge fields preserved through serialization
  </in_scope>
  <out_of_scope>
    - Node CRUD operations (TASK-M02-017 - already done)
    - Edge weight calculations (TASK-M02-011 - already done)
    - Graph traversal algorithms (future module)
    - Memex trait abstraction (TASK-M02-026)
    - Reverse index for get_edges_to() (future optimization)
  </out_of_scope>
</scope>

<definition_of_done>
  <signatures>
    <signature file="crates/context-graph-storage/src/rocksdb_backend.rs">
// CRITICAL: These are SYNC methods (NOT async) - match existing Node CRUD pattern!

use crate::serialization::{deserialize_edge, serialize_edge};
use context_graph_core::marblestone::EdgeType;
use context_graph_core::types::GraphEdge;

impl RocksDbMemex {
    /// Stores a GraphEdge with composite key for efficient lookups.
    ///
    /// Key format: source_uuid_bytes (16) + target_uuid_bytes (16) + edge_type_byte (1) = 33 bytes
    /// Preserves all 13 Marblestone fields through bincode serialization.
    ///
    /// # Errors
    /// - `StorageError::Serialization` if serialization fails
    /// - `StorageError::WriteFailed` if RocksDB write fails
    pub fn store_edge(&amp;self, edge: &amp;GraphEdge) -> Result&lt;(), StorageError&gt;;

    /// Retrieves a GraphEdge by source, target, and edge type.
    ///
    /// # Errors
    /// - `StorageError::NotFound` if edge doesn't exist
    /// - `StorageError::Serialization` if deserialization fails
    /// - `StorageError::ReadFailed` if RocksDB read fails
    pub fn get_edge(
        &amp;self,
        source_id: &amp;NodeId,
        target_id: &amp;NodeId,
        edge_type: EdgeType,
    ) -> Result&lt;GraphEdge, StorageError&gt;;

    /// Updates an existing GraphEdge.
    /// Same as store - RocksDB overwrites existing keys.
    /// DOES NOT verify edge exists first (use get_edge if verification needed).
    pub fn update_edge(&amp;self, edge: &amp;GraphEdge) -> Result&lt;(), StorageError&gt;;

    /// Deletes a GraphEdge.
    ///
    /// # Errors
    /// - `StorageError::WriteFailed` if RocksDB delete fails
    /// Note: Does NOT return NotFound if edge doesn't exist (RocksDB delete is idempotent)
    pub fn delete_edge(
        &amp;self,
        source_id: &amp;NodeId,
        target_id: &amp;NodeId,
        edge_type: EdgeType,
    ) -> Result&lt;(), StorageError&gt;;

    /// Gets all outgoing edges from a source node.
    /// Uses prefix scan for efficiency - O(n) where n = number of outgoing edges.
    ///
    /// # Errors
    /// - `StorageError::Serialization` if any edge deserialization fails
    /// - `StorageError::ReadFailed` if RocksDB iteration fails
    pub fn get_edges_from(&amp;self, source_id: &amp;NodeId) -> Result&lt;Vec&lt;GraphEdge&gt;, StorageError&gt;;

    /// Gets all incoming edges to a target node.
    /// Uses full scan with filter - O(E) where E = total edges in database.
    /// Less efficient than get_edges_from() - no reverse index.
    ///
    /// # Errors
    /// - `StorageError::Serialization` if any edge deserialization fails
    /// - `StorageError::ReadFailed` if RocksDB iteration fails
    pub fn get_edges_to(&amp;self, target_id: &amp;NodeId) -> Result&lt;Vec&lt;GraphEdge&gt;, StorageError&gt;;
}

// Private helper functions (add after format_source_key):

/// Format edge key: 16-byte source_uuid + 16-byte target_uuid + 1-byte edge_type.
/// Total: 33 bytes. Uses big-endian UUID bytes for proper lexicographic ordering.
#[inline]
fn format_edge_key(source_id: &amp;NodeId, target_id: &amp;NodeId, edge_type: EdgeType) -> Vec&lt;u8&gt;;

/// Format edge prefix for source_id: just the 16-byte source_uuid.
/// Used for prefix scans to find all edges from a source.
#[inline]
fn format_edge_prefix(source_id: &amp;NodeId) -> Vec&lt;u8&gt;;
    </signature>
  </signatures>

  <constraints>
    - MUST use SYNC methods (NOT async) - match existing Node CRUD pattern
    - Composite key format: source_uuid (16 bytes) + target_uuid (16 bytes) + edge_type (1 byte) = 33 bytes
    - UUID bytes via serialize_uuid() which returns [u8; 16]
    - EdgeType serialized as u8 (0 = Semantic, 1 = Temporal, 2 = Causal, 3 = Hierarchical)
    - Use existing cf_names::EDGES column family
    - Use existing serialize_edge/deserialize_edge from serialization.rs
    - All 13 GraphEdge fields MUST be preserved through serialization round-trip
    - get_edges_to() uses full scan (no reverse index in this task)
    - NO backwards compatibility hacks - fail fast on errors
    - NO mock data in tests - use real GraphEdge instances
  </constraints>

  <verification>
    - cargo build --package context-graph-storage compiles without errors
    - cargo test --package context-graph-storage edge -- --nocapture passes all tests
    - cargo clippy --package context-graph-storage -- -D warnings passes
    - Store/get round-trip preserves all 13 GraphEdge fields
    - get_edges_from() correctly uses prefix scan
    - Multiple edges between same nodes with different types work correctly
    - Prefix scan correctly terminates when prefix no longer matches
  </verification>
</definition_of_done>

<pseudo_code>
// =========================================================================
// rocksdb_backend.rs ADDITIONS (after delete_node implementation)
// =========================================================================

// Add new imports at top of file:
use crate::serialization::{deserialize_edge, serialize_edge};
use context_graph_core::marblestone::EdgeType;
use context_graph_core::types::GraphEdge;
use rocksdb::IteratorMode;

// =========================================================================
// Private Helper Functions (add after format_source_key)
// =========================================================================

/// Format edge key: source_uuid (16) + target_uuid (16) + edge_type (1) = 33 bytes
#[inline]
fn format_edge_key(source_id: &amp;NodeId, target_id: &amp;NodeId, edge_type: EdgeType) -> Vec&lt;u8&gt; {
    let mut key = Vec::with_capacity(33);
    key.extend_from_slice(&amp;serialize_uuid(source_id));
    key.extend_from_slice(&amp;serialize_uuid(target_id));
    key.push(edge_type as u8);
    key
}

/// Format edge prefix for source_id: just the 16-byte source_uuid
#[inline]
fn format_edge_prefix(source_id: &amp;NodeId) -> Vec&lt;u8&gt; {
    serialize_uuid(source_id).to_vec()
}

// =========================================================================
// Edge CRUD Methods (add to impl RocksDbMemex block)
// =========================================================================

impl RocksDbMemex {
    // ... existing methods ...

    // =========================================================================
    // Edge CRUD Operations (TASK-M02-018)
    // =========================================================================

    pub fn store_edge(&amp;self, edge: &amp;GraphEdge) -> Result&lt;(), StorageError&gt; {
        println!("=== store_edge: edge.id={} ===", edge.id);
        println!("BEFORE: source={}, target={}, type={:?}",
            edge.source_id, edge.target_id, edge.edge_type);

        let cf_edges = self.get_cf(cf_names::EDGES)?;
        let key = format_edge_key(&amp;edge.source_id, &amp;edge.target_id, edge.edge_type);
        let value = serialize_edge(edge)?;

        self.db.put_cf(cf_edges, &amp;key, &amp;value)
            .map_err(|e| StorageError::WriteFailed(e.to_string()))?;

        println!("AFTER: Stored {} bytes at key ({} bytes)", value.len(), key.len());
        Ok(())
    }

    pub fn get_edge(
        &amp;self,
        source_id: &amp;NodeId,
        target_id: &amp;NodeId,
        edge_type: EdgeType,
    ) -> Result&lt;GraphEdge, StorageError&gt; {
        println!("=== get_edge: source={}, target={}, type={:?} ===",
            source_id, target_id, edge_type);

        let cf_edges = self.get_cf(cf_names::EDGES)?;
        let key = format_edge_key(source_id, target_id, edge_type);

        let value = self.db.get_cf(cf_edges, &amp;key)
            .map_err(|e| StorageError::ReadFailed(e.to_string()))?
            .ok_or_else(|| StorageError::NotFound {
                id: format!("edge:{}:{}:{:?}", source_id, target_id, edge_type),
            })?;

        let edge = deserialize_edge(&amp;value)?;
        println!("AFTER: Retrieved edge.id={}", edge.id);
        Ok(edge)
    }

    pub fn update_edge(&amp;self, edge: &amp;GraphEdge) -> Result&lt;(), StorageError&gt; {
        // Same as store - RocksDB overwrites existing keys
        self.store_edge(edge)
    }

    pub fn delete_edge(
        &amp;self,
        source_id: &amp;NodeId,
        target_id: &amp;NodeId,
        edge_type: EdgeType,
    ) -> Result&lt;(), StorageError&gt; {
        println!("=== delete_edge: source={}, target={}, type={:?} ===",
            source_id, target_id, edge_type);

        let cf_edges = self.get_cf(cf_names::EDGES)?;
        let key = format_edge_key(source_id, target_id, edge_type);

        self.db.delete_cf(cf_edges, &amp;key)
            .map_err(|e| StorageError::WriteFailed(e.to_string()))?;

        println!("AFTER: Deleted edge");
        Ok(())
    }

    pub fn get_edges_from(&amp;self, source_id: &amp;NodeId) -> Result&lt;Vec&lt;GraphEdge&gt;, StorageError&gt; {
        println!("=== get_edges_from: source={} ===", source_id);

        let cf_edges = self.get_cf(cf_names::EDGES)?;
        let prefix = format_edge_prefix(source_id);
        let mut edges = Vec::new();

        // Use prefix iterator
        let iter = self.db.prefix_iterator_cf(cf_edges, &amp;prefix);

        for item in iter {
            let (key, value) = item.map_err(|e| StorageError::ReadFailed(e.to_string()))?;

            // Check that key still starts with our prefix (RocksDB may return more)
            if !key.starts_with(&amp;prefix) {
                break;
            }

            let edge = deserialize_edge(&amp;value)?;
            edges.push(edge);
        }

        println!("AFTER: Found {} outgoing edges", edges.len());
        Ok(edges)
    }

    pub fn get_edges_to(&amp;self, target_id: &amp;NodeId) -> Result&lt;Vec&lt;GraphEdge&gt;, StorageError&gt; {
        println!("=== get_edges_to: target={} ===", target_id);

        let cf_edges = self.get_cf(cf_names::EDGES)?;
        let mut edges = Vec::new();

        // Full scan with filter (no reverse index)
        let iter = self.db.iterator_cf(cf_edges, IteratorMode::Start);

        for item in iter {
            let (_key, value) = item.map_err(|e| StorageError::ReadFailed(e.to_string()))?;
            let edge = deserialize_edge(&amp;value)?;

            if &amp;edge.target_id == target_id {
                edges.push(edge);
            }
        }

        println!("AFTER: Found {} incoming edges", edges.len());
        Ok(edges)
    }
}
</pseudo_code>

<tests>
// =========================================================================
// REQUIRED TESTS - Use REAL data, NO MOCKS
// All tests must print BEFORE/AFTER state for evidence
// =========================================================================

#[cfg(test)]
mod edge_crud_tests {
    use super::*;
    use context_graph_core::marblestone::{Domain, EdgeType, NeurotransmitterWeights};
    use context_graph_core::types::GraphEdge;
    use tempfile::TempDir;
    use uuid::Uuid;

    fn create_temp_db() -> (TempDir, RocksDbMemex) {
        let tmp = TempDir::new().expect("create temp dir");
        let db = RocksDbMemex::open(tmp.path()).expect("open failed");
        (tmp, db)
    }

    /// Create a REAL GraphEdge with all 13 fields populated
    fn create_test_edge() -> GraphEdge {
        GraphEdge::new(
            Uuid::new_v4(),
            Uuid::new_v4(),
            EdgeType::Semantic,
            Domain::Code,
        )
    }

    fn create_test_edge_between(source: Uuid, target: Uuid, edge_type: EdgeType) -> GraphEdge {
        GraphEdge::new(source, target, edge_type, Domain::Code)
    }

    // =========================================================================
    // store_edge Tests
    // =========================================================================

    #[test]
    fn test_store_edge_basic() {
        println!("=== TEST: store_edge basic operation ===");
        let (_tmp, db) = create_temp_db();
        let edge = create_test_edge();

        println!("BEFORE: Storing edge {}", edge.id);
        let result = db.store_edge(&amp;edge);
        println!("AFTER: Store result = {:?}", result.is_ok());

        assert!(result.is_ok(), "store_edge should succeed");
    }

    #[test]
    fn test_store_and_get_edge_roundtrip() {
        println!("=== TEST: store_edge + get_edge roundtrip ===");
        let (_tmp, db) = create_temp_db();
        let edge = create_test_edge();

        println!("BEFORE: Storing edge with id={}", edge.id);
        println!("  source_id={}", edge.source_id);
        println!("  target_id={}", edge.target_id);
        println!("  edge_type={:?}", edge.edge_type);

        db.store_edge(&amp;edge).expect("store failed");

        let retrieved = db.get_edge(&amp;edge.source_id, &amp;edge.target_id, edge.edge_type)
            .expect("get failed");

        println!("AFTER: Retrieved edge id={}", retrieved.id);

        // Verify ALL 13 fields preserved
        assert_eq!(edge.id, retrieved.id, "id mismatch");
        assert_eq!(edge.source_id, retrieved.source_id, "source_id mismatch");
        assert_eq!(edge.target_id, retrieved.target_id, "target_id mismatch");
        assert_eq!(edge.edge_type, retrieved.edge_type, "edge_type mismatch");
        assert_eq!(edge.weight, retrieved.weight, "weight mismatch");
        assert_eq!(edge.confidence, retrieved.confidence, "confidence mismatch");
        assert_eq!(edge.domain, retrieved.domain, "domain mismatch");
        assert_eq!(edge.neurotransmitter_weights, retrieved.neurotransmitter_weights, "NT weights mismatch");
        assert_eq!(edge.is_amortized_shortcut, retrieved.is_amortized_shortcut, "amortized mismatch");
        assert_eq!(edge.steering_reward, retrieved.steering_reward, "steering mismatch");
        assert_eq!(edge.traversal_count, retrieved.traversal_count, "traversal mismatch");
        assert_eq!(edge.created_at, retrieved.created_at, "created_at mismatch");
        assert_eq!(edge.last_traversed_at, retrieved.last_traversed_at, "last_traversed mismatch");

        println!("RESULT: All 13 fields preserved ✓");
    }

    #[test]
    fn test_store_edge_with_all_marblestone_fields() {
        println!("=== TEST: store_edge preserves Marblestone fields ===");
        let (_tmp, db) = create_temp_db();

        let mut edge = create_test_edge();
        edge.weight = 0.85;
        edge.confidence = 0.95;
        edge.is_amortized_shortcut = true;
        edge.steering_reward = 0.75;
        edge.traversal_count = 42;
        edge.neurotransmitter_weights = NeurotransmitterWeights::for_domain(Domain::Medical);
        edge.record_traversal();

        println!("BEFORE: Marblestone fields set:");
        println!("  weight={}", edge.weight);
        println!("  confidence={}", edge.confidence);
        println!("  is_amortized_shortcut={}", edge.is_amortized_shortcut);
        println!("  steering_reward={}", edge.steering_reward);
        println!("  traversal_count={}", edge.traversal_count);
        println!("  last_traversed_at={:?}", edge.last_traversed_at);

        db.store_edge(&amp;edge).expect("store failed");
        let retrieved = db.get_edge(&amp;edge.source_id, &amp;edge.target_id, edge.edge_type)
            .expect("get failed");

        println!("AFTER: Retrieved Marblestone fields:");
        println!("  weight={}", retrieved.weight);
        println!("  confidence={}", retrieved.confidence);
        println!("  is_amortized_shortcut={}", retrieved.is_amortized_shortcut);
        println!("  steering_reward={}", retrieved.steering_reward);
        println!("  traversal_count={}", retrieved.traversal_count);
        println!("  last_traversed_at={:?}", retrieved.last_traversed_at);

        assert_eq!(edge.is_amortized_shortcut, retrieved.is_amortized_shortcut);
        assert_eq!(edge.steering_reward, retrieved.steering_reward);
        assert_eq!(edge.traversal_count, retrieved.traversal_count);
        assert_eq!(edge.neurotransmitter_weights, retrieved.neurotransmitter_weights);
        assert!(retrieved.last_traversed_at.is_some());

        println!("RESULT: All Marblestone fields preserved ✓");
    }

    // =========================================================================
    // get_edge Tests
    // =========================================================================

    #[test]
    fn test_get_edge_not_found() {
        println!("=== TEST: get_edge returns NotFound ===");
        let (_tmp, db) = create_temp_db();
        let fake_source = Uuid::new_v4();
        let fake_target = Uuid::new_v4();

        println!("BEFORE: Querying non-existent edge");
        let result = db.get_edge(&amp;fake_source, &amp;fake_target, EdgeType::Semantic);
        println!("AFTER: Result = {:?}", result);

        assert!(result.is_err(), "Should fail for missing edge");
        assert!(matches!(result, Err(StorageError::NotFound { .. })));
        println!("RESULT: NotFound returned correctly (fail fast) ✓");
    }

    // =========================================================================
    // update_edge Tests
    // =========================================================================

    #[test]
    fn test_update_edge() {
        println!("=== TEST: update_edge ===");
        let (_tmp, db) = create_temp_db();
        let mut edge = create_test_edge();

        db.store_edge(&amp;edge).expect("store failed");
        println!("BEFORE: weight={}", edge.weight);

        edge.weight = 0.999;
        edge.steering_reward = 0.5;
        db.update_edge(&amp;edge).expect("update failed");

        let retrieved = db.get_edge(&amp;edge.source_id, &amp;edge.target_id, edge.edge_type)
            .expect("get failed");
        println!("AFTER: weight={}", retrieved.weight);

        assert_eq!(retrieved.weight, 0.999);
        assert_eq!(retrieved.steering_reward, 0.5);
        println!("RESULT: Edge updated correctly ✓");
    }

    // =========================================================================
    // delete_edge Tests
    // =========================================================================

    #[test]
    fn test_delete_edge() {
        println!("=== TEST: delete_edge ===");
        let (_tmp, db) = create_temp_db();
        let edge = create_test_edge();

        db.store_edge(&amp;edge).expect("store failed");
        println!("BEFORE: Edge stored");

        // Verify exists
        assert!(db.get_edge(&amp;edge.source_id, &amp;edge.target_id, edge.edge_type).is_ok());

        db.delete_edge(&amp;edge.source_id, &amp;edge.target_id, edge.edge_type)
            .expect("delete failed");
        println!("AFTER: Edge deleted");

        // Verify gone
        let result = db.get_edge(&amp;edge.source_id, &amp;edge.target_id, edge.edge_type);
        assert!(matches!(result, Err(StorageError::NotFound { .. })));
        println!("RESULT: Edge deleted correctly ✓");
    }

    // =========================================================================
    // get_edges_from Tests (prefix scan)
    // =========================================================================

    #[test]
    fn test_get_edges_from_prefix_scan() {
        println!("=== TEST: get_edges_from prefix scan ===");
        let (_tmp, db) = create_temp_db();
        let source = Uuid::new_v4();
        let target1 = Uuid::new_v4();
        let target2 = Uuid::new_v4();
        let target3 = Uuid::new_v4();

        // Create 3 outgoing edges from same source
        let edge1 = create_test_edge_between(source, target1, EdgeType::Semantic);
        let edge2 = create_test_edge_between(source, target2, EdgeType::Causal);
        let edge3 = create_test_edge_between(source, target3, EdgeType::Temporal);

        println!("BEFORE: Storing 3 edges from source {}", source);
        db.store_edge(&amp;edge1).expect("store1 failed");
        db.store_edge(&amp;edge2).expect("store2 failed");
        db.store_edge(&amp;edge3).expect("store3 failed");

        let edges = db.get_edges_from(&amp;source).expect("get_edges_from failed");
        println!("AFTER: Found {} edges", edges.len());

        assert_eq!(edges.len(), 3, "Should find all 3 outgoing edges");

        // Verify all edges have correct source
        for edge in &amp;edges {
            assert_eq!(edge.source_id, source, "All edges should have same source");
        }

        println!("RESULT: Prefix scan found all outgoing edges ✓");
    }

    #[test]
    fn test_get_edges_from_empty() {
        println!("=== TEST: get_edges_from returns empty vec ===");
        let (_tmp, db) = create_temp_db();
        let source = Uuid::new_v4();

        let edges = db.get_edges_from(&amp;source).expect("get_edges_from failed");
        assert!(edges.is_empty(), "Should return empty vec for no edges");
        println!("RESULT: Empty vec returned correctly ✓");
    }

    // =========================================================================
    // get_edges_to Tests (full scan)
    // =========================================================================

    #[test]
    fn test_get_edges_to_full_scan() {
        println!("=== TEST: get_edges_to full scan ===");
        let (_tmp, db) = create_temp_db();
        let source1 = Uuid::new_v4();
        let source2 = Uuid::new_v4();
        let source3 = Uuid::new_v4();
        let target = Uuid::new_v4();

        // Create 3 incoming edges to same target
        let edge1 = create_test_edge_between(source1, target, EdgeType::Semantic);
        let edge2 = create_test_edge_between(source2, target, EdgeType::Causal);
        let edge3 = create_test_edge_between(source3, target, EdgeType::Temporal);

        println!("BEFORE: Storing 3 edges to target {}", target);
        db.store_edge(&amp;edge1).expect("store1 failed");
        db.store_edge(&amp;edge2).expect("store2 failed");
        db.store_edge(&amp;edge3).expect("store3 failed");

        let edges = db.get_edges_to(&amp;target).expect("get_edges_to failed");
        println!("AFTER: Found {} edges", edges.len());

        assert_eq!(edges.len(), 3, "Should find all 3 incoming edges");

        // Verify all edges have correct target
        for edge in &amp;edges {
            assert_eq!(edge.target_id, target, "All edges should have same target");
        }

        println!("RESULT: Full scan found all incoming edges ✓");
    }

    // =========================================================================
    // Multiple Edge Types Tests
    // =========================================================================

    #[test]
    fn test_multiple_edge_types_same_nodes() {
        println!("=== TEST: Multiple edge types between same nodes ===");
        let (_tmp, db) = create_temp_db();
        let source = Uuid::new_v4();
        let target = Uuid::new_v4();

        // Create 4 edges with different types between same nodes
        for edge_type in EdgeType::all() {
            let edge = create_test_edge_between(source, target, edge_type);
            db.store_edge(&amp;edge).expect("store failed");
            println!("  Stored edge type {:?}", edge_type);
        }

        println!("BEFORE: Stored 4 edges (one per type) between same nodes");

        // Retrieve each edge type
        for edge_type in EdgeType::all() {
            let edge = db.get_edge(&amp;source, &amp;target, edge_type)
                .expect("get failed");
            assert_eq!(edge.edge_type, edge_type);
            println!("  Retrieved edge type {:?} ✓", edge_type);
        }

        // Verify get_edges_from returns all 4
        let edges = db.get_edges_from(&amp;source).expect("get_edges_from failed");
        assert_eq!(edges.len(), 4, "Should find all 4 edge types");

        println!("RESULT: Multiple edge types between same nodes work ✓");
    }

    // =========================================================================
    // Edge Case Tests (REQUIRED - print before/after state)
    // =========================================================================

    #[test]
    fn edge_case_extreme_weight_values() {
        println!("=== EDGE CASE: Extreme weight values ===");
        let (_tmp, db) = create_temp_db();

        let mut edge = create_test_edge();
        edge.weight = 0.0;
        edge.confidence = 1.0;
        edge.steering_reward = -1.0;

        println!("BEFORE: weight={}, confidence={}, steering={}",
            edge.weight, edge.confidence, edge.steering_reward);

        db.store_edge(&amp;edge).expect("store failed");
        let retrieved = db.get_edge(&amp;edge.source_id, &amp;edge.target_id, edge.edge_type)
            .expect("get failed");

        println!("AFTER: weight={}, confidence={}, steering={}",
            retrieved.weight, retrieved.confidence, retrieved.steering_reward);

        assert_eq!(retrieved.weight, 0.0);
        assert_eq!(retrieved.confidence, 1.0);
        assert_eq!(retrieved.steering_reward, -1.0);
        println!("RESULT: Extreme values preserved ✓");
    }

    #[test]
    fn edge_case_all_edge_types() {
        println!("=== EDGE CASE: All EdgeType variants ===");
        let (_tmp, db) = create_temp_db();

        for edge_type in EdgeType::all() {
            let edge = GraphEdge::new(
                Uuid::new_v4(),
                Uuid::new_v4(),
                edge_type,
                Domain::General,
            );
            println!("  Testing {:?}", edge_type);

            db.store_edge(&amp;edge).expect("store failed");
            let retrieved = db.get_edge(&amp;edge.source_id, &amp;edge.target_id, edge_type)
                .expect("get failed");

            assert_eq!(retrieved.edge_type, edge_type);
        }
        println!("RESULT: All EdgeType variants work ✓");
    }

    #[test]
    fn edge_case_all_domain_types() {
        println!("=== EDGE CASE: All Domain variants ===");
        let (_tmp, db) = create_temp_db();

        for domain in Domain::all() {
            let edge = GraphEdge::new(
                Uuid::new_v4(),
                Uuid::new_v4(),
                EdgeType::Semantic,
                domain,
            );
            println!("  Testing {:?}", domain);

            db.store_edge(&amp;edge).expect("store failed");
            let retrieved = db.get_edge(&amp;edge.source_id, &amp;edge.target_id, EdgeType::Semantic)
                .expect("get failed");

            assert_eq!(retrieved.domain, domain);
            assert_eq!(
                retrieved.neurotransmitter_weights,
                NeurotransmitterWeights::for_domain(domain)
            );
        }
        println!("RESULT: All Domain variants work ✓");
    }

    // =========================================================================
    // Helper Function Tests
    // =========================================================================

    #[test]
    fn test_format_edge_key() {
        let source = Uuid::new_v4();
        let target = Uuid::new_v4();
        let edge_type = EdgeType::Causal;

        let key = format_edge_key(&amp;source, &amp;target, edge_type);

        assert_eq!(key.len(), 33, "Key should be 16+16+1=33 bytes");

        // First 16 bytes = source UUID
        let source_bytes: [u8; 16] = key[0..16].try_into().unwrap();
        assert_eq!(source_bytes, serialize_uuid(&amp;source));

        // Next 16 bytes = target UUID
        let target_bytes: [u8; 16] = key[16..32].try_into().unwrap();
        assert_eq!(target_bytes, serialize_uuid(&amp;target));

        // Last byte = edge_type
        assert_eq!(key[32], edge_type as u8);
    }

    #[test]
    fn test_format_edge_prefix() {
        let source = Uuid::new_v4();
        let prefix = format_edge_prefix(&amp;source);

        assert_eq!(prefix.len(), 16, "Prefix should be 16 bytes");
        assert_eq!(prefix.as_slice(), serialize_uuid(&amp;source).as_slice());
    }

    // =========================================================================
    // Evidence Tests - Verify data actually exists in RocksDB
    // =========================================================================

    #[test]
    fn evidence_edge_exists_in_rocksdb() {
        println!("=== EVIDENCE: Edge exists in RocksDB CF ===");
        let (_tmp, db) = create_temp_db();
        let edge = create_test_edge();

        db.store_edge(&amp;edge).expect("store failed");

        // Directly check RocksDB CF
        let cf_edges = db.get_cf(cf_names::EDGES).unwrap();
        let key = format_edge_key(&amp;edge.source_id, &amp;edge.target_id, edge.edge_type);
        let value = db.db().get_cf(cf_edges, &amp;key).expect("direct read failed");

        assert!(value.is_some(), "Edge MUST exist in edges CF");
        println!("  edges CF: Edge exists ({} bytes) ✓", value.unwrap().len());
        println!("RESULT: Edge verified in RocksDB ✓");
    }
}
</tests>

<files_to_modify>
  <file path="crates/context-graph-storage/src/rocksdb_backend.rs">
    Add imports, helper functions, and Edge CRUD methods following Node CRUD pattern
  </file>
</files_to_modify>

<test_commands>
  <command>cargo build --package context-graph-storage</command>
  <command>cargo test --package context-graph-storage edge_crud -- --nocapture</command>
  <command>cargo test --package context-graph-storage format_edge -- --nocapture</command>
  <command>cargo test --package context-graph-storage evidence_edge -- --nocapture</command>
  <command>cargo clippy --package context-graph-storage -- -D warnings</command>
</test_commands>
</task_spec>
```

## CRITICAL CORRECTIONS FROM CODEBASE AUDIT

### 1. SYNC vs ASYNC Methods (CRITICAL FIX)
**OLD (WRONG)**: Task specified `pub async fn store_edge(...)`
**NEW (CORRECT)**: `pub fn store_edge(...)` - SYNC methods matching Node CRUD pattern

The existing `rocksdb_backend.rs` uses **synchronous methods**:
- `pub fn store_node(&self, node: &MemoryNode) -> Result<(), StorageError>`
- `pub fn get_node(&self, id: &NodeId) -> Result<MemoryNode, StorageError>`

Edge CRUD MUST follow the same pattern.

### 2. GraphEdge Location (CORRECTED)
**OLD**: `crates/context-graph-core/src/marblestone.rs`
**NEW**: `crates/context-graph-core/src/types/graph_edge.rs`

GraphEdge is defined in the types module, not marblestone.

### 3. GraphEdge Has 13 Fields (VERIFIED)
All 13 fields confirmed in `graph_edge.rs`:
1. `id: EdgeId` (Uuid)
2. `source_id: NodeId`
3. `target_id: NodeId`
4. `edge_type: EdgeType`
5. `weight: f32`
6. `confidence: f32`
7. `domain: Domain`
8. `neurotransmitter_weights: NeurotransmitterWeights`
9. `is_amortized_shortcut: bool`
10. `steering_reward: f32`
11. `traversal_count: u64` (NOT u32 as previously stated)
12. `created_at: DateTime<Utc>`
13. `last_traversed_at: Option<DateTime<Utc>>`

### 4. Serialization Uses Bincode (VERIFIED)
- `serialize_edge()` uses `bincode::serialize()`
- `deserialize_edge()` uses `bincode::deserialize()`
- MemoryNode uses MessagePack (rmp_serde), but GraphEdge uses bincode

### 5. Key Format (33 bytes)
- source_uuid: 16 bytes
- target_uuid: 16 bytes
- edge_type: 1 byte (as u8)
- Total: 33 bytes

## Full State Verification Requirements

After implementing the Edge CRUD operations, you MUST verify:

### Source of Truth Verification
1. **RocksDB Direct Read**: Verify edges exist in `edges` CF using `db.db().get_cf()`
2. **Key Format Validation**: Confirm keys are exactly 33 bytes
3. **Serialization Round-trip**: All 13 fields MUST be preserved exactly

### Boundary/Edge Case Audit
1. **Extreme Values**: weight=0.0, weight=1.0, steering_reward=-1.0, steering_reward=1.0
2. **All EdgeType Variants**: Semantic, Temporal, Causal, Hierarchical
3. **All Domain Variants**: All 8+ domains from Domain::all()
4. **Empty Results**: get_edges_from/get_edges_to with no matching edges
5. **Multiple Edge Types**: Same source/target with different edge types

### Evidence of Success (MANDATORY LOGS)
Every test MUST print:
```
=== TEST: [test name] ===
BEFORE: [state before operation]
AFTER: [state after operation]
RESULT: [PASS/FAIL reason] ✓
```

## Sherlock-Holmes Verification Step

After completing implementation, run the sherlock-holmes subagent to verify:

```
YOU MUST USE sherlock-holmes subagent to VERIFY THE ENTIRE TASK IS COMPLETE:
1. Verify all 6 methods exist and compile
2. Verify tests pass with --nocapture showing BEFORE/AFTER logs
3. Verify clippy passes with no warnings
4. Verify edges exist in RocksDB CF after store_edge
5. Verify all 13 GraphEdge fields are preserved
6. Verify prefix scan works correctly for get_edges_from
7. Verify NotFound error for missing edges
```

---

*Task ID: TASK-M02-018*
*Module: 02 - Core Infrastructure*
*Layer: Logic*
*Version: 2.0 - Audited and corrected 2025-01-01*
